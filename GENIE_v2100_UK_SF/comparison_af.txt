
Algorithm/AlgConfigPool.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Algorithm/AlgFactory.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Algorithm/AlgId.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Algorithm/Algorithm.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


AlvarezRuso/AlvarezRusoCOHPiPDXSec.cxx


AlvarezRuso/AlvarezRusoCOHPiPXSec.cxx


AlvarezRuso/ARConstants.cxx


AlvarezRuso/AREikonalSolution.cxx


AlvarezRuso/ARSampledNucleus.cxx


AlvarezRuso/ARWavefunction.cxx


AlvarezRuso/ARWFSolution.cxx


AlvarezRuso/IntegrationTools.cxx


Apps/gAtmoEvGen.cxx


Apps/gEvComp.cxx


Apps/gEvDump.cxx


Apps/gEvGen.cxx


Apps/gEvGenHadronNucleus.cxx


Apps/gEvPick.cxx


Apps/gEvScan.cxx


Apps/gFNALExptEvGen.cxx


Apps/gMakeSplines.cxx


Apps/gMasterclass.cxx


Apps/gMaxPathLengths.cxx


Apps/gNtpConv.cxx


Apps/gNucleonDecayEvGen.cxx


Apps/gRwght1Scan.cxx


Apps/gSplineAdd.cxx


Apps/gSplineXml2Root.cxx


Apps/gT2KEvGen.cxx


Apps/gUpMuFluxGen.cxx


Apps/gXSecComp.cxx


BaryonResonance/BaryonResList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


BaryonResonance/BaryonResUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/DISStructureFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/DISStructureFuncModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/QELFormFactors.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/QELFormFactorsModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/XSecAlgorithmI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Base/XSecIntegratorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


BergerSehgal/BergerSehgalCOHPiPXSec2015.cxx


BergerSehgal/BergerSehgalFMCOHPiPXSec2015.cxx


BodekYang/BYPDF.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


BodekYang/BYStrucFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Charm/AivazisCharmPXSecLO.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Charm/KovalenkoQELCharmPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Charm/SlowRsclCharmDISPXSecLO.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Coherent/COHElasticPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	*/
	//____________________________________________________________________________
	
 @ Feb 09, 2009 - CA
	#include <TMath.h>
	
	#include "Algorithm/AlgConfigPool.h"
	#include "Base/XSecIntegratorI.h"
	#include "Conventions/Constants.h"
	#include "Conventions/RefFrame.h"
	#include "Conventions/KineVar.h"
	#include "Coherent/COHElasticPXSec.h"
	#include "Messenger/Messenger.h"
	#include "PDG/PDGUtils.h"
	#include "Utils/KineUtils.h"
	#include "Utils/MathUtils.h"
	#include "Utils/NuclearUtils.h"
	
   Moved into the new Coherent package from its previous location  (Elastic
   package)

*/
//____________________________________________________________________________

#include <TMath.h>

#include "Algorithm/AlgConfigPool.h"
#include "Base/XSecIntegratorI.h"
#include "Conventions/Constants.h"
#include "Conventions/RefFrame.h"
#include "Conventions/KineVar.h"
#include "Coherent/COHElasticPXSec.h"
#include "Messenger/Messenger.h"
#include "PDG/PDGUtils.h"
#include "Utils/KineUtils.h"
#include "Utils/MathUtils.h"
#include "Utils/NuclearUtils.h"



Coherent/COHElHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	*/
	//____________________________________________________________________________
	
	#include <cstdlib>
	
	#include "Coherent/COHElHadronicSystemGenerator.h"
	#include "GHEP/GHepStatus.h"
	#include "GHEP/GHepParticle.h"
	#include "GHEP/GHepRecord.h"
	#include "Messenger/Messenger.h"
	
 @ Nov 29, 2007 - CA
	using namespace genie;
	
	//___________________________________________________________________________
	COHElHadronicSystemGenerator::COHElHadronicSystemGenerator() :
	HadronicSystemGenerator("genie::COHElHadronicSystemGenerator")
	{
	
	}
	//___________________________________________________________________________
	COHElHadronicSystemGenerator::COHElHadronicSystemGenerator(string config) :
	HadronicSystemGenerator("genie::COHElHadronicSystemGenerator", config)
	{
	
	}
	//___________________________________________________________________________
	COHElHadronicSystemGenerator::~COHElHadronicSystemGenerator()
	{
	
	}
	//___________________________________________________________________________
	void COHElHadronicSystemGenerator::ProcessEventRecord(GHepRecord * evrec) const
	{
	// This method generates the final state hadronic system in COH elastic events
	//
	  int imom = evrec->TargetNucleusPosition();
	  int pdgc = evrec->Particle(imom)->Pdg();
	
	  TLorentzVector p4nuc = this->Hadronic4pLAB(evrec);
	  TLorentzVector v4(0.,0.,0.,0.);
	
	  evrec->AddParticle(pdgc,kIStStableFinalState, imom,-1,-1,-1, p4nuc, v4);
	}
	//___________________________________________________________________________
	
   Was first added in 2.0.1
 @ Feb 09, 2009 - CA
   Moved into the new Coherent package from its previous location  (EVGModules 
   package) 

*/
//____________________________________________________________________________

#include <cstdlib>

#include "Coherent/COHElHadronicSystemGenerator.h"
#include "GHEP/GHepStatus.h"
#include "GHEP/GHepParticle.h"
#include "GHEP/GHepRecord.h"
#include "Messenger/Messenger.h"

using namespace genie;

//___________________________________________________________________________
COHElHadronicSystemGenerator::COHElHadronicSystemGenerator() :
HadronicSystemGenerator("genie::COHElHadronicSystemGenerator")
{

}
//___________________________________________________________________________
COHElHadronicSystemGenerator::COHElHadronicSystemGenerator(string config) :
HadronicSystemGenerator("genie::COHElHadronicSystemGenerator", config)
{

}
//___________________________________________________________________________
COHElHadronicSystemGenerator::~COHElHadronicSystemGenerator()
{

}
//___________________________________________________________________________
void COHElHadronicSystemGenerator::ProcessEventRecord(GHepRecord * evrec) const
{
// This method generates the final state hadronic system in COH elastic events
//
  int imom = evrec->TargetNucleusPosition();
  int pdgc = evrec->Particle(imom)->Pdg();

  TLorentzVector p4nuc = this->Hadronic4pLAB(evrec);
  TLorentzVector v4(0.,0.,0.,0.);

  evrec->AddParticle(pdgc,kIStStableFinalState, imom,-1,-1,-1, p4nuc, v4);
}
//___________________________________________________________________________



Coherent/COHElKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	        evrec->SetDiffXSec(xsec,kPSyfE);
	
	        return;
	     }
	  }// iterations
	}
	//___________________________________________________________________________
	double COHElKinematicsGenerator::ComputeMaxXSec(const Interaction * in) const
	{
	// Computes the maximum differential cross section in the requested phase
	// space. This method overloads KineGeneratorWithCache::ComputeMaxXSec
	// method and the value is cached at a circular cache branch for retrieval
	// during subsequent event generation.
	
	  SLOG("COHElKinematics", pDEBUG)
	          << "Scanning the allowed phase space {K} for the max(dxsec/d{K})";
	
	  double max_xsec = 0.;
	  const int N     = 50;
	
	  const KPhaseSpace & kps = in->PhaseSpace();
	  Range1D_t y = kps.YLim();
	
	  const double logymin = TMath::Log10(y.min);
	  const double logymax = TMath::Log10(y.max);
	  const double dlogy   = (logymax - logymin) /(N-1);
	
	  for(int i=0; i<N; i++) {
	     double y = TMath::Power(10, logymin+i*dlogy);
	     in->KinePtr()->Sety(y);
	
	     double xsec = fXSecModel->XSec(in, kPSyfE);
	     LOG("COHElKinematics", pDEBUG)  << "xsec(y= " << y << ") = " << xsec;
	     max_xsec = TMath::Max(max_xsec, xsec);
        // TODO: this is kPSxyfE on the dev branch, but I think kPSyfE is right
        evrec->SetDiffXSec(xsec,kPSyfE);

        return;
     }
  }// iterations
}
//___________________________________________________________________________
double COHElKinematicsGenerator::ComputeMaxXSec(const Interaction * in) const
{
// Computes the maximum differential cross section in the requested phase
// space. This method overloads KineGeneratorWithCache::ComputeMaxXSec
// method and the value is cached at a circular cache branch for retrieval
// during subsequent event generation.

  SLOG("COHElKinematics", pDEBUG)
          << "Scanning the allowed phase space {K} for the max(dxsec/d{K})";

  double max_xsec = 0.;
  const int N     = 50;

  const KPhaseSpace & kps = in->PhaseSpace();
  Range1D_t yr = kps.YLim();

  const double logymin = TMath::Log10(yr.min);
  const double logymax = TMath::Log10(yr.max);
  const double dlogy   = (logymax - logymin) /(N-1);

  for(int i=0; i<N; i++) {
     double y = TMath::Power(10, logymin+i*dlogy);
     in->KinePtr()->Sety(y);

     double xsec = fXSecModel->XSec(in, kPSyfE);
     LOG("COHElKinematics", pDEBUG)  << "xsec(y= " << y << ") = " << xsec;
     max_xsec = TMath::Max(max_xsec, xsec);


Coherent/COHHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
#include "Base/XSecAlgorithmI.h"
#include "EVGCore/EVGThreadException.h"
#include "EVGCore/EventGeneratorI.h"
#include "EVGCore/RunningThreadInfo.h"

  HadronicSystemGenerator("genie::COHHadronicSystemGenerator")
{

}
//___________________________________________________________________________
COHHadronicSystemGenerator::COHHadronicSystemGenerator(string config) :
	HadronicSystemGenerator("genie::COHHadronicSystemGenerator")
	{
	
	}
	//___________________________________________________________________________
	COHHadronicSystemGenerator::COHHadronicSystemGenerator(string config) :
  HadronicSystemGenerator("genie::COHHadronicSystemGenerator", config)
{

}
//___________________________________________________________________________
COHHadronicSystemGenerator::~COHHadronicSystemGenerator()
{

}
//___________________________________________________________________________
	HadronicSystemGenerator("genie::COHHadronicSystemGenerator", config)
	{
	
	}
	//___________________________________________________________________________
	COHHadronicSystemGenerator::~COHHadronicSystemGenerator()
	{
	
	}
	//___________________________________________________________________________
  // Access cross section algorithm for running thread
  RunningThreadInfo * rtinfo = RunningThreadInfo::Instance();
  const EventGeneratorI * evg = rtinfo->RunningThread();
  const XSecAlgorithmI *fXSecModel = evg->CrossSectionAlg();
  if (fXSecModel->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
    CalculateHadronicSystem_ReinSehgal(evrec);
  } else if ((fXSecModel->Id().Name() == "genie::BergerSehgalCOHPiPXSec2015")) {
    CalculateHadronicSystem_BergerSehgal(evrec);
  } else if ((fXSecModel->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec2015")) {
    CalculateHadronicSystem_BergerSehgalFM(evrec);
  } else if ((fXSecModel->Id().Name() == "genie::AlvarezRusoCOHPiPXSec")) {
    CalculateHadronicSystem_AlvarezRuso(evrec);
  }
  else {
    LOG("COHHadronicSystemGenerator",pFATAL) <<
      "ProcessEventRecord >> Cannot calculate hadronic system for " <<
      fXSecModel->Id().Name();
  }
}
//___________________________________________________________________________
int COHHadronicSystemGenerator::getPionPDGCodeFromXclTag(const XclsTag& xcls_tag) const
{
  int pion_pdgc = 0;
  if      (xcls_tag.NPi0()     == 1) pion_pdgc = kPdgPi0;
  else if (xcls_tag.NPiPlus()  == 1) pion_pdgc = kPdgPiP;
  else if (xcls_tag.NPiMinus() == 1) pion_pdgc = kPdgPiM;
  else {
    LOG("COHHadronicVtx", pFATAL)
      << "No final state pion information in XclsTag!";
    exit(1);
  }
  return pion_pdgc;
}
//___________________________________________________________________________
	// This method generates the final state hadronic system (pion + nucleus) in 
	// COH interactions
	//
	  RandomGen * rnd = RandomGen::Instance();
	
	  Interaction * interaction = evrec->Summary();
	  const XclsTag & xcls_tag  = interaction->ExclTag();
	
	  //-- Access neutrino, initial nucleus and final state prim. lepton entries
	  GHepParticle * nu  = evrec->Probe();
	  GHepParticle * Ni  = evrec->TargetNucleus();
	  GHepParticle * fsl = evrec->FinalStatePrimaryLepton();
	  assert(nu);
	  assert(Ni);
	  assert(fsl);
	
	  const TLorentzVector & vtx   = *(nu->X4());
	  const TLorentzVector & p4nu  = *(nu ->P4());
	  const TLorentzVector & p4fsl = *(fsl->P4());
	
	  //-- Determine the pdg code of the final state pion & nucleus
	  int nucl_pdgc = Ni->Pdg(); // same as the initial nucleus
	  int pion_pdgc = 0;
	  if      (xcls_tag.NPi0()     == 1) pion_pdgc = kPdgPi0;
	  else if (xcls_tag.NPiPlus()  == 1) pion_pdgc = kPdgPiP;
	  else if (xcls_tag.NPiMinus() == 1) pion_pdgc = kPdgPiM;
	  else {
	     LOG("COHHadronicVtx", pFATAL)
	               << "No final state pion information in XclsTag!";
	     exit(1);
	  }
	
	  //-- basic kinematic inputs
	  double E    = nu->E();  
	  double M    = kNucleonMass;
	  double mpi  = PDGLibrary::Instance()->Find(pion_pdgc)->Mass();
	  double mpi2 = TMath::Power(mpi,2);
	  double xo   = interaction->Kine().x(true); 
	  double yo   = interaction->Kine().y(true); 
	  double to   = interaction->Kine().t(true); 
	
	  SLOG("COHHadronicVtx", pINFO) 
	         << "Ev = "<< E << ", xo = " << xo 
void COHHadronicSystemGenerator::CalculateHadronicSystem_BergerSehgal(GHepRecord * evrec) const
{
  // Treatment of the hadronic side is identical to Rein-Sehgal if we assume an infinite 
  // mass for the nucleus.
  CalculateHadronicSystem_ReinSehgal(evrec);
}
//___________________________________________________________________________
void COHHadronicSystemGenerator::CalculateHadronicSystem_BergerSehgalFM(GHepRecord * evrec) const
{
  //
  // This method generates the final state hadronic system (pion + nucleus) in 
  // COH interactions
  //
  RandomGen * rnd = RandomGen::Instance();

  Interaction * interaction = evrec->Summary();
  const XclsTag & xcls_tag  = interaction->ExclTag();
  const InitialState & init_state = interaction -> InitState();

  //-- Access neutrino, initial nucleus and final state prim. lepton entries
  GHepParticle * nu  = evrec->Probe();
  GHepParticle * Ni  = evrec->TargetNucleus();
  GHepParticle * fsl = evrec->FinalStatePrimaryLepton();
  assert(nu);
  assert(Ni);
  assert(fsl);

  const TLorentzVector & vtx   = *(nu->X4());
  const TLorentzVector & p4nu  = *(nu ->P4());
  const TLorentzVector & p4fsl = *(fsl->P4());

  //-- Determine the pdg code of the final state pion & nucleus
  int nucl_pdgc = Ni->Pdg(); // same as the initial nucleus
  int pion_pdgc = getPionPDGCodeFromXclTag(xcls_tag);

  //-- basic kinematic inputs
  double E    = nu->E();  
  double Q2   = interaction->Kine().Q2(true);
  double y    = interaction->Kine().y(true); 
  double t    = interaction->Kine().t(true); 
  double MA   = init_state.Tgt().Mass(); 
  // double MA2  = TMath::Power(MA, 2.);   // Unused
  double mpi  = PDGLibrary::Instance()->Find(pion_pdgc)->Mass();
  double mpi2 = TMath::Power(mpi,2);

  SLOG("COHHadronicVtx", pINFO) 
    << "Ev = "<< E << ", Q^2 = " << Q2 
	                         << ", yo = " << yo << ", to = " << to;
	
	  //-- compute pion energy and |momentum|
	  double Epi  = yo * E;  
	  double Epi2 = TMath::Power(Epi,2);
	  double ppi2 = Epi2-mpi2;
	  double ppi  = TMath::Sqrt(TMath::Max(0.,ppi2));
	
	  SLOG("COHHadronicVtx", pINFO)
	                      << "f/s pion E = " << Epi << ", |p| = " << ppi;
	  assert(Epi>mpi);
	
	  //-- 4-momentum transfer q=p(neutrino) - p(f/s lepton)
	  //   Note: m^2 = q^2 < 0
	  //   Also, since the nucleus is heavy all energy loss is comminicated to
	  //   the outgoing pion  Rein & Sehgal, Nucl.Phys.B223.29-44(1983), p.35
	
	  TLorentzVector q = p4nu - p4fsl;
	
	  SLOG("COHHadronicVtx", pINFO) 
	          << "\n 4-p transfer q @ LAB: " << utils::print::P4AsString(&q);
	
	  //-- find angle theta between q and ppi (xi=costheta)
	  //   note: t=|(ppi-q)^2|, Rein & Sehgal, Nucl.Phys.B223.29-44(1983), p.36
	 
	  double xi = 1. + M*xo/Epi - 0.5*mpi2/Epi2 - 0.5*to/Epi2;
	  xi /= TMath::Sqrt((1.+2.*M*xo/Epi)*(1.-mpi2/Epi2));
	
	  double costheta  = xi;
	  double sintheta  = TMath::Sqrt(TMath::Max(0.,1.-xi*xi));
	
	  SLOG("COHHadronicVtx", pINFO) << "cos(pion, q) = " << costheta;
	
	  // compute transverse and longitudinal ppi components along q
	  double ppiL = ppi*costheta;
	  double ppiT = ppi*sintheta;
	
	  double phi = 2*kPi* rnd->RndHadro().Rndm();
	
	  TVector3 ppi3(0,ppiT,ppiL);
	
	  ppi3.RotateZ(phi);              // randomize transverse components
	  ppi3.RotateUz(q.Vect().Unit()); // align longit. component with q in LAB
	
	  SLOG("COHHadronicVtx", pINFO) 
	               << "Pion 3-p @ LAB: " << utils::print::Vec3AsString(&ppi3);
	
	  // now figure out the f/s nucleus 4-p
	
	  double pxNf = nu->Px() + Ni->Px() - fsl->Px() - ppi3.Px();
	  double pyNf = nu->Py() + Ni->Py() - fsl->Py() - ppi3.Py();
	  double pzNf = nu->Pz() + Ni->Pz() - fsl->Pz() - ppi3.Pz();
	  double ENf  = nu->E()  + Ni->E()  - fsl->E()  - Epi;
	
	  //-- Save the particles at the GHEP record
	
	  int mom = evrec->TargetNucleusPosition();
	  
	  evrec->AddParticle(
	     nucl_pdgc,kIStStableFinalState, mom,-1,-1,-1, 
	     pxNf, pyNf, pzNf, ENf, 0, 0, 0, 0);
	
	  evrec->AddParticle(
	     pion_pdgc,kIStStableFinalState, mom,-1,-1,-1, 
	     ppi3.Px(), ppi3.Py(),ppi3.Pz(),Epi, vtx.X(), vtx.Y(), vtx.Z(), vtx.T());
	}
	//___________________________________________________________________________
	
    << ", y = " << y << ", t = " << t;

  double Epi = y * E - t / (2 * MA);
  double ppi2   = Epi * Epi - mpi2;
  double ppi    = ppi2 > 0.0 ? TMath::Sqrt(ppi2) : 0.0;

  double costheta = (t - Q2 - mpi2) / (2 * ( (y *E - Epi) * Epi - 
       ppi * sqrt(TMath::Power(y * E - Epi, 2.) + t) ) );

  if ((costheta > 1.0) || (costheta < -1.0)) {
    SLOG("COHHadronicVtx", pERROR) 
      << "Unphysical pion angle!";
  }

  double sintheta = TMath::Sqrt(1 - costheta * costheta);

  //-- first work in the c.m.s. frame
  // double S        = 2 * MA * nuh - Q2 + MA2;
  // double S_2      = S >= 0 ? TMath::Sqrt(S) : 0.0;  // TODO - Error here?
  // double Pcm      = MA * TMath::Sqrt( (nuh*nuh + Q2)/S );
  // double Epi      = (S + mpi2 - MA2)/(2 * S_2);
  // double EAprime  = (S - mpi2 + MA2)/(2 * S_2);
  // double EA       = (S + MA2 + Q2)/(2 * S_2);
  // double PAprime2 = TMath::Power(EAprime,2.0) - MA2;
  // double PAprime  = TMath::Sqrt(PAprime2);
  // double tA       = TMath::Power((EAprime - EA),2.0) - TMath::Power(PAprime,2.0) - 
  //   TMath::Power(Pcm, 2.0);
  // double tB       = 2 * Pcm * PAprime;
  // double cosT     = (t - tA)/tB;
  // double sinT     = TMath::Sqrt(1 - cosT*cosT);
  // double PAz      = PAprime * cosT;
  // double PAperp   = PAprime * sinT;
  // double PPiz     = -PAz;

  // Randomize transverse components
  double phi    = 2 * kPi * rnd->RndHadro().Rndm();
  double ppix   = ppi * sintheta * TMath::Cos(phi);
  double ppiy   = ppi * sintheta * TMath::Sin(phi);
  double ppiz   = ppi * costheta;

  // boost back to the lab frame
  // double beta      = TMath::Sqrt( nuh*nuh + Q2 )/(nuh + MA);
  // double gamma     = (nuh + MA)/TMath::Sqrt(S);
  // double betagamma = beta * gamma;

  // double epi  = gamma*Epi + betagamma*PPiz;
  // double ppiz = betagamma*Epi + gamma*PPiz;

  // double ea  = gamma*EAprime + betagamma*PAz;
  // double paz = betagamma*EAprime + gamma*PAz;

  // Now rotate so our axes are aligned with the lab instead of q
  TLorentzVector q = p4nu - p4fsl;
  TVector3 ppi3(ppix, ppiy, ppiz);
  ppi3.RotateUz(q.Vect().Unit());

  // Nucleus...
  // TVector3 pa(PAx,PAy,paz);
  // pa.RotateUz(q.Vect().Unit());

  // now figure out the f/s nucleus 4-p

  double pxNf = nu->Px() + Ni->Px() - fsl->Px() - ppi3.Px();
  double pyNf = nu->Py() + Ni->Py() - fsl->Py() - ppi3.Py();
  double pzNf = nu->Pz() + Ni->Pz() - fsl->Pz() - ppi3.Pz();
  double ENf  = nu->E()  + Ni->E()  - fsl->E()  - Epi;

  //-- Save the particles at the GHEP record

  int mom = evrec->TargetNucleusPosition();

  // Nucleus - need to balance overall 4-momentum
  evrec->AddParticle(nucl_pdgc,kIStStableFinalState, mom,-1,-1,-1, 
                     pxNf, pyNf, pzNf, ENf, 0, 0, 0, 0);

  // evrec->AddParticle(
  //     nucl_pdgc,kIStStableFinalState, mom,-1,-1,-1,
  //     pa.Px(), pa.Py(), pa.Pz(), ea, 0, 0, 0, 0);

  evrec->AddParticle(
      pion_pdgc,kIStStableFinalState, mom,-1,-1,-1,
      ppi3.Px(), ppi3.Py(), ppi3.Pz(), Epi, vtx.X(), vtx.Y(), vtx.Z(), vtx.T());
}
//___________________________________________________________________________
void COHHadronicSystemGenerator::CalculateHadronicSystem_ReinSehgal(GHepRecord * evrec) const
{
  //
  // This method generates the final state hadronic system (pion + nucleus) in 
  // COH interactions
  //
  RandomGen * rnd = RandomGen::Instance();

  Interaction * interaction = evrec->Summary();
  const XclsTag & xcls_tag  = interaction->ExclTag();

  //-- Access neutrino, initial nucleus and final state prim. lepton entries
  GHepParticle * nu  = evrec->Probe();
  GHepParticle * Ni  = evrec->TargetNucleus();
  GHepParticle * fsl = evrec->FinalStatePrimaryLepton();
  assert(nu);
  assert(Ni);
  assert(fsl);

  const TLorentzVector & vtx   = *(nu->X4());
  const TLorentzVector & p4nu  = *(nu ->P4());
  const TLorentzVector & p4fsl = *(fsl->P4());

  //-- Determine the pdg code of the final state pion & nucleus
  int nucl_pdgc = Ni->Pdg(); // same as the initial nucleus
  int pion_pdgc = getPionPDGCodeFromXclTag(xcls_tag);

  //-- basic kinematic inputs
  double E    = nu->E();  
  double M    = kNucleonMass;
  double mpi  = PDGLibrary::Instance()->Find(pion_pdgc)->Mass();
  double mpi2 = TMath::Power(mpi,2);
  double xo   = interaction->Kine().x(true); 
  double yo   = interaction->Kine().y(true); 
  double to   = interaction->Kine().t(true); 

  SLOG("COHHadronicVtx", pINFO) 
    << "Ev = "<< E << ", xo = " << xo 
    << ", yo = " << yo << ", to = " << to;

  //-- compute pion energy and |momentum|
  double Epi  = yo * E;  
  double Epi2 = TMath::Power(Epi,2);
  double ppi2 = Epi2-mpi2;
  double ppi  = TMath::Sqrt(TMath::Max(0.,ppi2));

  SLOG("COHHadronicVtx", pINFO)
    << "f/s pion E = " << Epi << ", |p| = " << ppi;
  assert(Epi>mpi);

  //-- 4-momentum transfer q=p(neutrino) - p(f/s lepton)
  //   Note: m^2 = q^2 < 0
  //   Also, since the nucleus is heavy all energy loss is comminicated to
  //   the outgoing pion  Rein & Sehgal, Nucl.Phys.B223.29-44(1983), p.35

  TLorentzVector q = p4nu - p4fsl;

  SLOG("COHHadronicVtx", pINFO) 
    << "\n 4-p transfer q @ LAB: " << utils::print::P4AsString(&q);

  //-- find angle theta between q and ppi (xi=costheta)
  //   note: t=|(ppi-q)^2|, Rein & Sehgal, Nucl.Phys.B223.29-44(1983), p.36

  double xi = 1. + M*xo/Epi - 0.5*mpi2/Epi2 - 0.5*to/Epi2;
  xi /= TMath::Sqrt((1.+2.*M*xo/Epi)*(1.-mpi2/Epi2));

  double costheta  = xi;
  double sintheta  = TMath::Sqrt(TMath::Max(0.,1.-xi*xi));

  SLOG("COHHadronicVtx", pINFO) << "cos(pion, q) = " << costheta;

  // compute transverse and longitudinal ppi components along q
  double ppiL = ppi*costheta;
  double ppiT = ppi*sintheta;

  double phi = 2*kPi* rnd->RndHadro().Rndm();

  TVector3 ppi3(0,ppiT,ppiL);

  ppi3.RotateZ(phi);              // randomize transverse components
  ppi3.RotateUz(q.Vect().Unit()); // align longit. component with q in LAB

  SLOG("COHHadronicVtx", pINFO) 
    << "Pion 3-p @ LAB: " << utils::print::Vec3AsString(&ppi3);

  // now figure out the f/s nucleus 4-p

  double pxNf = nu->Px() + Ni->Px() - fsl->Px() - ppi3.Px();
  double pyNf = nu->Py() + Ni->Py() - fsl->Py() - ppi3.Py();
  double pzNf = nu->Pz() + Ni->Pz() - fsl->Pz() - ppi3.Pz();
  double ENf  = nu->E()  + Ni->E()  - fsl->E()  - Epi;

  //-- Save the particles at the GHEP record

  int mom = evrec->TargetNucleusPosition();

  evrec->AddParticle(nucl_pdgc,kIStStableFinalState, mom,-1,-1,-1, 
                     pxNf, pyNf, pzNf, ENf, 0, 0, 0, 0);

  evrec->AddParticle(pion_pdgc,kIStStableFinalState, mom,-1,-1,-1, 
                     ppi3.Px(), ppi3.Py(),ppi3.Pz(),Epi, vtx.X(), vtx.Y(), vtx.Z(), vtx.T());
}
//___________________________________________________________________________
void COHHadronicSystemGenerator::CalculateHadronicSystem_AlvarezRuso(GHepRecord * evrec) const
{
  Interaction * interaction = evrec->Summary();
  const Kinematics &   kinematics = interaction -> Kine();
  GHepParticle * nu  = evrec->Probe();
  GHepParticle * Ni  = evrec->TargetNucleus();
  GHepParticle * fsl = evrec->FinalStatePrimaryLepton();

  // Pion
  const TLorentzVector ppi  = kinematics.HadSystP4();
  const TVector3 ppi3 = ppi.Vect();
  const double Epi = ppi.E();
  int pion_pdgc=0;
  if ( interaction->ProcInfo().IsWeakCC() ) {
    if( nu->Pdg() > 0 ){ // neutrino
      pion_pdgc = kPdgPiP;
    }
    else{ // anti-neutrino
      pion_pdgc = kPdgPiM;
    }
  }
  else if ( interaction->ProcInfo().IsWeakNC() ) {
    pion_pdgc = kPdgPi0;
  }
  else{
    LOG("COHHadronicSystemGeneratorAR", pFATAL)
      << "Could not determine pion involved in interaction";
    exit(1);
  }

  //
  // Nucleus
  int nucl_pdgc = Ni->Pdg(); // pdg of final nucleus same as the initial nucleus
  double pxNf = nu->Px() + Ni->Px() - fsl->Px() - ppi3.Px();
  double pyNf = nu->Py() + Ni->Py() - fsl->Py() - ppi3.Py();
  double pzNf = nu->Pz() + Ni->Pz() - fsl->Pz() - ppi3.Pz();
  double ENf  = nu->E()  + Ni->E()  - fsl->E()  - Epi;
  //
  // Both
  const TLorentzVector & vtx   = *(nu->X4());
  int mom = evrec->TargetNucleusPosition();

  //
  // Fill the records
  evrec->AddParticle(nucl_pdgc,kIStStableFinalState, mom,-1,-1,-1,
                     pxNf, pyNf, pzNf, ENf, 0, 0, 0, 0);

  evrec->AddParticle(pion_pdgc,kIStStableFinalState, mom,-1,-1,-1,
                     ppi3.Px(), ppi3.Py(),ppi3.Pz(),Epi, vtx.X(), vtx.Y(), vtx.Z(), vtx.T());
}



Coherent/COHInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Coherent/COHKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	#include "Algorithm/AlgConfigPool.h"
	#include "Conventions/GBuild.h"
	#include "Conventions/Constants.h"
	#include "Conventions/Controls.h"
	#include "Conventions/Units.h"
	#include "Coherent/COHKinematicsGenerator.h"
	#include "Conventions/KinePhaseSpace.h"
	#include "EVGCore/EVGThreadException.h"
	#include "EVGCore/EventGeneratorI.h"
	#include "EVGCore/RunningThreadInfo.h"
	#include "GHEP/GHepRecord.h"
	#include "GHEP/GHepFlags.h"
#include "Math/Minimizer.h"
#include "Math/Factory.h"

#include "Algorithm/AlgConfigPool.h"
#include "Conventions/GBuild.h"
#include "Conventions/Constants.h"
#include "Conventions/Controls.h"
#include "Conventions/Units.h"
#include "Coherent/COHKinematicsGenerator.h"
#include "Conventions/KinePhaseSpace.h"
#include "EVGCore/EVGThreadException.h"
#include "EVGCore/EventGeneratorI.h"
#include "EVGCore/RunningThreadInfo.h"
#include "GHEP/GHepRecord.h"
#include "GHEP/GHepFlags.h"
	
#include "CrossSections/GSLXSecFunc.h"

  KineGeneratorWithCache("genie::COHKinematicsGenerator")
{
  fEnvelope = 0;
}
//___________________________________________________________________________
COHKinematicsGenerator::COHKinematicsGenerator(string config) :
	KineGeneratorWithCache("genie::COHKinematicsGenerator")
	{
	  fEnvelope = 0;
	}
	//___________________________________________________________________________
	COHKinematicsGenerator::COHKinematicsGenerator(string config) :
  KineGeneratorWithCache("genie::COHKinematicsGenerator", config)
{
  fEnvelope = 0;
}
//___________________________________________________________________________
COHKinematicsGenerator::~COHKinematicsGenerator()
{
  if(fEnvelope) delete fEnvelope;
}
//___________________________________________________________________________
	KineGeneratorWithCache("genie::COHKinematicsGenerator", config)
	{
	  fEnvelope = 0;
	}
	//___________________________________________________________________________
	COHKinematicsGenerator::~COHKinematicsGenerator()
	{
	  if(fEnvelope) delete fEnvelope;
	}
	//___________________________________________________________________________
      << "Generating kinematics uniformly over the allowed phase space";
  }

  //-- Access cross section algorithm for running thread
	          << "Generating kinematics uniformly over the allowed phase space";
	  }
	
	  Interaction * interaction = evrec->Summary();
	  interaction->SetBit(kISkipProcessChk);
	  interaction->SetBit(kISkipKinematicChk);
	
	  //-- Get the random number generators
	  RandomGen * rnd = RandomGen::Instance();
	
	  //-- Access cross section algorithm for running thread
	
	  //-- For the subsequent kinematic selection with the rejection method:
	  //   Calculate the max differential cross section or retrieve it from the
	  //   cache. Throw an exception and quit the evg thread if a non-positive
  if (fXSecModel->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
    CalculateKin_ReinSehgal(evrec);
  } else if (fXSecModel->Id().Name() == "genie::BergerSehgalCOHPiPXSec2015") {
    CalculateKin_BergerSehgal(evrec);
  } else if (fXSecModel->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec2015") {
    CalculateKin_BergerSehgalFM(evrec);
  } else if ((fXSecModel->Id().Name() == "genie::AlvarezRusoCOHPiPXSec")) {
    CalculateKin_AlvarezRuso(evrec);
  }
  else {
    LOG("COHKinematicsGenerator",pFATAL) <<
      "ProcessEventRecord >> Cannot calculate kinematics for " <<
      fXSecModel->Id().Name();
  }
}
//___________________________________________________________________________
	  //   value is found.
	  //   If the kinematics are generated uniformly over the allowed phase
	  //   space the max xsec is irrelevant
	  double xsec_max = (fGenerateUniformly) ? -1 : this->MaxXSec(evrec);
	
	  //-- Get the kinematical limits for the generated x,y
	  const KPhaseSpace & kps = interaction->PhaseSpace();
	  Range1D_t y = kps.YLim();
	  assert(y.min>0. && y.max>0. && y.min<1. && y.max<1. && y.min<y.max);
	
	  const double xmin = kASmallNum;
	  const double xmax = 1.- kASmallNum;
	  const double ymin = y.min + kASmallNum;
	  const double ymax = y.max - kASmallNum;
	  const double dx   = xmax - xmin;
	  const double dy   = ymax - ymin;
	
	  //------ Try to select a valid x,y pair
	
	  unsigned int iter = 0;
	  bool accept=false;
	  double xsec=-1, gx=-1, gy=-1;
	
void COHKinematicsGenerator::CalculateKin_BergerSehgal(GHepRecord * evrec) const
{
  // Get the Primary Interacton object
  Interaction * interaction = evrec->Summary();
  interaction->SetBit(kISkipProcessChk);
  interaction->SetBit(kISkipKinematicChk);    // TODO: Why turn this off?

  // Initialise a random number generator 
  RandomGen * rnd = RandomGen::Instance();

  //-- For the subsequent kinematic selection with the rejection method:
  //   Calculate the max differential cross section or retrieve it from the
  //   cache. Throw an exception and quit the evg thread if a non-positive
  //   value is found.
  //
  //   TODO: We are not offering the "fGenerateUniformly" option here.
  double xsec_max = this->MaxXSec(evrec);

  //-- Get the kinematical limits for the generated x,y
  const KPhaseSpace & kps = interaction->PhaseSpace();
  Range1D_t y  = kps.YLim();
  Range1D_t Q2(fQ2Min,fQ2Max);
  assert(y.min>0. && y.max>0. && y.min<1. && y.max<1. && y.min<y.max);

  const double ymin  = y.min + kASmallNum;
  const double ymax  = y.max - kASmallNum;
  const double dy    = ymax - ymin;
  const double Q2min = Q2.min + kASmallNum;
  const double Q2max = Q2.max - kASmallNum; 
  const double dQ2   = Q2max - Q2min;

  unsigned int iter = 0;
  bool accept=false;
  double xsec=-1, gy=-1, gQ2=-1;

	     iter++;
	     if(iter > kRjMaxIterations) {
    iter++;
    if(iter > kRjMaxIterations) this->throwOnTooManyIterations(iter,evrec);

	        LOG("COHKinematics", pWARN)
	             << "*** Could not select a valid (x,y) pair after "
	                                               << iter << " iterations";
	        evrec->EventFlags()->SetBitNumber(kKineGenErr, true);
	        genie::exceptions::EVGThreadException exception;
	        exception.SetReason("Couldn't select kinematics");
	        exception.SwitchOnFastForward();
    //-- Select unweighted kinematics using importance sampling method. 
	        throw exception;
	     }
	
	     if(fGenerateUniformly) {
	        //-- Generate a x,y pair uniformly in the kinematically allowed range.
	        gx = xmin + dx * rnd->RndKine().Rndm();
	        gy = ymin + dy * rnd->RndKine().Rndm();
	
	     } else {
	        //-- Select unweighted kinematics using importance sampling method. 
	
	        if(iter==1) {
	         LOG("COHKinematics", pNOTICE) << "Initializing the sampling envelope";
	         double Ev = interaction->InitState().ProbeE(kRfLab);
	         fEnvelope->SetRange(xmin,ymin,xmax,ymax);
	         fEnvelope->SetParameter(0, xsec_max);  
	         fEnvelope->SetParameter(1, Ev);        
	       }
	
	       // Generate W,QD2 using the 2-D envelope as PDF
	       fEnvelope->GetRandom2(gx,gy);
	     }
	
	     LOG("COHKinematics", pINFO) << "Trying: x = " << gx << ", y = " << gy;
	
	     interaction->KinePtr()->Setx(gx);
	     interaction->KinePtr()->Sety(gy);
	
	     // computing cross section for the current kinematics
    // TODO: The importance sampling envelope is not used. Currently, 
    // we just employ a standard rejection-method approach.

    gy  = ymin  + dy  * rnd->RndKine().Rndm(); 
    gQ2 = Q2min + dQ2 * rnd->RndKine().Rndm(); 

    LOG("COHKinematics", pINFO) << 
      "Trying: Q^2 = " << gQ2 << ", y = " << gy; /* << ", t = " << gt; */

    interaction->KinePtr()->Sety(gy);
    interaction->KinePtr()->SetQ2(gQ2);
    kinematics::UpdateXFromQ2Y(interaction);

    // computing cross section for the current kinematics
    xsec = fXSecModel->XSec(interaction, kPSQ2yfE);

    //-- decide whether to accept the current kinematics
    accept = (xsec_max * rnd->RndKine().Rndm() < xsec);

    //-- If the generated kinematics are accepted, finish-up module's job
    if(accept) {
      LOG("COHKinematics", pNOTICE)
        << "Selected: Q^2 = " << gQ2 << ", y = " << gy; /* << ", t = " << gt; */

      // the Berger-Sehgal COH cross section should be a triple differential cross section
      // d^2xsec/dQ2dydt where t is the the square of the 4p transfer to the
      // nucleus. The cross section used for kinematical selection should have
      // the t-dependence integrated out. The t-dependence is of the form
      // ~exp(-bt). Now that the x,y kinematical variables have been selected
      // we can generate a t using the t-dependence as a PDF.
      const InitialState & init_state = interaction->InitState();
      double Ev    = init_state.ProbeE(kRfLab);
      double Epi   = gy*Ev; // pion energy
      double Epi2  = TMath::Power(Epi,2);
      double pme2  = kPionMass2/Epi2;   
      double gx    = interaction->KinePtr()->x(); // utils::kinematics::Q2YtoX(Ev,kNucleonMass,gQ2,gy); // gQ2 / ( 2. * gy * kNucleonMass * Ev); 
      double xME   = kNucleonMass*gx/Epi;
      double tA    = 1. + xME - 0.5*pme2;
      /* Range1D_t tl = kps.TLim();   // this becomes the bounds for t */
      double tB    = TMath::Sqrt(1.+ 2*xME) * TMath::Sqrt(1.-pme2);
      double tmin  = 2*Epi2 * (tA-tB);
      double tmax  = 2*Epi2 * (tA+tB);
      double A     = (double) init_state.Tgt().A(); 
      double A13   = TMath::Power(A,1./3.);
      double R     = fRo * A13 * units::fermi; // nuclear radius
      double R2    = TMath::Power(R,2.);
      double b     = 0.33333 * R2;
      double tsum  = (TMath::Exp(-b*tmin) - TMath::Exp(-b*tmax))/b; 
      double rt    = tsum * rnd->RndKine().Rndm();
      double gt    = -1.*TMath::Log(-1.*b*rt + TMath::Exp(-1.*b*tmin))/b;

      // TODO: If we re-install the fGenerateUniformly option, we 
      // would compute the event weight here.

      // reset bits
      interaction->ResetBit(kISkipProcessChk);
      interaction->ResetBit(kISkipKinematicChk);

      // lock selected kinematics & clear running values
      interaction->KinePtr()->Setx(gx, true);
      interaction->KinePtr()->Sety(gy, true);
      interaction->KinePtr()->Sett(gt, true);
      interaction->KinePtr()->SetW(this->pionMass(interaction), true);
      interaction->KinePtr()->SetQ2(gQ2, true);
      interaction->KinePtr()->ClearRunningValues();

      // set the cross section for the selected kinematics
      evrec->SetDiffXSec(xsec * TMath::Exp(-b * gt) / tsum, kPSQ2yfE);

      return;
    }
  }// iterations
}
//___________________________________________________________________________
void COHKinematicsGenerator::CalculateKin_BergerSehgalFM(GHepRecord * evrec) const
{
  // Get the Primary Interacton object
  Interaction * interaction = evrec->Summary();
  interaction->SetBit(kISkipProcessChk);
  interaction->SetBit(kISkipKinematicChk);

  // Initialise a random number generator 
  RandomGen * rnd = RandomGen::Instance();

  //-- For the subsequent kinematic selection with the rejection method:
  //   Calculate the max differential cross section or retrieve it from the
  //   cache. Throw an exception and quit the evg thread if a non-positive
  //   value is found.
  //
  //   TODO: We are not offering the "fGenerateUniformly" option here.
  double xsec_max = this->MaxXSec(evrec);

  //-- Get the kinematical limits for the generated x,y
  const KPhaseSpace & kps = interaction->PhaseSpace();
  Range1D_t y  = kps.YLim();
  Range1D_t Q2(fQ2Min,fQ2Max);
  assert(y.min>0. && y.max>0. && y.min<1. && y.max<1. && y.min<y.max);

  const double ymin  = y.min + kASmallNum;
  const double ymax  = y.max - kASmallNum;
  const double dy    = ymax - ymin;
  const double Q2min = Q2.min + kASmallNum;
  const double Q2max = Q2.max - kASmallNum; 
  const double dQ2   = Q2max - Q2min;
  const double tmin  = kASmallNum;
  const double tmax  = fTMax - kASmallNum; // TODO: Choose realistic t bounds
  const double dt    = tmax - tmin;

  //-- Try to select a valid (Q^2,y,t) triple.

  unsigned int iter = 0;
  bool accept=false;
  double xsec=-1, gy=-1, gt=-1, gQ2=-1;

  while(1) {
    iter++;
    if(iter > kRjMaxIterations) this->throwOnTooManyIterations(iter,evrec);

    //-- Select unweighted kinematics using importance sampling method. 
    // TODO: The importance sampling envelope is not used. Currently, 
    // we just employ a standard rejection-method approach.

    gy  = ymin  + dy  * rnd->RndKine().Rndm(); 
    gt  = tmin  + dt  * rnd->RndKine().Rndm(); 
    gQ2 = Q2min + dQ2 * rnd->RndKine().Rndm(); 

    LOG("COHKinematics", pINFO) << 
      "Trying: Q^2 = " << gQ2 << ", y = " << gy << ", t = " << gt;

    interaction->KinePtr()->Sety(gy);
    interaction->KinePtr()->Sett(gt);  
    interaction->KinePtr()->SetQ2(gQ2);

    // computing cross section for the current kinematics
	     xsec = fXSecModel->XSec(interaction, kPSxyfE);
	
	     //-- decide whether to accept the current kinematics
	     if(!fGenerateUniformly) {
	        double max = fEnvelope->Eval(gx, gy);
	        double t   = max * rnd->RndKine().Rndm();
	
	        this->AssertXSecLimits(interaction, xsec, max);
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	        LOG("COHKinematics", pDEBUG) 
    xsec = fXSecModel->XSec(interaction, kPSxyfE);

    //-- decide whether to accept the current kinematics
    accept = (xsec_max * rnd->RndKine().Rndm() < xsec);

    //-- If the generated kinematics are accepted, finish-up module's job
    if(accept) {
      LOG("COHKinematics", pNOTICE)
        << "Selected: Q^2 = " << gQ2 << ", y = " << gy << ", t = " << gt; 

      // TODO: If we re-install the fGenerateUniformly option, we 
      // would compute the event weight here.

      // reset bits
      interaction->ResetBit(kISkipProcessChk);
      interaction->ResetBit(kISkipKinematicChk);

      // lock selected kinematics & clear running values
      interaction->KinePtr()->SetQ2(gQ2, true);
      interaction->KinePtr()->Sety(gy, true);
      interaction->KinePtr()->Sett(gt, true);
      interaction->KinePtr()->SetW(this->pionMass(interaction), true); 
      interaction->KinePtr()->ClearRunningValues();

      // set the cross section for the selected kinematics
      evrec->SetDiffXSec(xsec, kPSxytfE);

      return;
    }
  }// iterations
}
//___________________________________________________________________________
void COHKinematicsGenerator::CalculateKin_ReinSehgal(GHepRecord * evrec) const
{
  // Get the Primary Interacton object
  Interaction * interaction = evrec->Summary();
  interaction->SetBit(kISkipProcessChk);
  interaction->SetBit(kISkipKinematicChk);

  //-- Get the random number generators
  RandomGen * rnd = RandomGen::Instance();

  //-- For the subsequent kinematic selection with the rejection method:
  //   Calculate the max differential cross section or retrieve it from the
  //   cache. Throw an exception and quit the evg thread if a non-positive
  //   value is found.
  //   If the kinematics are generated uniformly over the allowed phase
  //   space the max xsec is irrelevant
  double xsec_max = (fGenerateUniformly) ? -1 : this->MaxXSec(evrec);

  //-- Get the kinematical limits for the generated x,y
  const KPhaseSpace & kps = interaction->PhaseSpace();
  Range1D_t y = kps.YLim();
  assert(y.min>0. && y.max>0. && y.min<1. && y.max<1. && y.min<y.max);

  const double xmin = kASmallNum;
  const double xmax = 1.- kASmallNum;
  const double ymin = y.min + kASmallNum;
  const double ymax = y.max - kASmallNum;
  const double dx   = xmax - xmin;
  const double dy   = ymax - ymin;

  //------ Try to select a valid x,y pair

  unsigned int iter = 0;
  bool accept=false;
  double xsec=-1, gx=-1, gy=-1;

  while(1) {
    iter++;
    if(iter > kRjMaxIterations) this->throwOnTooManyIterations(iter,evrec);

    if(fGenerateUniformly) {
      //-- Generate a x,y pair uniformly in the kinematically allowed range.
      gx = xmin + dx * rnd->RndKine().Rndm();
      gy = ymin + dy * rnd->RndKine().Rndm();

    } else {
      //-- Select unweighted kinematics using importance sampling method. 

      if(iter==1) {
        LOG("COHKinematics", pNOTICE) << "Initializing the sampling envelope";
        double Ev = interaction->InitState().ProbeE(kRfLab);
        fEnvelope->SetRange(xmin,ymin,xmax,ymax);
        fEnvelope->SetParameter(0, xsec_max);  
        fEnvelope->SetParameter(1, Ev);        
      }

      // Generate W,QD2 using the 2-D envelope as PDF
      fEnvelope->GetRandom2(gx,gy);
    }

    LOG("COHKinematics", pINFO) << "Trying: x = " << gx << ", y = " << gy;

    interaction->KinePtr()->Setx(gx);
    interaction->KinePtr()->Sety(gy);

    // computing cross section for the current kinematics
    xsec = fXSecModel->XSec(interaction, kPSxyfE);

    //-- decide whether to accept the current kinematics
    if(!fGenerateUniformly) {
      double max = fEnvelope->Eval(gx, gy);
      double t   = max * rnd->RndKine().Rndm();

      this->AssertXSecLimits(interaction, xsec, max);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
      LOG("COHKinematics", pDEBUG) 
        << "xsec= " << xsec << ", J= 1, Rnd= " << t;
#endif
      accept = (t<xsec);
    }
    else { 
      accept = (xsec>0);
    }

    //-- If the generated kinematics are accepted, finish-up module's job
    if(accept) {
      LOG("COHKinematics", pNOTICE) << "Selected: x = "<< gx << ", y = "<< gy;

      // the Rein-Sehgal COH cross section should be a triple differential cross section
      // d^2xsec/dxdydt where t is the the square of the 4p transfer to the
      // nucleus. The cross section used for kinematical selection should have
      // the t-dependence integrated out. The t-dependence is of the form
      // ~exp(-bt). Now that the x,y kinematical variables have been selected
      // we can generate a t using the t-dependence as a PDF.
      const InitialState & init_state = interaction->InitState();
      double Ev    = init_state.ProbeE(kRfLab);
      double Epi   = gy*Ev; // pion energy
      double Epi2  = TMath::Power(Epi,2);
      double pme2  = kPionMass2/Epi2;   
      double xME   = kNucleonMass*gx/Epi;
      double tA    = 1. + xME - 0.5*pme2;
      double tB    = TMath::Sqrt(1.+ 2*xME) * TMath::Sqrt(1.-pme2);
      double tmin  = 2*Epi2 * (tA-tB);
      double tmax  = 2*Epi2 * (tA+tB);
      double A     = (double) init_state.Tgt().A(); 
      double A13   = TMath::Power(A,1./3.);
      double R     = fRo * A13 * units::fermi; // nuclear radius
      double R2    = TMath::Power(R,2.);
      double b     = 0.33333 * R2;
      double tsum  = (TMath::Exp(-b*tmin) - TMath::Exp(-b*tmax))/b; 
      double rt    = tsum * rnd->RndKine().Rndm();
      double gt    = -1.*TMath::Log(-1.*b*rt + TMath::Exp(-1.*b*tmin))/b;

      LOG("COHKinematics", pNOTICE)
        << "Selected: t = "<< gt << ", from ["<< tmin << ", "<< tmax << "]";

      // for uniform kinematics, compute an event weight as
      // wght = (phase space volume)*(differential xsec)/(event total xsec)
      if(fGenerateUniformly) {
        double vol     = y.max-y.min; // dx=1, dt: irrelevant
        double totxsec = evrec->XSec();
        double wght    = (vol/totxsec)*xsec;
        LOG("COHKinematics", pNOTICE)  << "Kinematics wght = "<< wght;

        // apply computed weight to the current event weight
        wght *= evrec->Weight();
        LOG("COHKinematics", pNOTICE) << "Current event wght = " << wght;
        evrec->SetWeight(wght);
      }

      // reset bits
      interaction->ResetBit(kISkipProcessChk);
      interaction->ResetBit(kISkipKinematicChk);

      // lock selected kinematics & clear running values
      interaction->KinePtr()->Setx(gx, true);
      interaction->KinePtr()->Sety(gy, true);
      interaction->KinePtr()->Sett(gt, true);
      interaction->KinePtr()->SetW(kPionMass, true);
      interaction->KinePtr()->SetQ2(2*kNucleonMass*gx*gy*Ev, true);
      interaction->KinePtr()->ClearRunningValues();

      // set the cross section for the selected kinematics
      evrec->SetDiffXSec(xsec * TMath::Exp(-b * gt) / tsum, kPSxytfE);

      return;
    }
  }// iterations
}
//___________________________________________________________________________
void COHKinematicsGenerator::CalculateKin_AlvarezRuso(GHepRecord * evrec) const
{

  LOG("COHKinematics", pNOTICE) << "Using AlvarezRuso Model";
  // Get the Primary Interacton object
  Interaction * interaction = evrec->Summary();
  interaction->SetBit(kISkipProcessChk);
  interaction->SetBit(kISkipKinematicChk);

  // Initialise a random number generator 
  RandomGen * rnd = RandomGen::Instance();

  //-- For the subsequent kinematic selection with the rejection method:
  //   Calculate the max differential cross section or retrieve it from the
  //   cache. Throw an exception and quit the evg thread if a non-positive
  //   value is found.
  //   If the kinematics are generated uniformly over the allowed phase
  //   space the max xsec is irrelevant
  double xsec_max = (fGenerateUniformly) ? -1 : this->MaxXSec(evrec);

  //Set up limits of integration variables
  // Primary lepton energy
  const double E_l_min = interaction->FSPrimLepton()->Mass();
  const double E_l_max = interaction->InitStatePtr()->GetProbeP4(kRfLab)->E() - kPionMass;
  // Primary lepton angle with respect to the beam axis
  const double ctheta_l_min = 0.4;
  const double ctheta_l_max = 1.0 - kASmallNum;
  // Pion angle with respect to the beam axis
  const double ctheta_pi_min = 0.4;
  const double ctheta_pi_max = 1.0 - kASmallNum;
  // Pion angle transverse to the beam axis
  const double phi_min = kASmallNum;
  const double phi_max = (2.0 * kPi) - kASmallNum;
  // 
  const double d_E_l = E_l_max - E_l_min;
  const double d_ctheta_l  = ctheta_l_max  - ctheta_l_min;
  const double d_ctheta_pi = ctheta_pi_max - ctheta_pi_min;
  const double d_phi = phi_max - phi_min;

  //------ Try to select a valid set of kinematics
  unsigned int iter = 0;
  bool accept=false;
  double xsec=-1, g_E_l=-1, g_theta_l=-1, g_phi_l=-1, g_theta_pi=-1, g_phi_pi=-1;
  double g_ctheta_l, g_ctheta_pi;

  while(1) {
    iter++;
    if(iter > kRjMaxIterations) this->throwOnTooManyIterations(iter,evrec);

    //Select kinematic point
    g_E_l = E_l_min + d_E_l * rnd->RndKine().Rndm();
    g_ctheta_l  = ctheta_l_min  + d_ctheta_l  * rnd->RndKine().Rndm();
    g_ctheta_pi = ctheta_pi_min + d_ctheta_pi * rnd->RndKine().Rndm();
    g_phi_l = phi_min + d_phi * rnd->RndKine().Rndm();
    // random phi is relative to phi_l
    g_phi_pi = g_phi_l + (phi_min + d_phi * rnd->RndKine().Rndm()); 
    g_theta_l = TMath::ACos(g_ctheta_l);
    g_theta_pi = TMath::ACos(g_ctheta_pi);

    LOG("COHKinematics", pINFO) << "Trying: Lep(" <<g_E_l << ", " << 
      g_theta_l << ", " << g_phi_l << ") Pi(" << 
      g_theta_pi << ",     " << g_phi_pi << ")";

    this->SetKinematics(g_E_l, g_theta_l, g_phi_l, g_theta_pi, g_phi_pi, 
                        interaction, interaction->KinePtr());

    // computing cross section for the current kinematics
    xsec = fXSecModel->XSec(interaction,kPSElOlOpifE);

    if (!fGenerateUniformly) {
      //-- decide whether to accept the current kinematics
      double t   = xsec_max * rnd->RndKine().Rndm();

      LOG("COHKinematics", pINFO) << "Got: xsec = " << xsec << ", t = " << 
        t << " (max_xsec = " << xsec_max << ")";

      this->AssertXSecLimits(interaction, xsec, xsec_max);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
      LOG("COHKinematics", pDEBUG)
        << "xsec= " << xsec << ", J= 1, Rnd= " << t;
#endif
      accept = (t<xsec);
    }
    else {
      accept = (xsec>0);
    }

    //-- If the generated kinematics are accepted, finish-up module's job
    if(accept) {
      LOG("COHKinematics", pNOTICE) << "Selected: Lepton(" << 
        g_E_l << ", " << g_theta_l << ", " << 
        g_phi_l << ") Pion(" << g_theta_pi << ", " << g_phi_pi << ")";

      double E_l = g_E_l;
      double theta_l = g_theta_l;
      double theta_pi = g_theta_pi;
      double phi_l = g_phi_l;
      double phi_pi = g_phi_pi;
      const TLorentzVector P4_nu = *(interaction->InitStatePtr()->GetProbeP4(kRfLab));
      double E_nu       = P4_nu.E();
      double E_pi= E_nu-E_l;
      double m_l = interaction->FSPrimLepton()->Mass();
      double m_pi = this->pionMass(interaction);

      double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
      TVector3 lepton_3vector = TVector3(0,0,0);
      lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
      TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );

      double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
      TVector3 pion_3vector = TVector3(0,0,0);
      pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
      TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);

      TLorentzVector q = P4_nu - P4_lep;
      double Q2 = -q.Mag2();
      double x = Q2/(2*E_pi*constants::kNucleonMass);
      double y = E_pi/E_nu;

      double t = TMath::Abs( (q - P4_pion).Mag2() );

      // for uniform kinematics, compute an event weight as
      // wght = (phase space volume)*(differential xsec)/(event total xsec)
      if(fGenerateUniformly) {
        // Phase space volume needs checking
        double vol     = d_E_l*d_ctheta_l*d_phi*d_ctheta_pi*d_phi;
        double totxsec = evrec->XSec();
        double wght    = (vol/totxsec)*xsec;
        LOG("COHKinematics", pNOTICE)  << "Kinematics wght = "<< wght;

        // apply computed weight to the current event weight
        wght *= evrec->Weight();
        LOG("COHKinematics", pNOTICE) << "Current event wght = " << wght;
        evrec->SetWeight(wght);
      }

      // reset bits
      interaction->ResetBit(kISkipProcessChk);
      interaction->ResetBit(kISkipKinematicChk);
      // lock selected kinematics & clear running values
      interaction->KinePtr()->Setx(x, true);
      interaction->KinePtr()->Sety(y, true);
      interaction->KinePtr()->Sett(t, true);
      interaction->KinePtr()->SetW(kPionMass, true);
      interaction->KinePtr()->SetQ2(2*kNucleonMass*x*y*E_nu, true);
      interaction->KinePtr()->ClearRunningValues();
      // set the cross section for the selected kinematics
      evrec->SetDiffXSec(xsec,kPSElOlOpifE);
      return;
    }
  }//while
}
//___________________________________________________________________________
void COHKinematicsGenerator::SetKinematics(const double E_l,
                                           const double theta_l,
                                           const double phi_l,
                                           const double theta_pi,
                                           const double phi_pi,
                                           const Interaction* interaction,
                                           Kinematics* kinematics) const
{
  const TLorentzVector P4_nu = *(interaction->InitStatePtr()->GetProbeP4(kRfLab));
  double E_nu       = P4_nu.E();
  double E_pi= E_nu-E_l;
  double m_l = interaction->FSPrimLepton()->Mass();
  double m_pi;
  if ( interaction->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  } else {
    m_pi = constants::kPi0Mass;
  }
  double p_l=0.0;
  if (E_l > m_l) {
    p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
  }
  TVector3 lepton_3vector = TVector3(0,0,0);
  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );

  double p_pi=0.0;
  if (E_pi > m_pi) {
    p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
  }
  TVector3 pion_3vector = TVector3(0,0,0);
  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);

  double Q2 = -(P4_nu-P4_lep).Mag2();
  double x = Q2/(2*E_pi*constants::kNucleonMass);
  double y = E_pi/E_nu;

  kinematics->Setx(x);
  kinematics->Sety(y);
  kinematics::UpdateWQ2FromXY(interaction);

  kinematics->SetFSLeptonP4(P4_lep );
  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
}
//___________________________________________________________________________
bool COHKinematicsGenerator::CheckKinematics(const double E_l,
                                             const double /*  theta_l    */ ,  
                                             const double /*  phi_l      */ ,
                                             const double /*  theta_pi   */ ,
                                             const double /*  phi_pi     */ ,
                                             const Interaction* interaction) const
{
  const TLorentzVector P4_nu = *(interaction->InitStatePtr()->GetProbeP4(kRfLab));
  double E_nu       = P4_nu.E();
  double E_pi= E_nu-E_l;
  double m_l = interaction->FSPrimLepton()->Mass();
  double m_pi;
  if ( interaction->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  }
  else {
    m_pi = constants::kPi0Mass;
  }
  if (E_l <= m_l) {
    return false;
  }
  if (E_pi <= m_pi) {
    return false;
  }
  return true;
}
//___________________________________________________________________________
double COHKinematicsGenerator::ComputeMaxXSec(const Interaction * in) const
{
  // Computes the maximum differential cross section in the requested phase
  // space. This method overloads KineGeneratorWithCache::ComputeMaxXSec
  // method and the value is cached at a circular cache branch for retrieval
  // during subsequent event generation.

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  SLOG("COHKinematics", pDEBUG)
    << "Scanning the allowed phase space {K} for the max(dxsec/d{K})";
#endif
  double max_xsec = 0.;
  if (fXSecModel->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
    max_xsec = MaxXSec_ReinSehgal(in);
  } else if ((fXSecModel->Id().Name() == "genie::BergerSehgalCOHPiPXSec2015")) {
    max_xsec = MaxXSec_BergerSehgal(in);
  } else if ((fXSecModel->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec2015")) {
    max_xsec = MaxXSec_BergerSehgalFM(in);
  } else if ((fXSecModel->Id().Name() == "genie::AlvarezRusoCOHPiPXSec")) {
    max_xsec = MaxXSec_AlvarezRuso(in);
  }
  else {
    LOG("COHKinematicsGenerator",pFATAL) <<
      "ComputeMaxXSec >> Cannot calculate max cross-section for " <<
      fXSecModel->Id().Name();
  }

  // Apply safety factor, since value retrieved from the cache might
  // correspond to a slightly different energy.
  max_xsec *= fSafetyFactor;

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  SLOG("COHKinematics", pDEBUG) << in->AsString();
  SLOG("COHKinematics", pDEBUG) << "Max xsec in phase space = " << max_xsec;
  SLOG("COHKinematics", pDEBUG) << "Computed using alg = " << fXSecModel->Id();
#endif

  return max_xsec;
}
//___________________________________________________________________________
double COHKinematicsGenerator::MaxXSec_BergerSehgal(const Interaction * in) const
{
  double max_xsec = 0;
  const int NQ2   = 50;
  const int Ny    = 50;

  const KPhaseSpace & kps = in->PhaseSpace();
  Range1D_t Q2r = kps.Q2Lim();
  Q2r.max = fQ2Max;

  const double logQ2min = TMath::Log10(Q2r.min + kASmallNum);
  const double logQ2max = TMath::Log10(Q2r.max); 
  const double dlogQ2   = (logQ2max - logQ2min) /(NQ2-1);

  for(int i=0; i<NQ2; i++) {
    double Q2 = TMath::Power(10, logQ2min + i * dlogQ2);
    in->KinePtr()->SetQ2(Q2);

    Range1D_t yr;
    if (fPaschosSchallaXi >= 0) {
	            << "xsec= " << xsec << ", J= 1, Rnd= " << t;
	#endif
	        accept = (t<xsec);
	     }
	     else { 
	        accept = (xsec>0);
	     }
	
	     //-- If the generated kinematics are accepted, finish-up module's job
	     if(accept) {
	        LOG("COHKinematics", pNOTICE) << "Selected: x = "<< gx << ", y = "<< gy;
	
	        // the COH cross section should be a triple differential cross section
	        // d^2xsec/dxdydt where t is the the square of the 4p transfer to the
	        // nucleus. The cross section used for kinematical selection should have
	        // the t-dependence integrated out. The t-dependence is of the form
	        // ~exp(-bt). Now that the x,y kinematical variables have been selected
	        // we can generate a t using the t-dependence as a PDF.
	        const InitialState & init_state = interaction->InitState();
	        double Ev    = init_state.ProbeE(kRfLab);
	        double Epi   = gy*Ev; // pion energy
	        double Epi2  = TMath::Power(Epi,2);
	        double pme2  = kPionMass2/Epi2;   
	        double xME   = kNucleonMass*gx/Epi;
	        double tA    = 1. + xME - 0.5*pme2;
	        double tB    = TMath::Sqrt(1.+ 2*xME) * TMath::Sqrt(1.-pme2);
	        double tmin  = 2*Epi2 * (tA-tB);
	        double tmax  = 2*Epi2 * (tA+tB);
	        double A     = (double) init_state.Tgt().A(); 
	        double A13   = TMath::Power(A,1./3.);
	        double R     = fRo * A13 * units::fermi; // nuclear radius
	        double R2    = TMath::Power(R,2.);
	        double b     = 0.33333 * R2;
	        double tsum  = (TMath::Exp(-b*tmin) - TMath::Exp(-b*tmax))/b; 
	        double rt    = tsum * rnd->RndKine().Rndm();
	        double gt    = -1.*TMath::Log(-1.*b*rt + TMath::Exp(-1.*b*tmin))/b;
	
	        LOG("COHKinematics", pNOTICE)
	          << "Selected: t = "<< gt << ", from ["<< tmin << ", "<< tmax << "]";
	
	        // for uniform kinematics, compute an event weight as
	        // wght = (phase space volume)*(differential xsec)/(event total xsec)
	        if(fGenerateUniformly) {
	          double vol     = y.max-y.min; // dx=1, dt: irrelevant
	          double totxsec = evrec->XSec();
	          double wght    = (vol/totxsec)*xsec;
	          LOG("COHKinematics", pNOTICE)  << "Kinematics wght = "<< wght;
	
	          // apply computed weight to the current event weight
	          wght *= evrec->Weight();
	          LOG("COHKinematics", pNOTICE) << "Current event wght = " << wght;
	          evrec->SetWeight(wght);
	        }
	
	        // reset bits
	        interaction->ResetBit(kISkipProcessChk);
	        interaction->ResetBit(kISkipKinematicChk);
	
	        // lock selected kinematics & clear running values
	        interaction->KinePtr()->Setx(gx, true);
	        interaction->KinePtr()->Sety(gy, true);
	        interaction->KinePtr()->Sett(gt, true);
	        interaction->KinePtr()->SetW(kPionMass, true);
	        interaction->KinePtr()->SetQ2(2*kNucleonMass*gx*gy*Ev, true);
	        interaction->KinePtr()->ClearRunningValues();
	
	        // set the cross section for the selected kinematics
	        evrec->SetDiffXSec(xsec*TMath::Exp(-b*gt),kPSxytfE);
	
	        return;
	     }
	  }// iterations
	}
	//___________________________________________________________________________
	double COHKinematicsGenerator::ComputeMaxXSec(const Interaction * in) const
	{
	// Computes the maximum differential cross section in the requested phase
	// space. This method overloads KineGeneratorWithCache::ComputeMaxXSec
	// method and the value is cached at a circular cache branch for retrieval
	// during subsequent event generation.
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  SLOG("COHKinematics", pDEBUG)
	          << "Scanning the allowed phase space {K} for the max(dxsec/d{K})";
	#endif
	  double max_xsec = 0.;
	
	  double Ev = in->InitState().ProbeE(kRfLab);
	
	  const int Nx = 50;
	  const int Ny = 50;
	
	  const KPhaseSpace & kps = in->PhaseSpace();
	  Range1D_t y = kps.YLim();
	
	  const double logxmin = TMath::Log10(1E-5);
	  const double logxmax = TMath::Log10(1.0);
	  const double logymin = TMath::Log10(y.min);
	  const double logymax = TMath::Log10(y.max);
	/*
	  double dy=0;
	  double log10Ev = TMath::Log10(Ev);
	  double yc = TMath::Power(10,-0.5813-0.8492*log10Ev);
	  const double logymin = TMath::Log10( TMath::Max(y.min,yc-dy) );
	  const double logymax = TMath::Log10( TMath::Min(y.max,yc+dy) );
	*/
	  const double dlogx   = (logxmax - logxmin) /(Nx-1);
	  const double dlogy   = (logymax - logymin) /(Ny-1);
	
	  for(int i=0; i<Nx; i++) {
	   double gx = TMath::Power(10, logxmin + i * dlogx);
	   for(int j=0; j<Ny; j++) {
	     double gy = TMath::Power(10, logymin + j * dlogy);
	
	     double Q2 = 2*kNucleonMass*gx*gy*Ev;
	     if(Ev>1.0 && Q2>0.01) continue;
	
	     in->KinePtr()->Setx(gx);
	     in->KinePtr()->Sety(gy);
	
	     double xsec = fXSecModel->XSec(in, kPSxyfE);
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	     LOG("COHKinematics", pDEBUG)  
	     	 << "xsec(x= " << gx << ", y= " << gy << ") = " << xsec;
	#endif
	     max_xsec = TMath::Max(max_xsec, xsec);
	
	   }//y
	  }//x
	
	  // Apply safety factor, since value retrieved from the cache might
	  // correspond to a slightly different energy.
	  max_xsec *= fSafetyFactor;
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  SLOG("COHKinematics", pDEBUG) << in->AsString();
	  SLOG("COHKinematics", pDEBUG) << "Max xsec in phase space = " << max_xsec;
	  SLOG("COHKinematics", pDEBUG) << "Computed using alg = " << fXSecModel->Id();
	#endif
	
	  return max_xsec;
	}
	//___________________________________________________________________________
	double COHKinematicsGenerator::Energy(const Interaction * interaction) const
	{
	// Override the base class Energy() method to cache the max xsec for the
	// neutrino energy in the LAB rather than in the hit nucleon rest frame.
	
	  const InitialState & init_state = interaction->InitState();
	  double E = init_state.ProbeE(kRfLab);
	  return E;
	}
	//___________________________________________________________________________
	void COHKinematicsGenerator::Configure(const Registry & config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void COHKinematicsGenerator::Configure(string config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void COHKinematicsGenerator::LoadConfig(void)
	{
	  AlgConfigPool * confp = AlgConfigPool::Instance();
	  const Registry * gc = confp->GlobalParameterList();
	
	  //-- COH model parameter Ro
	  fRo = fConfig->GetDoubleDef("Ro", gc->GetDouble("COH-Ro"));
	
	  //-- max xsec safety factor (for rejection method) and min cached energy
	  fSafetyFactor = fConfig->GetDoubleDef("MaxXSec-SafetyFactor", 1.6);
	  fEMin         = fConfig->GetDoubleDef("Cache-MinEnergy",     -1.0);
	
	  //-- Generate kinematics uniformly over allowed phase space and compute
	  //   an event weight?
	  fGenerateUniformly = fConfig->GetBoolDef("UniformOverPhaseSpace", false);
	
	  //-- Maximum allowed fractional cross section deviation from maxim cross
	  //   section used in rejection method
	  fMaxXSecDiffTolerance = 
	         fConfig->GetDoubleDef("MaxXSec-DiffTolerance",999999.);
	  assert(fMaxXSecDiffTolerance>=0);
	
	  //-- Envelope employed when importance sampling is used 
	  //   (initialize with dummy range)
	  if(fEnvelope) delete fEnvelope;
	  fEnvelope = new TF2("envelope",
	    	  kinematics::COHImportanceSamplingEnvelope,0.,1,0.,1,2);
	}
	//____________________________________________________________________________
	
      yr = kps.YLim(fPaschosSchallaXi);
    } else {
      yr = kps.YLim();
    }
    if ((yr.max < 0) || (yr.max < yr.min) || 
        (yr.max > 1) || (yr.min < 0)) { // forbidden kinematics
      continue;
    }
    const double logymin  = TMath::Log10(yr.min);
    const double logymax  = TMath::Log10(yr.max);
    const double dlogy    = (logymax - logymin) /(Ny-1);

    for(int j=0; j<Ny; j++) {
      double gy = TMath::Power(10, logymin + j * dlogy);
      in->KinePtr()->Sety(gy);

      /* Range1D_t tl = kps.TLim();   // TESTING! - this becomes a loop over t */
      kinematics::UpdateXFromQ2Y(in);

      // Note: We're not stepping through log Q^2, log y - we "unpacked"
      double xsec = fXSecModel->XSec(in, kPSQ2yfE);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
      LOG("COHKinematics", pDEBUG)  
        << "xsec(Q2= " << Q2 << ", y= " << gy << ", t = " << gt << ") = " << xsec;
#endif
      max_xsec = TMath::Max(max_xsec, xsec);

    } // y
  } // Q2
  return max_xsec;
}
//___________________________________________________________________________
double COHKinematicsGenerator::MaxXSec_BergerSehgalFM(const Interaction * in) const
{
  double max_xsec = 0;
  // How many sampling bins in each variable for max xsec calculation?
  const int NQ2   = 50;
  const int Ny    = 50;
  const int Nt    = 50;

  const KPhaseSpace & kps = in->PhaseSpace();
  Range1D_t Q2r = kps.Q2Lim();
  Q2r.max = fQ2Max;

  const double logQ2min = TMath::Log10(Q2r.min + kASmallNum);
  const double logQ2max = TMath::Log10(Q2r.max); 
  const double logtmin  = TMath::Log10(kASmallNum);
  const double logtmax  = TMath::Log10(fTMax - kASmallNum); 
  const double dlogQ2   = (logQ2max - logQ2min) /(NQ2-1);
  const double dlogt    = (logtmax - logtmin) /(Nt-1);

  for(int i=0; i<NQ2; i++) {
    double Q2 = TMath::Power(10, logQ2min + i * dlogQ2);
    in->KinePtr()->SetQ2(Q2);

    Range1D_t yr;
    if (fPaschosSchallaXi >= 0) {
      yr = kps.YLim(fPaschosSchallaXi);
    } else {
      yr = kps.YLim();
    }
    if ((yr.max < 0) || (yr.max < yr.min) || 
        (yr.max > 1) || (yr.min < 0)) { // forbidden kinematics
      continue;
    }
    const double logymin  = TMath::Log10(yr.min);
    const double logymax  = TMath::Log10(yr.max);
    const double dlogy    = (logymax - logymin) /(Ny-1);

    for(int j=0; j<Ny; j++) {
      double gy = TMath::Power(10, logymin + j * dlogy);
      
      for(int k=0; k<Nt; k++) {
        double gt = TMath::Power(10, logtmin + k * dlogt);

        in->KinePtr()->Sety(gy);
        in->KinePtr()->Sett(gt);

        double xsec = fXSecModel->XSec(in, kPSxyfE);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
        LOG("COHKinematics", pDEBUG)  
          << "xsec(Q2= " << Q2 << ", y= " << gy << ", t = " << gt << ") = " << xsec;
#endif
        max_xsec = TMath::Max(max_xsec, xsec);

      } // t
    } // y
  } // Q2
  return max_xsec;
}
//___________________________________________________________________________
double COHKinematicsGenerator::MaxXSec_ReinSehgal(const Interaction * in) const
{
  double max_xsec = 0;
  double Ev = in->InitState().ProbeE(kRfLab);

  const int Nx = 50;
  const int Ny = 50;

  const KPhaseSpace & kps = in->PhaseSpace();
  Range1D_t y = kps.YLim();

  const double logxmin = TMath::Log10(1E-5);
  const double logxmax = TMath::Log10(1.0);
  const double logymin = TMath::Log10(y.min);
  const double logymax = TMath::Log10(y.max);

  const double dlogx   = (logxmax - logxmin) /(Nx-1);
  const double dlogy   = (logymax - logymin) /(Ny-1);

  for(int i=0; i<Nx; i++) {
    double gx = TMath::Power(10, logxmin + i * dlogx);
    for(int j=0; j<Ny; j++) {
      double gy = TMath::Power(10, logymin + j * dlogy);

      double Q2 = 2*kNucleonMass*gx*gy*Ev;
      if(Ev>1.0 && Q2>0.01) continue;

      in->KinePtr()->Setx(gx);
      in->KinePtr()->Sety(gy);

      double xsec = fXSecModel->XSec(in, kPSxyfE);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
      LOG("COHKinematics", pDEBUG)  
        << "xsec(x= " << gx << ", y= " << gy << ") = " << xsec;
#endif
      max_xsec = TMath::Max(max_xsec, xsec);

    }//y
  }//x
  return max_xsec;
}
//___________________________________________________________________________
double COHKinematicsGenerator::MaxXSec_AlvarezRuso(const Interaction * in) const
{
  // Computes the maximum differential cross section in the requested phase
  // space. This method overloads KineGeneratorWithCache::ComputeMaxXSec
  // method and the value is cached at a circular cache branch for retrieval
  // during subsequent event generation.

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  SLOG("COHKinematics", pDEBUG)
    << "Scanning the allowed phase space {K} for the max(dxsec/d{K})";
#endif
  double max_xsec = 0.;
  double Ev = in->InitState().ProbeE(kRfLab);

  const KPhaseSpace & kps = in->PhaseSpace();
  Range1D_t y = kps.YLim();

  ROOT::Math::Minimizer * min = ROOT::Math::Factory::CreateMinimizer("Minuit2");
  gsl::d4Xsec_dEldThetaldOmegapi f(fXSecModel,in);
  f.SetFactor(-1.); // Make it return negative of cross-section so we can minimize

  min->SetFunction( f );
  min->SetMaxFunctionCalls(10000);
  min->SetTolerance(0.05);

  const double min_el = in->FSPrimLepton()->Mass();
  const double max_el = Ev - kPionMass;
  const unsigned int n_el = 100;
  const double d_el = (max_el - min_el) / double(n_el - 1);

  const double min_thetal = kASmallNum;
  const double max_thetal = kPi / 4.0;
  const unsigned int n_thetal = 10;
  const double d_thetal = (max_thetal - min_thetal) / double(n_thetal - 1);

  const double min_thetapi = kASmallNum;
  const double max_thetapi = kPi / 2.0;
  const unsigned int n_thetapi = 10;
  const double d_thetapi = (max_thetapi - min_thetapi) / double(n_thetapi - 1);

  //~ const double min_phipi = kPi;
  //~ const double max_phipi = 0.5 * kPi;
  const double min_phipi = kASmallNum;
  const double max_phipi = 2*kPi-kASmallNum;
  const unsigned int n_phipi = 10;
  const double d_phipi = (max_phipi - min_phipi) / double(n_phipi - 1);

  min->SetLimitedVariable ( 0 ,"E_lep"    , max_el     -kASmallNum , d_el      , min_el     , max_el      );
  min->SetLimitedVariable ( 1 ,"theta_l"  , min_thetal +kASmallNum , d_thetal  , min_thetal , max_thetal  );
  min->SetLimitedVariable ( 2 ,"theta_pi" , min_thetapi+kASmallNum , d_thetapi , min_thetapi, max_thetapi );
  min->SetLimitedVariable ( 3 ,"phi_pi"   , min_phipi  +kASmallNum , d_phipi   , min_phipi  , max_phipi   );

  min->Minimize();
  max_xsec = -min->MinValue(); //back to positive xsec

  // Apply safety factor, since value retrieved from the cache might
  // correspond to a slightly different energy.
  max_xsec *= fSafetyFactor;

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  SLOG("COHKinematics", pDEBUG) << in->AsString();
  SLOG("COHKinematics", pDEBUG) << "Max xsec in phase space = " << max_xsec;
  SLOG("COHKinematics", pDEBUG) << "Computed using alg = " << fXSecModel->Id();
#endif

  delete min;

  return max_xsec;
}
//___________________________________________________________________________
double COHKinematicsGenerator::Energy(const Interaction * interaction) const
{
  // Override the base class Energy() method to cache the max xsec for the
  // neutrino energy in the LAB rather than in the hit nucleon rest frame.

  const InitialState & init_state = interaction->InitState();
  double E = init_state.ProbeE(kRfLab);
  return E;
}
//___________________________________________________________________________
double COHKinematicsGenerator::pionMass(const Interaction* in) const
{
  double m_pi = 0.0;
  if ( in->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  } else {
    m_pi = constants::kPi0Mass;
  }
  return m_pi;
}
//___________________________________________________________________________
void COHKinematicsGenerator::throwOnTooManyIterations(unsigned int iters,
                                                      GHepRecord* evrec) const
{
  LOG("COHKinematics", pWARN)
    << "*** Could not select valid kinematics after "
    << iters << " iterations";
  evrec->EventFlags()->SetBitNumber(kKineGenErr, true);
  genie::exceptions::EVGThreadException exception;
  exception.SetReason("Couldn't select kinematics");
  exception.SwitchOnFastForward();
  throw exception;
}
//___________________________________________________________________________
void COHKinematicsGenerator::Configure(const Registry & config)
{
  Algorithm::Configure(config);
  this->LoadConfig();
}
//____________________________________________________________________________
void COHKinematicsGenerator::Configure(string config)
{
  Algorithm::Configure(config);
  this->LoadConfig();
}
//____________________________________________________________________________
void COHKinematicsGenerator::LoadConfig(void)
{
  AlgConfigPool * confp = AlgConfigPool::Instance();
  const Registry * gc = confp->GlobalParameterList();

  //-- COH model parameter Ro
  fRo = fConfig->GetDoubleDef("Ro", gc->GetDouble("COH-Ro"));
  //-- COH model parameter t_max for t = (q - p_pi)^2
  fTMax = fConfig->GetDoubleDef("COH-t-max", gc->GetDouble("COH-t-max"));
  //-- COH model bounds of integration for Q^2
  fQ2Min = fConfig->GetDoubleDef("COH-Q2-min", gc->GetDouble("COH-Q2-min"));
  fQ2Max = fConfig->GetDoubleDef("COH-Q2-max", gc->GetDouble("COH-Q2-max"));

  //-- max xsec safety factor (for rejection method) and min cached energy
  fSafetyFactor = fConfig->GetDoubleDef("MaxXSec-SafetyFactor", 1.6);
  fEMin         = fConfig->GetDoubleDef("Cache-MinEnergy",     -1.0);

  //-- Generate kinematics uniformly over allowed phase space and compute
  //   an event weight?
  fGenerateUniformly = fConfig->GetBoolDef("UniformOverPhaseSpace", false);

  //-- Maximum allowed fractional cross section deviation from maxim cross
  //   section used in rejection method
  fMaxXSecDiffTolerance = 
    fConfig->GetDoubleDef("MaxXSec-DiffTolerance",999999.);
  assert(fMaxXSecDiffTolerance>=0);

  //-- nu_min scaling from Paschos, Schalla PRD 80 033005
  fPaschosSchallaXi = 
    fConfig->GetDoubleDef("COH-PaschosSchallaXi",
                          gc->GetDouble("COH-PaschosSchallaXi"));

  //-- Envelope employed when importance sampling is used 
  //   (initialize with dummy range)
  if(fEnvelope) delete fEnvelope;
  fEnvelope = new TF2("envelope",
                      kinematics::COHImportanceSamplingEnvelope,0.,1,0.,1,2);
}
//____________________________________________________________________________



Coherent/COHPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
#include "Base/XSecAlgorithmI.h"
#include "EVGCore/EVGThreadException.h"
#include "EVGCore/EventGeneratorI.h"
#include "EVGCore/RunningThreadInfo.h"

  PrimaryLeptonGenerator("genie::COHPrimaryLeptonGenerator")
{

}
//___________________________________________________________________________
COHPrimaryLeptonGenerator::COHPrimaryLeptonGenerator(string config) :
	PrimaryLeptonGenerator("genie::COHPrimaryLeptonGenerator")
	{
	
	}
	//___________________________________________________________________________
	COHPrimaryLeptonGenerator::COHPrimaryLeptonGenerator(string config) :
  PrimaryLeptonGenerator("genie::COHPrimaryLeptonGenerator", config)
{

}
//___________________________________________________________________________
COHPrimaryLeptonGenerator::~COHPrimaryLeptonGenerator()
{

}
//___________________________________________________________________________
	PrimaryLeptonGenerator("genie::COHPrimaryLeptonGenerator", config)
	{
	
	}
	//___________________________________________________________________________
	COHPrimaryLeptonGenerator::~COHPrimaryLeptonGenerator()
	{
	
	}
	//___________________________________________________________________________
  //-- Access cross section algorithm for running thread
  RunningThreadInfo * rtinfo = RunningThreadInfo::Instance();
  const EventGeneratorI * evg = rtinfo->RunningThread();
  const XSecAlgorithmI *fXSecModel = evg->CrossSectionAlg();

  // In Rein and Berger-Sehgal, no modification is required to the standard impl.
  if (fXSecModel->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
    PrimaryLeptonGenerator::ProcessEventRecord(evrec);
  }
  else if ((fXSecModel->Id().Name() == "genie::BergerSehgalCOHPiPXSec2015")) {
    PrimaryLeptonGenerator::ProcessEventRecord(evrec);
  }
  else if ((fXSecModel->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec2015")) {
    PrimaryLeptonGenerator::ProcessEventRecord(evrec);
  }
  else if ((fXSecModel->Id().Name() == "genie::AlvarezRusoCOHPiPXSec")) {
    CalculatePrimaryLepton_AlvarezRuso(evrec);
  }
  else {
    LOG("COHPrimaryLeptonGenerator",pFATAL) <<
      "ProcessEventRecord >> Cannot calculate primary lepton for " <<
      fXSecModel->Id().Name();
  }
}
//___________________________________________________________________________
	// This method generates the final state primary lepton in COH events
	
	  Interaction * interaction = evrec->Summary();
	  const InitialState & init_state = interaction->InitState();
	
	  // Look-up selected kinematics
	  double Q2 = interaction->Kine().Q2(true);
	  double y  = interaction->Kine().y(true);
	
	  // Auxiliary params
	  double Ev  = init_state.ProbeE(kRfLab);
	  double ml  = interaction->FSPrimLepton()->Mass();
	  double ml2 = TMath::Power(ml,2);
	
	  // Compute the final state primary lepton energy and momentum components
	  // along and perpendicular the neutrino direction 
	  double El  = (1-y)*Ev;
	  double plp = El - 0.5*(Q2+ml2)/Ev;                          // p(//)
	  double plt = TMath::Sqrt(TMath::Max(0.,El*El-plp*plp-ml2)); // p(-|)
	
	  LOG("LeptonicVertex", pNOTICE)
	          << "fsl: E = " << El << ", |p//| = " << plp << "[pT] = " << plt;
	
	  // Randomize transverse components
	  RandomGen * rnd = RandomGen::Instance();
	  double phi  = 2*kPi * rnd->RndLep().Rndm();
	  double pltx = plt * TMath::Cos(phi);
	  double plty = plt * TMath::Sin(phi);
	
	  // Take a unit vector along the neutrino direction
	  TVector3 unit_nudir = evrec->Probe()->P4()->Vect().Unit();
	
	  // Rotate lepton momentum vector from the reference frame (x'y'z') where 
void COHPrimaryLeptonGenerator::CalculatePrimaryLepton_AlvarezRuso(GHepRecord * evrec) const
{
  Interaction * interaction = evrec->Summary();
  const Kinematics & kinematics = interaction->Kine();
  TLorentzVector p4l = kinematics.FSLeptonP4();
  int pdgc = interaction->FSPrimLepton()->PdgCode();
  this->AddToEventRecord(evrec, pdgc, p4l);
}
//___________________________________________________________________________
	  // {z':(neutrino direction), z'x':(theta plane)} to the LAB
	  TVector3 p3l(pltx,plty,plp);
	  p3l.RotateUz(unit_nudir);
	
	  // Lepton 4-momentum in LAB
	  TLorentzVector p4l(p3l,El);
	
	  // Figure out the Final State Lepton PDG Code
	  int pdgc = interaction->FSPrimLepton()->PdgCode();
	
	  // Create a GHepParticle and add it to the event record
	  this->AddToEventRecord(evrec, pdgc, p4l);
	
	  // Set final state lepton polarization
	  this->SetPolarization(evrec);
	}
	//___________________________________________________________________________


CrossSections/COHXSecAR.cxx


CrossSections/COHXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
#include "Algorithm/AlgConfigPool.h"
	  Q2l.max = 1.0;  // TODO - No magic numbers! 
	
	  Interaction * interaction = new Interaction(*in);
	  interaction->SetBit(kISkipProcessChk);
	  //interaction->SetBit(kISkipKinematicChk);
	
	  double xsec = 0.0;
	
	  if (model->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
	    LOG("COHXSec", pINFO)
  Q2l.max = fQ2Max;

  Interaction * interaction = new Interaction(*in);
  interaction->SetBit(kISkipProcessChk);
  //interaction->SetBit(kISkipKinematicChk);

  double xsec = 0.0;

  if (model->Id().Name() == "genie::ReinSehgalCOHPiPXSec") {
    LOG("COHXSec", pINFO)
	  else if (model->Id().Name() == "genie::BergerSehgalCOHPiPXSec" || 
  else if (model->Id().Name() == "genie::BergerSehgalCOHPiPXSec2015")
  {
	           model->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec") 
	  {
	
	  const InitialState & init_state = in->InitState();
	  double Ev = init_state.ProbeE(kRfLab);
  else if (model->Id().Name() == "genie::BergerSehgalFMCOHPiPXSec2015") 
  {
	  LOG("COHXSec", pINFO) << "XSec[COH] (E = " << Ev << " GeV) = " << xsec;
	
	  delete interaction;
	
    Range1D_t tl;
	  return xsec;
	}
	//____________________________________________________________________________
    tl.min = controls::kASmallNum;
    tl.max = fTMax;

    ROOT::Math::IBaseFunctionMultiDim * func = 
      new utils::gsl::d2XSec_dQ2dydt_E(model, interaction);
    ROOT::Math::IntegrationMultiDim::Type ig_type = 
      utils::gsl::IntegrationNDimTypeFromString(fGSLIntgType);
    ROOT::Math::IntegratorMultiDim ig(ig_type);
    ig.SetRelTolerance(fGSLRelTol);
    ig.SetFunction(*func);
    if (ig_type == ROOT::Math::IntegrationMultiDim::kADAPTIVE) {
    ROOT::Math::AdaptiveIntegratorMultiDim * cast =
      dynamic_cast<ROOT::Math::AdaptiveIntegratorMultiDim*>( ig.GetIntegrator() );
      assert(cast);
      cast->SetMinPts(fGSLMinEval);
    }
    double kine_min[3] = { Q2l.min, yl.min, tl.min };
    double kine_max[3] = { Q2l.max, yl.max, tl.max };
	void COHXSec::Configure(const Registry & config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void COHXSec::Configure(string config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void COHXSec::LoadConfig(void)
	{
	  // Get GSL integration type & relative tolerance
	  fGSLIntgType = fConfig->GetStringDef("gsl-integration-type",  "adaptive");
	  fGSLRelTol   = fConfig->GetDoubleDef("gsl-relative-tolerance", 1E-2); 
	  fGSLMaxEval  = (unsigned int) fConfig->GetIntDef ("gsl-max-eval", 500000); 
	  fGSLMinEval  = (unsigned int) fConfig->GetIntDef ("gsl-min-eval",  5000); 
	}
	//____________________________________________________________________________
    xsec = ig.Integral(kine_min, kine_max) * (1E-38 * units::cm2);
    delete func;
  }

  const InitialState & init_state = in->InitState();
  double Ev = init_state.ProbeE(kRfLab);
  LOG("COHXSec", pINFO) << "XSec[COH] (E = " << Ev << " GeV) = " << xsec;

  delete interaction;

  return xsec;
}
//____________________________________________________________________________
void COHXSec::Configure(const Registry & config)
{
  Algorithm::Configure(config);
  this->LoadConfig();
}
//____________________________________________________________________________
void COHXSec::Configure(string config)
{
  Algorithm::Configure(config);
  this->LoadConfig();
}
//____________________________________________________________________________
void COHXSec::LoadConfig(void)
{
  AlgConfigPool * confp = AlgConfigPool::Instance();
  const Registry * gc = confp->GlobalParameterList();

  // Get GSL integration type & relative tolerance
  fGSLIntgType = fConfig->GetStringDef("gsl-integration-type",  "adaptive");
  fGSLRelTol   = fConfig->GetDoubleDef("gsl-relative-tolerance", 1E-2); 
  fGSLMaxEval  = (unsigned int) fConfig->GetIntDef ("gsl-max-eval", 500000); 
  fGSLMinEval  = (unsigned int) fConfig->GetIntDef ("gsl-min-eval",  5000); 

  //-- COH model parameter t_max for t = (q - p_pi)^2
  fTMax = fConfig->GetDoubleDef("COH-t-max", gc->GetDouble("COH-t-max"));
  //-- COH model bounds of integration for Q^2
  fQ2Min = fConfig->GetDoubleDef("COH-Q2-min", gc->GetDouble("COH-Q2-min"));
  fQ2Max = fConfig->GetDoubleDef("COH-Q2-max", gc->GetDouble("COH-Q2-max"));
  //-- nu_min scaling from Paschos, Schalla PRD 80 033005
  fPaschosSchallaXi = 
    fConfig->GetDoubleDef("COH-PaschosSchallaXi",
                          gc->GetDouble("COH-PaschosSchallaXi"));
}
//____________________________________________________________________________


CrossSections/DISXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


CrossSections/GSLXSecFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration

	#include "QEL/QELEventGenerator.h"
	#include "LlewellynSmith/LwlynSmithQELCCPXSec.h"
	
	#include "PDG/PDGLibrary.h"
	#include "PDG/PDGUtils.h"
	#include "PDG/PDGCodes.h"
	
  LOG("GSLXSecFunc", pDEBUG) << "xsec(Q2 = " << Q2 << ") = " << xsec;
#endif
	  LOG("GXSecFunc", pDEBUG) << "xsec(Q2 = " << Q2 << ") = " << xsec;
	#endif
genie::utils::gsl::d2XSec_dQ2dydt_E::d2XSec_dQ2dydt_E(
     const XSecAlgorithmI * m, const Interaction * i) :
	genie::utils::gsl::d2XSec_dWdQ2_E::d2XSec_dWdQ2_E(
	     const XSecAlgorithmI * m, const Interaction * i) :
	
  
genie::utils::gsl::d2XSec_dQ2dydt_E::~d2XSec_dQ2dydt_E()
{

}
	genie::utils::gsl::d2XSec_dWdQ2_E::~d2XSec_dWdQ2_E()
	{
	
	}
unsigned int genie::utils::gsl::d2XSec_dQ2dydt_E::NDim(void) const
{
  return 3;
}
double genie::utils::gsl::d2XSec_dQ2dydt_E::DoEval(const double * xin) const
{
// inputs:  
//   Q2 [-]
	unsigned int genie::utils::gsl::d2XSec_dWdQ2_E::NDim(void) const
	{
	  return 2;
	}
	double genie::utils::gsl::d2XSec_dWdQ2_E::DoEval(const double * xin) const
	{
	// inputs:  
	//    W  [GeV]
	//    Q2 [GeV^2]
	// outputs: 
	//   differential cross section [10^-38 cm^2/GeV^3]
	//
	  double W  = xin[0];
	  double Q2 = xin[1];
	  fInteraction->KinePtr()->SetW(W);
	  fInteraction->KinePtr()->SetQ2(Q2);
	  if(fInteraction->ProcInfo().IsDeepInelastic()) {
	    double x=0,y=0;
	    double E = fInteraction->InitState().ProbeE(kRfHitNucRest);
	    double M = fInteraction->InitState().Tgt().HitNucP4Ptr()->M();
	    kinematics::WQ2toXY(E,M,W,Q2,x,y);
	    fInteraction->KinePtr()->Setx(x);
	    fInteraction->KinePtr()->Sety(y);
	  }
	  double xsec = fModel->XSec(fInteraction, kPSWQ2fE);
	  return xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionMultiDim *
	   genie::utils::gsl::d2XSec_dWdQ2_E::Clone() const
	{
	  return 
	    new genie::utils::gsl::d2XSec_dWdQ2_E(fModel,fInteraction);
	}
	//____________________________________________________________________________
	genie::utils::gsl::d2XSec_dxdy_Ex::d2XSec_dxdy_Ex(
	     const XSecAlgorithmI * m, const Interaction * i, double x) :
	ROOT::Math::IBaseFunctionOneDim(),
	fModel(m),
	fInteraction(i),
	fx(x)
	{
	
	}
	genie::utils::gsl::d2XSec_dxdy_Ex::~d2XSec_dxdy_Ex()
	{
	
	}
	unsigned int genie::utils::gsl::d2XSec_dxdy_Ex::NDim(void) const
	{
	  return 1;
	}
	double genie::utils::gsl::d2XSec_dxdy_Ex::DoEval(double xin) const
	{
	// inputs:  
	// outputs: 
	//   differential cross section [10^-38 cm^2]
	//
	  double y = xin;
	  fInteraction->KinePtr()->Setx(fx);
	  fInteraction->KinePtr()->Sety(y);
	  double xsec = fModel->XSec(fInteraction, kPSxyfE);
	  return xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionOneDim *
	   genie::utils::gsl::d2XSec_dxdy_Ex::Clone() const
	{
	  return
	    new genie::utils::gsl::d2XSec_dxdy_Ex(fModel,fInteraction,fx);
	}
	//____________________________________________________________________________
	genie::utils::gsl::d2XSec_dxdy_Ey::d2XSec_dxdy_Ey(
	     const XSecAlgorithmI * m, const Interaction * i, double y) :
	ROOT::Math::IBaseFunctionOneDim(),
	fModel(m),
	fInteraction(i),
	fy(y)
	{
	
	}
	genie::utils::gsl::d2XSec_dxdy_Ey::~d2XSec_dxdy_Ey()
	{
	
	}
//    t [-]
// outputs: 
//   differential cross section [10^-38 cm^2]
//
  //double  E = fInteraction->InitState().ProbeE(kRfLab);
  double Q2 = xin[0];
  double  y = xin[1];
  double  t = xin[2];
  fInteraction->KinePtr()->SetQ2(Q2);
  fInteraction->KinePtr()->Sety(y);
  fInteraction->KinePtr()->Sett(t);
  kinematics::UpdateXFromQ2Y(fInteraction);
  double xsec = fModel->XSec(fInteraction, kPSQ2yfE);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionMultiDim * 
   genie::utils::gsl::d2XSec_dQ2dydt_E::Clone() const
{
  return 
    new genie::utils::gsl::d2XSec_dQ2dydt_E(fModel,fInteraction);
}
//____________________________________________________________________________
genie::utils::gsl::d2XSec_dWdQ2_E::d2XSec_dWdQ2_E(
     const XSecAlgorithmI * m, const Interaction * i) :
ROOT::Math::IBaseFunctionMultiDim(),
fModel(m),
fInteraction(i)
{

}
genie::utils::gsl::d2XSec_dWdQ2_E::~d2XSec_dWdQ2_E()
{

}
unsigned int genie::utils::gsl::d2XSec_dWdQ2_E::NDim(void) const
{
  return 2;
}
double genie::utils::gsl::d2XSec_dWdQ2_E::DoEval(const double * xin) const
{
// inputs:  
	unsigned int genie::utils::gsl::d2XSec_dxdy_Ey::NDim(void) const
	{
	  return 1;
	}
	double genie::utils::gsl::d2XSec_dxdy_Ey::DoEval(double xin) const
	{
	// inputs:  
//    W  [GeV]
//    Q2 [GeV^2]
// outputs: 
//   differential cross section [10^-38 cm^2/GeV^3]
//
  double W  = xin[0];
  double Q2 = xin[1];
  fInteraction->KinePtr()->SetW(W);
  fInteraction->KinePtr()->SetQ2(Q2);
  if(fInteraction->ProcInfo().IsDeepInelastic()) {
    double x=0,y=0;
    double E = fInteraction->InitState().ProbeE(kRfHitNucRest);
    double M = fInteraction->InitState().Tgt().HitNucP4Ptr()->M();
    kinematics::WQ2toXY(E,M,W,Q2,x,y);
    fInteraction->KinePtr()->Setx(x);
    fInteraction->KinePtr()->Sety(y);
  }
  double xsec = fModel->XSec(fInteraction, kPSWQ2fE);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionMultiDim *
   genie::utils::gsl::d2XSec_dWdQ2_E::Clone() const
{
  return 
    new genie::utils::gsl::d2XSec_dWdQ2_E(fModel,fInteraction);
}
//____________________________________________________________________________
genie::utils::gsl::d2XSec_dxdy_Ex::d2XSec_dxdy_Ex(
     const XSecAlgorithmI * m, const Interaction * i, double x) :
ROOT::Math::IBaseFunctionOneDim(),
fModel(m),
fInteraction(i),
fx(x)
{

}
genie::utils::gsl::d2XSec_dxdy_Ex::~d2XSec_dxdy_Ex()
{

}
unsigned int genie::utils::gsl::d2XSec_dxdy_Ex::NDim(void) const
{
  return 1;
}
double genie::utils::gsl::d2XSec_dxdy_Ex::DoEval(double xin) const
{
// inputs:  
	//    x [-]
	// outputs: 
	//   differential cross section [10^-38 cm^2]
	//
	  double x = xin;
	  fInteraction->KinePtr()->Setx(x);
	  fInteraction->KinePtr()->Sety(fy);
	  double xsec = fModel->XSec(fInteraction, kPSxyfE);
	  return xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionOneDim *
	   genie::utils::gsl::d2XSec_dxdy_Ey::Clone() const
	{
	  return
	    new genie::utils::gsl::d2XSec_dxdy_Ey(fModel,fInteraction,fy);
	}
	//____________________________________________________________________________
	genie::utils::gsl::d2XSec_dWdQ2_EW::d2XSec_dWdQ2_EW(
	     const XSecAlgorithmI * m, const Interaction * i, double W) :
	ROOT::Math::IBaseFunctionOneDim(),
	fModel(m),
	fInteraction(i),
	fW(W)
	{
	
	}
	genie::utils::gsl::d2XSec_dWdQ2_EW::~d2XSec_dWdQ2_EW()
	{
	
	}
	unsigned int genie::utils::gsl::d2XSec_dWdQ2_EW::NDim(void) const
	{
	  return 1;
	}
	double genie::utils::gsl::d2XSec_dWdQ2_EW::DoEval(double xin) const
	{
	// inputs:  
	//   Q2 [GeV^2]
	// outputs: 
	//   differential cross section [10^-38 cm^2/GeV^3]
	//
	  double Q2 = xin;
	  fInteraction->KinePtr()->SetW(fW);
	  fInteraction->KinePtr()->SetQ2(Q2);
	  double xsec = fModel->XSec(fInteraction, kPSWQ2fE);
	  return xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionOneDim *
	   genie::utils::gsl::d2XSec_dWdQ2_EW::Clone(void) const
	{
	  return
	    new genie::utils::gsl::d2XSec_dWdQ2_EW(fModel,fInteraction,fW);
	}
	//____________________________________________________________________________
	genie::utils::gsl::d2XSec_dWdQ2_EQ2::d2XSec_dWdQ2_EQ2(
	     const XSecAlgorithmI * m, const Interaction * i, double Q2) :
	ROOT::Math::IBaseFunctionOneDim(),
	fModel(m),
	fInteraction(i),
	fQ2(Q2)
	{
	
	}
	genie::utils::gsl::d2XSec_dWdQ2_EQ2::~d2XSec_dWdQ2_EQ2()
	{
	
	}
	unsigned int genie::utils::gsl::d2XSec_dWdQ2_EQ2::NDim(void) const
	{
	  return 1;
	}
	double genie::utils::gsl::d2XSec_dWdQ2_EQ2::DoEval(double xin) const
	{
	// inputs:  
	//   W [GeV]
	// outputs: 
	//   differential cross section [10^-38 cm^2/GeV^3]
	//
	  double W = xin;
	  fInteraction->KinePtr()->SetW(W);
	  fInteraction->KinePtr()->SetQ2(fQ2);
	  double xsec = fModel->XSec(fInteraction,kPSWQ2fE);
	  return xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionOneDim *
	   genie::utils::gsl::d2XSec_dWdQ2_EQ2::Clone() const
	{
	  return 
	   new genie::utils::gsl::d2XSec_dWdQ2_EQ2(fModel,fInteraction,fQ2);
	}
	//____________________________________________________________________________
	//
	//  This just returns the 5-D differential cross section
	//
	genie::utils::gsl::d5XSecAR::d5XSecAR(
	     const XSecAlgorithmI * m, const Interaction * i) :
	ROOT::Math::IBaseFunctionMultiDim(),
	fModel(m),
	fInteraction(i),
	flip(false)
	{
	
	}
	genie::utils::gsl::d5XSecAR::~d5XSecAR()
	{
	}
	 
	unsigned int genie::utils::gsl::d5XSecAR::NDim(void) const
	{
	  return 5;
	}
	double genie::utils::gsl::d5XSecAR::DoEval(const double * xin) const
	{
	// inputs:
	//    x [-]
	// outputs:
	//   differential cross section [10^-38 cm^2]
	//
	
	  Kinematics * kinematics = fInteraction->KinePtr();
	  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
	  double E_nu       = P4_nu->E();
	  
	  double E_l       = xin[0];
	  double theta_l   = xin[1];
	  double phi_l     = xin[2];
	  double theta_pi  = xin[3];
	  double phi_pi    = xin[4];
	  
	  double E_pi= E_nu-E_l;
	  
	  double y = E_pi/E_nu;
	   
	  double m_l = fInteraction->FSPrimLepton()->Mass();
	  if (E_l < m_l) {
// outputs: 
//   differential cross section [10^-38 cm^2]
//
  double y = xin;
  fInteraction->KinePtr()->Setx(fx);
  fInteraction->KinePtr()->Sety(y);
  double xsec = fModel->XSec(fInteraction, kPSxyfE);
	    return 0.;
	  }
	  
	  double m_pi;
	  if ( fInteraction->ProcInfo().IsWeakCC() ) {
	    m_pi = constants::kPionMass;
	  }
	  else {
	    m_pi = constants::kPi0Mass;
	  }
	
	   
	  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionOneDim *
   genie::utils::gsl::d2XSec_dxdy_Ex::Clone() const
{
  return
    new genie::utils::gsl::d2XSec_dxdy_Ex(fModel,fInteraction,fx);
}
//____________________________________________________________________________
genie::utils::gsl::d2XSec_dxdy_Ey::d2XSec_dxdy_Ey(
     const XSecAlgorithmI * m, const Interaction * i, double y) :
ROOT::Math::IBaseFunctionOneDim(),
fModel(m),
fInteraction(i),
fy(y)
{

}
genie::utils::gsl::d2XSec_dxdy_Ey::~d2XSec_dxdy_Ey()
{

}
	  TVector3 lepton_3vector = TVector3(0,0,0);
	  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
	  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
	
	  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
	  TVector3 pion_3vector = TVector3(0,0,0);
	  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
	  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);
	     
	  double Q2 = -(*P4_nu-P4_lep).Mag2();
	
	  double x = Q2/(2*E_pi*constants::kNucleonMass);
	
	  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
	
	  if ( x <  xlim.min || x > xlim.max ) {
	    return 0.;
	  }
	 
	  kinematics->Setx(x);
	  kinematics->Sety(y);
	  kinematics::UpdateWQ2FromXY(fInteraction);
	  
	  kinematics->SetFSLeptonP4(P4_lep );
	  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
	 
	  double xsec = fModel->XSec(fInteraction);
	  if (xsec>0 && flip) {
unsigned int genie::utils::gsl::d2XSec_dxdy_Ey::NDim(void) const
{
  return 1;
}
double genie::utils::gsl::d2XSec_dxdy_Ey::DoEval(double xin) const
{
// inputs:  
//    x [-]
// outputs: 
//   differential cross section [10^-38 cm^2]
//
  double x = xin;
  fInteraction->KinePtr()->Setx(x);
  fInteraction->KinePtr()->Sety(fy);
  double xsec = fModel->XSec(fInteraction, kPSxyfE);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionOneDim *
   genie::utils::gsl::d2XSec_dxdy_Ey::Clone() const
{
  return
    new genie::utils::gsl::d2XSec_dxdy_Ey(fModel,fInteraction,fy);
}
//____________________________________________________________________________
genie::utils::gsl::d2XSec_dWdQ2_EW::d2XSec_dWdQ2_EW(
     const XSecAlgorithmI * m, const Interaction * i, double W) :
ROOT::Math::IBaseFunctionOneDim(),
fModel(m),
fInteraction(i),
fW(W)
{

}
genie::utils::gsl::d2XSec_dWdQ2_EW::~d2XSec_dWdQ2_EW()
{

}
unsigned int genie::utils::gsl::d2XSec_dWdQ2_EW::NDim(void) const
{
  return 1;
}
double genie::utils::gsl::d2XSec_dWdQ2_EW::DoEval(double xin) const
{
// inputs:  
//   Q2 [GeV^2]
// outputs: 
//   differential cross section [10^-38 cm^2/GeV^3]
//
  double Q2 = xin;
  fInteraction->KinePtr()->SetW(fW);
  fInteraction->KinePtr()->SetQ2(Q2);
  double xsec = fModel->XSec(fInteraction, kPSWQ2fE);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionOneDim *
   genie::utils::gsl::d2XSec_dWdQ2_EW::Clone(void) const
{
  return
    new genie::utils::gsl::d2XSec_dWdQ2_EW(fModel,fInteraction,fW);
}
//____________________________________________________________________________
genie::utils::gsl::d2XSec_dWdQ2_EQ2::d2XSec_dWdQ2_EQ2(
     const XSecAlgorithmI * m, const Interaction * i, double Q2) :
ROOT::Math::IBaseFunctionOneDim(),
fModel(m),
fInteraction(i),
fQ2(Q2)
{

}
genie::utils::gsl::d2XSec_dWdQ2_EQ2::~d2XSec_dWdQ2_EQ2()
{

}
unsigned int genie::utils::gsl::d2XSec_dWdQ2_EQ2::NDim(void) const
{
  return 1;
}
double genie::utils::gsl::d2XSec_dWdQ2_EQ2::DoEval(double xin) const
{
// inputs:  
//   W [GeV]
// outputs: 
//   differential cross section [10^-38 cm^2/GeV^3]
//
  double W = xin;
  fInteraction->KinePtr()->SetW(W);
  fInteraction->KinePtr()->SetQ2(fQ2);
  double xsec = fModel->XSec(fInteraction,kPSWQ2fE);
  return xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionOneDim *
   genie::utils::gsl::d2XSec_dWdQ2_EQ2::Clone() const
{
  return 
   new genie::utils::gsl::d2XSec_dWdQ2_EQ2(fModel,fInteraction,fQ2);
}
//____________________________________________________________________________
//
//  This just returns the 5-D differential cross section
//
genie::utils::gsl::d5XSecAR::d5XSecAR(
     const XSecAlgorithmI * m, const Interaction * i) :
ROOT::Math::IBaseFunctionMultiDim(),
fModel(m),
fInteraction(i),
flip(false)
{

}
genie::utils::gsl::d5XSecAR::~d5XSecAR()
{
}
 
unsigned int genie::utils::gsl::d5XSecAR::NDim(void) const
{
  return 5;
}
double genie::utils::gsl::d5XSecAR::DoEval(const double * xin) const
{
// inputs:
//    x [-]
	    xsec = xsec*-1.0;
	  }
	  delete P4_nu;
	  //return xsec/(1E-38 * units::cm2);
	  return xsec;
	}
	
	ROOT::Math::IBaseFunctionMultiDim *
	   genie::utils::gsl::d5XSecAR::Clone() const
	{    
	  return
	    new genie::utils::gsl::d5XSecAR(fModel,fInteraction);
	}
	
	//____________________________________________________________________________
	//
	//  This is the original 5-D cross-section that Steve D coded
	//
	genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::d5Xsec_dEldOmegaldOmegapi(
	     const XSecAlgorithmI * m, const Interaction * i) :
	ROOT::Math::IBaseFunctionMultiDim(),
	fModel(m),
	fInteraction(i)
	{ 
	  
	}
	genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::~d5Xsec_dEldOmegaldOmegapi()
	{  
	  
	}
	unsigned int genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::NDim(void) const
	{
	  return 5;
	}
	double genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::DoEval(const double * xin) const
	{  
	// inputs:
	//    x [-]

	
  
	
  
	
  
   
	    
	 
  
   

	  
	
     

	    
	  delete P4_nu;
	
  double xsec = fModel->XSec(fInteraction);
	  double xsec = fModel->XSec(fInteraction)*TMath::Sin(theta_l)*TMath::Sin(theta_pi);
  if (xsec>0 && flip) {
	  return xsec/(1E-38 * units::cm2);
	}
	
	ROOT::Math::IBaseFunctionMultiDim *
	   genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::Clone() const
	{
	  return
	    new genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi(fModel,fInteraction);
	}
	
	//____________________________________________________________________________
	//
	// This is the same as the 5d space that Steve D coded,   
	// But we remove the integration of phi_l
	//
	
	genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::d4Xsec_dEldThetaldOmegapi(
	     const XSecAlgorithmI * m, const Interaction * i) :
	ROOT::Math::IBaseFunctionMultiDim(),
	fModel(m),
	fInteraction(i)
	{
	  
	}
	genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::~d4Xsec_dEldThetaldOmegapi()
	{
	
	}
	unsigned int genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::NDim(void) const
	{
	  return 4;
	}
	double genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::DoEval(const double * xin) const
	{
	// inputs:  
	//    El [GeV]
	//    theta l [rad]
	//    theta pi [rad]
	//    phi pi [rad]
	// outputs: 
	//   differential cross section [10^-38 cm^2]
	//
	  Kinematics * kinematics = fInteraction->KinePtr();
	  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
	  double E_nu       = P4_nu->E();
	  
	  double E_l       = xin[0];
	  double theta_l   = xin[1];
	  double phi_l     = 0.0;
	  double theta_pi  = xin[2];
	  double phi_pi    = xin[3];
	  
	  double sin_theta_l  = TMath::Sin(theta_l);
	  double sin_theta_pi = TMath::Sin(theta_pi);
	  
	  double E_pi= E_nu-E_l;
	    
	  double y = E_pi/E_nu;
	  
	  double m_l = fInteraction->FSPrimLepton()->Mass();
	  if (E_l < m_l) {
	    return 0.;
	  }
	  
	  double m_pi;
	  if ( fInteraction->ProcInfo().IsWeakCC() ) {
	    m_pi = constants::kPionMass;
	  }
	  else {
	    m_pi = constants::kPi0Mass;
	  }
	  
	  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
	  TVector3 lepton_3vector = TVector3(0,0,0);
	  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
	  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
	  
	  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
	  TVector3 pion_3vector = TVector3(0,0,0);
	  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
	  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);
	  
	  double Q2 = -(*P4_nu-P4_lep).Mag2();
	  
	  double x = Q2/(2*E_pi*constants::kNucleonMass);
	  
	  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
	  
	  if ( x <  xlim.min || x > xlim.max ) {
	    return 0.;
	  }
	  
	  kinematics->Setx(x);
	  kinematics->Sety(y);
	  kinematics::UpdateWQ2FromXY(fInteraction);
	  
	  kinematics->SetFSLeptonP4(P4_lep );
	  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
	  
	  delete P4_nu;
	  
	  double xsec = sin_theta_l * sin_theta_pi * fModel->XSec(fInteraction,kPSElOlTpifE);
	  return fFactor * xsec/(1E-38 * units::cm2);
	}
	ROOT::Math::IBaseFunctionMultiDim * 
	   genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::Clone() const
	{
	  return 
	    new genie::utils::gsl::d4Xsec_dEldThetaldOmegapi(fModel,fInteraction);
	}
	void genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::SetFactor(double factor)
	{
	  fFactor = factor;
	}
	double genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::GetFactor(void) const
	{
	  return fFactor;
	}
	//____________________________________________________________________________
	genie::utils::gsl::d3Xsec_dOmegaldThetapi::d3Xsec_dOmegaldThetapi(
	     const XSecAlgorithmI * m, const Interaction * i) :
	ROOT::Math::IBaseFunctionMultiDim(),
	fModel(m),
	fInteraction(i),
	fElep(-1)
	{
	  
	}
	genie::utils::gsl::d3Xsec_dOmegaldThetapi::~d3Xsec_dOmegaldThetapi()
	{
	
	}
	unsigned int genie::utils::gsl::d3Xsec_dOmegaldThetapi::NDim(void) const
	{
	  return 3;
	}
	double genie::utils::gsl::d3Xsec_dOmegaldThetapi::DoEval(const double * xin) const
	{
	// inputs:  
	//    theta l [rad]
	//    phi_l   [rad]
	//    phi pi  [rad]
	// outputs: 
	//   differential cross section [10^-38 cm^2]
	//
	  Kinematics * kinematics = fInteraction->KinePtr();
	  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
	  double E_nu = P4_nu->E();
	  
	  double E_l = fElep;
	  
	  double theta_l   = xin[0];
	  double phi_l     = xin[1];
	  double theta_pi  = xin[2];
	  double phi_pi    = 0;
	  
	  double sin_theta_l  = TMath::Sin(theta_l);
	  double sin_theta_pi = TMath::Sin(theta_pi);
	  
	  double E_pi= E_nu-E_l;
	    
	  double y = E_pi/E_nu;
	  
	  double m_l = fInteraction->FSPrimLepton()->Mass();
	  if (E_l < m_l) {
	    return 0.;
	  }
	  
	  double m_pi;
	  if ( fInteraction->ProcInfo().IsWeakCC() ) {
	    m_pi = constants::kPionMass;
	  }
	  else {
	    m_pi = constants::kPi0Mass;
	  }
	  
	  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
	  TVector3 lepton_3vector = TVector3(0,0,0);
	  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
	  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
	  
	  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
	  TVector3 pion_3vector = TVector3(0,0,0);
	  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
	  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);
	  
	  double Q2 = -(*P4_nu-P4_lep).Mag2();
	  
	  double x = Q2/(2*E_pi*constants::kNucleonMass);
	  
	  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
	  
	  if ( x <  xlim.min || x > xlim.max ) {
	    return 0.;
	  }
	  
	  kinematics->Setx(x);
	  kinematics->Sety(y);
	  kinematics::UpdateWQ2FromXY(fInteraction);
	  
	  kinematics->SetFSLeptonP4(P4_lep );
	  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
	  
	  delete P4_nu;
	  
	  double xsec = (sin_theta_l * sin_theta_pi) * fModel->XSec(fInteraction,kPSElOlTpifE);
	  return xsec/(1E-38 * units::cm2);
	}
	genie::utils::gsl::d3Xsec_dOmegaldThetapi * 
	   genie::utils::gsl::d3Xsec_dOmegaldThetapi::Clone() const
	{
	  d3Xsec_dOmegaldThetapi * out = new genie::utils::gsl::d3Xsec_dOmegaldThetapi(fModel,fInteraction);
	  out->SetE_lep(fElep);
	  return out;
	}
	//____________________________________________________________________________
	void genie::utils::gsl::d3Xsec_dOmegaldThetapi::SetE_lep(double E_lepton) const
	{
	  fElep = E_lepton;
	}
	//____________________________________________________________________________
	genie::utils::gsl::dXSec_dElep_AR::dXSec_dElep_AR(
	    const XSecAlgorithmI * m, const Interaction * i,
	    string gsl_nd_integrator_type, double gsl_relative_tolerance,
	    unsigned int max_n_calls) :
	ROOT::Math::IBaseFunctionOneDim(),
	fModel(m),
	fInteraction(i),
	integrator(utils::gsl::IntegrationNDimTypeFromString(gsl_nd_integrator_type),1, gsl_relative_tolerance, max_n_calls),
	fGSLIntegratorType(gsl_nd_integrator_type),
	fGSLRelTol(gsl_relative_tolerance),
	fGSLMaxCalls(max_n_calls)
	{
	  func = new utils::gsl::d3Xsec_dOmegaldThetapi(fModel, fInteraction);
	  
	  integrator.SetRelTolerance(gsl_relative_tolerance);
	  integrator.SetFunction(*func);
	  
	  kine_min[0] = kine_min[1] = kine_min[2] = controls::kASmallNum;
	  
	  kine_max[0] = kine_max[2] = constants::kPi-controls::kASmallNum;
	  kine_max[1] = 2 * constants::kPi-controls::kASmallNum;
	}
	genie::utils::gsl::dXSec_dElep_AR::~dXSec_dElep_AR()
	{
	  delete func;
	}
	double genie::utils::gsl::dXSec_dElep_AR::DoEval(double xin) const
	{
	  double Elep = xin;
	  func->SetE_lep(Elep);
	  double xsec = integrator.Integral(&kine_min[0], &kine_max[0]) ;
	  LOG("GSLXSecFunc",pINFO) << "dXSec_dElep_AR >> "<<func->NDim()<<"d integral done. (Elep = " <<Elep<< " , dxsec/dElep = "<<xsec << ")";
	  return xsec;
	}
	genie::utils::gsl::dXSec_dElep_AR *
	   genie::utils::gsl::dXSec_dElep_AR::Clone() const
	{
	  return
	    new genie::utils::gsl::dXSec_dElep_AR(fModel,fInteraction, fGSLIntegratorType, fGSLRelTol, fGSLMaxCalls);
	}
	//____________________________________________________________________________
	genie::utils::gsl::dXSec_Log_Wrapper::dXSec_Log_Wrapper(
	      const ROOT::Math::IBaseFunctionMultiDim * fn,
	      bool * ifLog, double * mins, double * maxes) :
	  fFn(fn),
	  fIfLog(ifLog),
	  fMins(mins),
	  fMaxes(maxes)
	{
	}
	genie::utils::gsl::dXSec_Log_Wrapper::~dXSec_Log_Wrapper()
	{
	} 
	 
	// ROOT::Math::IBaseFunctionMultiDim interface
	unsigned int genie::utils::gsl::dXSec_Log_Wrapper::NDim   (void) const  
	{
	  return fFn->NDim();
	}
	double genie::utils::gsl::dXSec_Log_Wrapper::DoEval (const double * xin) const
	{
	  double * toEval = new double[this->NDim()];
	  double a,b,x;
	  for (unsigned int i = 0 ; i < this->NDim() ; i++ )
	  {
	    if (fIfLog[i]) {
	      a = fMins[i];
	      b = fMaxes[i];
    xsec = xsec*-1.0;
  }
  delete P4_nu;
  //return xsec/(1E-38 * units::cm2);
  return xsec;
}

ROOT::Math::IBaseFunctionMultiDim *
   genie::utils::gsl::d5XSecAR::Clone() const
{    
  return
    new genie::utils::gsl::d5XSecAR(fModel,fInteraction);
}

//____________________________________________________________________________
//
//  This is the original 5-D cross-section that Steve D coded
//
genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::d5Xsec_dEldOmegaldOmegapi(
     const XSecAlgorithmI * m, const Interaction * i) :
ROOT::Math::IBaseFunctionMultiDim(),
fModel(m),
fInteraction(i)
{ 
  
}
genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::~d5Xsec_dEldOmegaldOmegapi()
{  
  
}
unsigned int genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::NDim(void) const
{
  return 5;
}
double genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::DoEval(const double * xin) const
{  
// inputs:
//    x [-]
	      x = xin[i];
	      toEval[i] = a + (b-a)/(constants::ke-1.) * (exp(x/(b-a)) - 1.);
	    }
	    else {
	      toEval[i] = xin[i];
	    }
	  }
	  double val = (*fFn)(toEval);
	  delete[] toEval;
	  return val; 
	}
	ROOT::Math::IBaseFunctionMultiDim * genie::utils::gsl::dXSec_Log_Wrapper::Clone (void) const
	{
	  return new dXSec_Log_Wrapper(fFn,fIfLog,fMins,fMaxes);
	}
	    
	//____________________________________________________________________________
	genie::utils::gsl::fullDifferentialXSec::fullDifferentialXSec(const XSecAlgorithmI * m, const Interaction * i) :
	ROOT::Math::IBaseFunctionMultiDim(),
	fModel(m),
	fInteraction(i)
	{
	}
	
	genie::utils::gsl::fullDifferentialXSec::~fullDifferentialXSec(){}
	
	unsigned int genie::utils::gsl::fullDifferentialXSec::NDim(void) const
	{
	  return 2;
	}
	
	ROOT::Math::IBaseFunctionMultiDim *genie::utils::gsl::fullDifferentialXSec::Clone() const
	{
	  return new genie::utils::gsl::fullDifferentialXSec(fModel, fInteraction);
	}
	
	double genie::utils::gsl::fullDifferentialXSec::DoEval(const double * xin) const
	{
	
	//  std::cout << "starting gsl fullDifferentialXSec::DoEval " << std::endl;
	  double phi = xin[0];
	  double costheta = xin[1];
	//  std::cout << "costheta = " << costheta << ", phi = " << phi << std::endl;
	  double lepMass = fInteraction->FSPrimLepton()->Mass();
	  //double Mn = tb->GetParticle(fInteraction->InitState().TgtPtr()->HitNucPdg())->Mass();// outgoing nucleon mass
	  TDatabasePDG *tb = TDatabasePDG::Instance();
	  double Mp = tb->GetParticle(fInteraction->RecoilNucleonPdg())->Mass(); // incoming nucleon mass
	  
	//  std::cout << "lepton mass = " << lepMass << ", proton mass = " << Mp << std::endl;
	
	  QELEventGenerator * tmp = new QELEventGenerator();
	  //std::cout << "Loading config" << std::endl;
	  //tmp->Configure();
	//  double xsec = QELEventGenerator::ComputeXSec(fInteraction,phi,costheta);
	//  TRY USING THE LLEWELYN SMITH CLASS!
	  //Interaction * interaction = new Interaction(*fInteraction);
	  //LwlynSmithQELCCPXSec *tmpLwlyn = new LwlynSmithQELCCPXSec();
	  //tmpLwlyn->Configure();
	  //double xsec = tmpLwlyn->FullDifferentialXSec(fInteraction);
	  //double xsec = tmp->ComputeXSec(interaction,phi,costheta);
	  //
	  double labEnu = fInteraction->InitState().ProbeE(kRfLab);
	
	  double s = fInteraction->InitState().comE(); // actually sqrt(s)
	  s *= s; // now s actually = s
	  double outLeptonEnergy = ( s - Mp*Mp + lepMass*lepMass ) / (2 * TMath::Sqrt(s));
	  double outMomentum = TMath::Sqrt(outLeptonEnergy*outLeptonEnergy - lepMass*lepMass);
	  
	  TLorentzVector lepton(outMomentum, 0, 0, outLeptonEnergy);
	  
	  lepton.SetTheta(TMath::ACos(costheta));
	  lepton.SetPhi(phi);
	//  std::cout << "Pre-boosted lepton" << std::endl;
	//  lepton.Print();
	  
	  TLorentzVector outNucleon(-1*lepton.Px(),-1*lepton.Py(),-1*lepton.Pz(), TMath::Sqrt(outMomentum*outMomentum + Mp*Mp));
	  
	  // Boost particles
	//   TVector3 beta = QELEventGenerator::COMframe2Lab(fInteraction->InitState());
	//   std::cout << "calculate boost! (in GSL function)" << std::endl;
	  TVector3 beta = tmp->COMframe2Lab(fInteraction->InitState());
	  TLorentzVector leptonCOM = TLorentzVector(lepton);
	
	  lepton.Boost(beta);
	  outNucleon.Boost(beta);
	//  std::cout << "Post-boosted lepton" << std::endl;
	//  lepton.Print();
	//  std::cout << "Post-boosted nucleon" << std::endl;
	//  outNucleon.Print();
	             
	   // Check if event is at a low angle - if so return 0 and stop wasting time
	//   double angle = fConfig->GetDoubleDef("MinAngle",  gc->GetDouble("SF-MinAngleEMscattering"));
	  double fMinAngleEM = 34;
	  if (180 * lepton.Theta() / 3.1415 < fMinAngleEM && fInteraction->ProcInfo().IsEM()){
	    std::cout << "returning zero because I'm below the minimum angle" << std::endl;
	    delete tmp;
	    return 0;
	  }
	  //Apply pauli blocking consideration:
	  if (outNucleon.P() < 0.2){
	    delete tmp;
	    return 0;
	  }
	  fInteraction->KinePtr()->SetFSLeptonP4(lepton);
	  fInteraction->KinePtr()->SetHadSystP4(outNucleon);
	//   std::cout << "calculate cross section!" << std::endl;
	   
	  labEnu = fInteraction->InitState().ProbeE(kRfLab);
	//  std::cout << "lab Enu = " << labEnu <<  std::endl;
	   
	   double xsec = fModel->XSec(fInteraction, kPSFullDiffQE);
	   xsec *= 4*TMath::Pi()*leptonCOM.P()*leptonCOM.P();
	
	   xsec *= tmp->COMJacobian(lepton, leptonCOM, outNucleon, beta);
	//   std::cout << "Jacobian = " << tmp->COMJacobian(lepton, leptonCOM, outNucleon, beta) << std::endl;
	
	//   std::cout << "cross section = " << xsec << std::endl;
	//   std::cout << "cross section for event = " << xsec << std::endl;
	   
	   delete tmp;
	   return xsec/(1E-38 * units::cm2);
	
	}
	
	
	
	
//    y [-]
// outputs:
//   differential cross section [10^-38 cm^2]
//
  Kinematics * kinematics = fInteraction->KinePtr();
  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
  double E_nu       = P4_nu->E();

  double E_l       = xin[0];
  double theta_l   = xin[1];
  double phi_l     = xin[2];
  double theta_pi  = xin[3];
  double phi_pi    = xin[4];

  double E_pi= E_nu-E_l;

  double y = E_pi/E_nu;
    
  double m_l = fInteraction->FSPrimLepton()->Mass();
  if (E_l < m_l) {
    return 0.;
  }
 
  double m_pi;
  if ( fInteraction->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  }
  else {
    m_pi = constants::kPi0Mass;
  }

  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
  TVector3 lepton_3vector = TVector3(0,0,0);
  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
  
  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
  TVector3 pion_3vector = TVector3(0,0,0);
  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);

  double Q2 = -(*P4_nu-P4_lep).Mag2();

  double x = Q2/(2*E_pi*constants::kNucleonMass);

  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
    
  if ( x <  xlim.min || x > xlim.max ) {
    return 0.;
  }
 
  kinematics->Setx(x);
  kinematics->Sety(y);
  kinematics::UpdateWQ2FromXY(fInteraction);
  
  kinematics->SetFSLeptonP4(P4_lep );
  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
 
  delete P4_nu;

  double xsec = fModel->XSec(fInteraction)*TMath::Sin(theta_l)*TMath::Sin(theta_pi);
  return xsec/(1E-38 * units::cm2);
}

ROOT::Math::IBaseFunctionMultiDim *
   genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi::Clone() const
{
  return
    new genie::utils::gsl::d5Xsec_dEldOmegaldOmegapi(fModel,fInteraction);
}

//____________________________________________________________________________
//
// This is the same as the 5d space that Steve D coded,   
// But we remove the integration of phi_l
//

genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::d4Xsec_dEldThetaldOmegapi(
     const XSecAlgorithmI * m, const Interaction * i) :
ROOT::Math::IBaseFunctionMultiDim(),
fModel(m),
fInteraction(i)
{
  
}
genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::~d4Xsec_dEldThetaldOmegapi()
{

}
unsigned int genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::NDim(void) const
{
  return 4;
}
double genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::DoEval(const double * xin) const
{
// inputs:  
//    El [GeV]
//    theta l [rad]
//    theta pi [rad]
//    phi pi [rad]
// outputs: 
//   differential cross section [10^-38 cm^2]
//
  Kinematics * kinematics = fInteraction->KinePtr();
  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
  double E_nu       = P4_nu->E();
  
  double E_l       = xin[0];
  double theta_l   = xin[1];
  double phi_l     = 0.0;
  double theta_pi  = xin[2];
  double phi_pi    = xin[3];
  
  double sin_theta_l  = TMath::Sin(theta_l);
  double sin_theta_pi = TMath::Sin(theta_pi);
  
  double E_pi= E_nu-E_l;
    
  double y = E_pi/E_nu;
  
  double m_l = fInteraction->FSPrimLepton()->Mass();
  if (E_l < m_l) {
    return 0.;
  }
  
  double m_pi;
  if ( fInteraction->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  }
  else {
    m_pi = constants::kPi0Mass;
  }
  
  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
  TVector3 lepton_3vector = TVector3(0,0,0);
  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
  
  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
  TVector3 pion_3vector = TVector3(0,0,0);
  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);
  
  double Q2 = -(*P4_nu-P4_lep).Mag2();
  
  double x = Q2/(2*E_pi*constants::kNucleonMass);
  
  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
  
  if ( x <  xlim.min || x > xlim.max ) {
    return 0.;
  }
  
  kinematics->Setx(x);
  kinematics->Sety(y);
  kinematics::UpdateWQ2FromXY(fInteraction);
  
  kinematics->SetFSLeptonP4(P4_lep );
  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
  
  delete P4_nu;
  
  double xsec = sin_theta_l * sin_theta_pi * fModel->XSec(fInteraction,kPSElOlTpifE);
  return fFactor * xsec/(1E-38 * units::cm2);
}
ROOT::Math::IBaseFunctionMultiDim * 
   genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::Clone() const
{
  return 
    new genie::utils::gsl::d4Xsec_dEldThetaldOmegapi(fModel,fInteraction);
}
void genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::SetFactor(double factor)
{
  fFactor = factor;
}
double genie::utils::gsl::d4Xsec_dEldThetaldOmegapi::GetFactor(void) const
{
  return fFactor;
}
//____________________________________________________________________________
genie::utils::gsl::d3Xsec_dOmegaldThetapi::d3Xsec_dOmegaldThetapi(
     const XSecAlgorithmI * m, const Interaction * i) :
ROOT::Math::IBaseFunctionMultiDim(),
fModel(m),
fInteraction(i),
fElep(-1)
{
  
}
genie::utils::gsl::d3Xsec_dOmegaldThetapi::~d3Xsec_dOmegaldThetapi()
{

}
unsigned int genie::utils::gsl::d3Xsec_dOmegaldThetapi::NDim(void) const
{
  return 3;
}
double genie::utils::gsl::d3Xsec_dOmegaldThetapi::DoEval(const double * xin) const
{
// inputs:  
//    theta l [rad]
//    phi_l   [rad]
//    phi pi  [rad]
// outputs: 
//   differential cross section [10^-38 cm^2]
//
  Kinematics * kinematics = fInteraction->KinePtr();
  const TLorentzVector * P4_nu = fInteraction->InitStatePtr()->GetProbeP4(kRfLab);
  double E_nu = P4_nu->E();
  
  double E_l = fElep;
  
  double theta_l   = xin[0];
  double phi_l     = xin[1];
  double theta_pi  = xin[2];
  double phi_pi    = 0;
  
  double sin_theta_l  = TMath::Sin(theta_l);
  double sin_theta_pi = TMath::Sin(theta_pi);
  
  double E_pi= E_nu-E_l;
    
  double y = E_pi/E_nu;
  
  double m_l = fInteraction->FSPrimLepton()->Mass();
  if (E_l < m_l) {
    return 0.;
  }
  
  double m_pi;
  if ( fInteraction->ProcInfo().IsWeakCC() ) {
    m_pi = constants::kPionMass;
  }
  else {
    m_pi = constants::kPi0Mass;
  }
  
  double p_l = TMath::Sqrt(E_l*E_l - m_l*m_l);
  TVector3 lepton_3vector = TVector3(0,0,0);
  lepton_3vector.SetMagThetaPhi(p_l,theta_l,phi_l);
  TLorentzVector P4_lep    = TLorentzVector(lepton_3vector , E_l );
  
  double p_pi = TMath::Sqrt(E_pi*E_pi - m_pi*m_pi);
  TVector3 pion_3vector = TVector3(0,0,0);
  pion_3vector.SetMagThetaPhi(p_pi,theta_pi,phi_pi);
  TLorentzVector P4_pion   = TLorentzVector(pion_3vector   , E_pi);
  
  double Q2 = -(*P4_nu-P4_lep).Mag2();
  
  double x = Q2/(2*E_pi*constants::kNucleonMass);
  
  Range1D_t xlim = fInteraction->PhaseSpace().XLim();
  
  if ( x <  xlim.min || x > xlim.max ) {
    return 0.;
  }
  
  kinematics->Setx(x);
  kinematics->Sety(y);
  kinematics::UpdateWQ2FromXY(fInteraction);
  
  kinematics->SetFSLeptonP4(P4_lep );
  kinematics->SetHadSystP4 (P4_pion); // use Hadronic System variable to store pion momentum
  
  delete P4_nu;
  
  double xsec = (sin_theta_l * sin_theta_pi) * fModel->XSec(fInteraction,kPSElOlTpifE);
  return xsec/(1E-38 * units::cm2);
}
genie::utils::gsl::d3Xsec_dOmegaldThetapi * 
   genie::utils::gsl::d3Xsec_dOmegaldThetapi::Clone() const
{
  d3Xsec_dOmegaldThetapi * out = new genie::utils::gsl::d3Xsec_dOmegaldThetapi(fModel,fInteraction);
  out->SetE_lep(fElep);
  return out;
}
//____________________________________________________________________________
void genie::utils::gsl::d3Xsec_dOmegaldThetapi::SetE_lep(double E_lepton) const
{
  fElep = E_lepton;
}
//____________________________________________________________________________
genie::utils::gsl::dXSec_dElep_AR::dXSec_dElep_AR(
    const XSecAlgorithmI * m, const Interaction * i,
    string gsl_nd_integrator_type, double gsl_relative_tolerance,
    unsigned int max_n_calls) :
ROOT::Math::IBaseFunctionOneDim(),
fModel(m),
fInteraction(i),
integrator(utils::gsl::IntegrationNDimTypeFromString(gsl_nd_integrator_type),1, gsl_relative_tolerance, max_n_calls),
fGSLIntegratorType(gsl_nd_integrator_type),
fGSLRelTol(gsl_relative_tolerance),
fGSLMaxCalls(max_n_calls)
{
  func = new utils::gsl::d3Xsec_dOmegaldThetapi(fModel, fInteraction);
  
  integrator.SetRelTolerance(gsl_relative_tolerance);
  integrator.SetFunction(*func);
  
  kine_min[0] = kine_min[1] = kine_min[2] = controls::kASmallNum;
  
  kine_max[0] = kine_max[2] = constants::kPi-controls::kASmallNum;
  kine_max[1] = 2 * constants::kPi-controls::kASmallNum;
}
genie::utils::gsl::dXSec_dElep_AR::~dXSec_dElep_AR()
{
  delete func;
}
double genie::utils::gsl::dXSec_dElep_AR::DoEval(double xin) const
{
  double Elep = xin;
  func->SetE_lep(Elep);
  double xsec = integrator.Integral(&kine_min[0], &kine_max[0]) ;
  LOG("GSLXSecFunc",pINFO) << "dXSec_dElep_AR >> "<<func->NDim()<<"d integral done. (Elep = " <<Elep<< " , dxsec/dElep = "<<xsec << ")";
  return xsec;
}
genie::utils::gsl::dXSec_dElep_AR *
   genie::utils::gsl::dXSec_dElep_AR::Clone() const
{
  return
    new genie::utils::gsl::dXSec_dElep_AR(fModel,fInteraction, fGSLIntegratorType, fGSLRelTol, fGSLMaxCalls);
}
//____________________________________________________________________________
genie::utils::gsl::dXSec_Log_Wrapper::dXSec_Log_Wrapper(
      const ROOT::Math::IBaseFunctionMultiDim * fn,
      bool * ifLog, double * mins, double * maxes) :
  fFn(fn),
  fIfLog(ifLog),
  fMins(mins),
  fMaxes(maxes)
{
}
genie::utils::gsl::dXSec_Log_Wrapper::~dXSec_Log_Wrapper()
{
} 
 
// ROOT::Math::IBaseFunctionMultiDim interface
unsigned int genie::utils::gsl::dXSec_Log_Wrapper::NDim   (void) const  
{
  return fFn->NDim();
}
double genie::utils::gsl::dXSec_Log_Wrapper::DoEval (const double * xin) const
{
  double * toEval = new double[this->NDim()];
  double a,b,x;
  for (unsigned int i = 0 ; i < this->NDim() ; i++ )
  {
    if (fIfLog[i]) {
      a = fMins[i];
      b = fMaxes[i];
      x = xin[i];
      toEval[i] = a + (b-a)/(constants::kNapierConst-1.) * (exp(x/(b-a)) - 1.);
    }
    else {
      toEval[i] = xin[i];
    }
  }
  double val = (*fFn)(toEval);
  delete[] toEval;
  return val; 
}
ROOT::Math::IBaseFunctionMultiDim * genie::utils::gsl::dXSec_Log_Wrapper::Clone (void) const
{
  return new dXSec_Log_Wrapper(fFn,fIfLog,fMins,fMaxes);
}
    
//____________________________________________________________________________



CrossSections/IMDXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


CrossSections/NuElectronXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


CrossSections/QELXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  if(E < fEnergyCutOff) {
     // clone the input interaction so as to tweak the
     // hit nucleon 4-momentum in the averaging loop
     Interaction in_curr(*in);

     // hit target
     const Target & tgt = in_curr.InitState().Tgt();

     // get nuclear masses (init & final state nucleus)
     int nucleon_pdgc = tgt.HitNucPdg();
     bool is_p = pdg::IsProton(nucleon_pdgc);
     int Zi = tgt.Z();
     int Ai = tgt.A();
     int Zf = (is_p) ? Zi-1 : Zi;
     int Af = Ai-1;
     PDGLibrary * pdglib = PDGLibrary::Instance();
	  std::cout << "electron/neutrino energy = " << in->InitState().ProbeE(kRfLab) << std::endl;
	  if(E < fEnergyCutOff) {
	     // clone the input interaction so as to tweak the
	     // hit nucleon 4-momentum in the averaging loop
	     Interaction in_curr(*in);
	
	     // hit target
	     const Target & tgt = in_curr.InitState().Tgt();
	
	     // get nuclear masses (init & final state nucleus)
	     int nucleon_pdgc = tgt.HitNucPdg();
	     bool is_p = pdg::IsProton(nucleon_pdgc);
	     int Zi = tgt.Z();
	     int Ai = tgt.A();
	     int Zf = (is_p) ? Zi-1 : Zi;
	     int Af = Ai-1;
	     PDGLibrary * pdglib = PDGLibrary::Instance();
     const int nnuc = 2000;
	     const int nnuc = 5;//2000;
     return xsec_avg;

  } else {
    return this->IntegrateOnce(model,in);
  }

  return 0;
}
//____________________________________________________________________________
double QELXSec::IntegrateOnce(
                  const XSecAlgorithmI * model, const Interaction * in) const
{
  const KPhaseSpace & kps = in->PhaseSpace();
  if(!kps.IsAboveThreshold()) {
     LOG("QELXSec", pDEBUG)  << "*** Below energy threshold";
     return 0;
  }
  Range1D_t rQ2 = kps.Limits(kKVQ2);
  if(rQ2.min<0 || rQ2.max<0) return 0;
  LOG("QELXSec", pDEBUG) 
          << "Q2 integration range = (" << rQ2.min << ", " << rQ2.max << ")";

  Interaction * interaction = new Interaction(*in);
  interaction->SetBit(kISkipProcessChk);
  interaction->SetBit(kISkipKinematicChk);

  ROOT::Math::IBaseFunctionOneDim * func = new 
	     std::cout << "cross section on this nucleus = " << xsec_avg << std::endl;
	     return xsec_avg;
	
	  } else {
	    return this->IntegrateOnce(model,in);
	  }
	
	  return 0;
	}
	//____________________________________________________________________________
	double QELXSec::IntegrateOnce(
	                  const XSecAlgorithmI * model, const Interaction * in) const
	{
	//  std::cout << "calling QELXSec::IntegrateOnce()" << std::endl;
	  const KPhaseSpace & kps = in->PhaseSpace();
	  if(!kps.IsAboveThreshold()) {
	//     std::cout << "failed energy threshold cut!" << std::endl;
	     LOG("QELXSec", pDEBUG)  << "*** Below energy threshold";
	     return 0;
	  }
	// temporarily commented
	//  Range1D_t rQ2 = kps.Limits(kKVQ2);
	//  if(rQ2.min<0 || rQ2.max<0) return 0;
	//  LOG("QELXSec", pDEBUG) 
	//          << "Q2 integration range = (" << rQ2.min << ", " << rQ2.max << ")";
	
	  Interaction * interaction = new Interaction(*in);
	  interaction->SetBit(kISkipProcessChk);
	  interaction->SetBit(kISkipKinematicChk);
	
	//  ROOT::Math::IBaseFunctionOneDim * func = new 
      utils::gsl::dXSec_dQ2_E(model, interaction);
  ROOT::Math::IntegrationOneDim::Type ig_type = 
	//      utils::gsl::dXSec_dQ2_E(model, interaction);
	//  ROOT::Math::IntegrationOneDim::Type ig_type = 
      utils::gsl::Integration1DimTypeFromString(fGSLIntgType);
  
  double abstol = 1; //We mostly care about relative tolerance
  ROOT::Math::Integrator ig(*func,ig_type,abstol,fGSLRelTol,fGSLMaxEval);
  double xsec = ig.Integral(rQ2.min, rQ2.max) * (1E-38 * units::cm2);
     
  //LOG("QELXSec", pDEBUG) << "XSec[QEL] (E = " << E << ") = " << xsec;

  delete func;
  delete interaction;

  return xsec;
}
//____________________________________________________________________________
	//      utils::gsl::Integration1DimTypeFromString(fGSLIntgType);
	
	// try again for new model
	  ROOT::Math::IBaseFunctionMultiDim * func = new 
	      utils::gsl::fullDifferentialXSec(model, interaction);
	  ROOT::Math::IntegrationMultiDim::Type ig_type = 
	      utils::gsl::IntegrationNDimTypeFromString(fGSLIntgType);
	
	
	  double abstol = 1; //We mostly care about relative tolerance
	  //ROOT::Math::Integrator ig(*func,ig_type,abstol,fGSLRelTol,fGSLMaxEval);
	  ROOT::Math::IntegratorMultiDim ig(*func,ig_type,abstol,fGSLRelTol,fGSLMaxEval);
	  double angle_min[2] = {0, -1};
	  double angle_max[2] = {2 * TMath::Pi(), 1};
	//  double xsec = ig.Integral(rQ2.min, rQ2.max) * (1E-38 * units::cm2);
	  double xsec = ig.Integral(angle_min, angle_max) * (1E-38 * units::cm2);
	     
	  //LOG("QELXSec", pDEBUG) << "XSec[QEL] (E = " << E << ") = " << xsec;
	
	  delete func;
	  delete interaction;
	
	  return xsec;
	}
	//____________________________________________________________________________


CrossSections/RESXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Decay/BaryonResonanceDecayer.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Decay/DecayModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Decay/PythiaDecayer.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Diffractive/DFRHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Diffractive/DFRInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Diffractive/DFRKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Diffractive/DFRPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


DIS/DISHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


DIS/DISInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  int      ppdg   = init_state.ProbePdg();
  int ppdg = init_state.ProbePdg();
  if( !pdg::IsLepton(ppdg) ) {
     LOG("IntLst", pWARN)
       << "Can not handle probe! Returning NULL InteractionList "
       << "for init-state: " << init_state.AsString();
     return 0;
  }

  bool hasP = (init_state.Tgt().Z() > 0);
  bool hasN = (init_state.Tgt().N() > 0);

  InteractionList * intlist = new InteractionList;

  int nuclpdg[2] = { kPdgProton, kPdgNeutron };

  for(int inucl=0; inucl<2; inucl++) {

    int struck_nucleon = nuclpdg[inucl];

    if( (struck_nucleon == kPdgProton  && hasP) ||
        (struck_nucleon == kPdgNeutron && hasN) ) {

      ProcessInfo proc_info(kScDeepInelastic, inttype);

      Interaction * interaction = new Interaction(init_state, proc_info);
	  Target * target = init_state.TgtPtr();
	
	  if( !pdg::IsLepton(ppdg) ) {
	     LOG("IntLst", pWARN)
	       << "Can not handle probe! Returning NULL InteractionList "
	       << "for init-state: " << init_state.AsString();
	     return 0;
	  }
	
	  bool hasP = (target->Z() > 0);
	  bool hasN = (target->N() > 0);
	
	  InteractionList * intlist = new InteractionList;
	
	  int nuclpdg[2] = { kPdgProton, kPdgNeutron };
	
	  for(int inucl=0; inucl<2; inucl++) {
	
	    int struck_nucleon = nuclpdg[inucl];
	
	    if( (struck_nucleon == kPdgProton  && hasP) ||
	        (struck_nucleon == kPdgNeutron && hasN) ) {
	
	      ProcessInfo proc_info(kScDeepInelastic, inttype);
	
	      Interaction * interaction = new Interaction(init_state, proc_info);


DIS/DISKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


DIS/DISPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Elastic/AhrensNCELPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  double Ga1 = -0.5 * fFa0 * (1+fEta)/ qma2;  
	
	  //-- compute form factors
  double Ga1 = -0.5 * fFa0 * (1 + (nucsign) * fEta) / qma2;  

  //-- compute form factors


Elastic/RosenbluthPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	  if (kps == kPSFullDiffQE){
  if(! this -> ValidProcess    (interaction) ) return 0.;
  if(! this -> ValidKinematics (interaction) ) return 0.;

  // Get interaction information
  const InitialState & init_state = interaction -> InitState();
  const Kinematics &   kinematics = interaction -> Kine();
  const Target &       target     = init_state.Tgt();

  int nucpdgc = target.HitNucPdg();
  double E  = init_state.ProbeE(kRfHitNucRest);
  double Q2 = kinematics.Q2();
  double M  = target.HitNucMass();

  double E2 = E*E;
  double E3 = E*E2;
  double M2 = M*M;

  // Calculate scattering angle
  //
  // Q^2 = 4 * E^2 * sin^2 (theta/2) / ( 1 + 2 * (E/M) * sin^2(theta/2) ) =>
	  return this->FullDifferentialXSec(interaction);}
	
	  if(! this -> ValidProcess    (interaction) ) return 0.;
	  if(! this -> ValidKinematics (interaction) ) return 0.;
	
	  // Get interaction information
	  const InitialState & init_state = interaction -> InitState();
	  const Kinematics &   kinematics = interaction -> Kine();
	  const Target &       target     = init_state.Tgt();
	
	  int nucpdgc = target.HitNucPdg();
	  double E  = init_state.ProbeE(kRfHitNucRest);
	  double Q2 = kinematics.Q2();
	  double M  = target.HitNucMass();
	
	  double E2 = E*E;
	  double E3 = E*E2;
	  double M2 = M*M;
	
	  // Calculate scattering angle
	  //
	  // Q^2 = 4 * E^2 * sin^2 (theta/2) / ( 1 + 2 * (E/M) * sin^2(theta/2) ) =>
	//
	double RosenbluthPXSec::FullDifferentialXSec(const Interaction *  interaction)const{
	
	  // calculate cross section differential in lab variables
	  const Kinematics &   kinematics = interaction -> Kine();
	  const InitialState & init_state = interaction -> InitState();
	  const Target &       target     = init_state.Tgt();
	
	  const TLorentzVector outElectronMom = kinematics.FSLeptonP4();
	  const TLorentzVector outNucleonMom = kinematics.HadSystP4();
	
	  TLorentzVector * inElectronMom = init_state.GetProbeP4();
	  TLorentzVector * inNucleonMom = init_state.TgtPtr()->HitNucP4Ptr();
	  
	  // Now we calculate q and qTilde
	  TLorentzVector qP4(0,0,0,0);
	  TLorentzVector qTildeP4(0,0,0,0);
	  qP4 = *inElectronMom - outElectronMom;
	//  qTildeP4 -= outElectronMom;
	  qTildeP4 = outNucleonMom - *inNucleonMom;
	
	
	  double Q2tilde = -1 * qTildeP4.Mag2();
	  interaction->KinePtr()->SetQ2(Q2tilde);
	  
	  // Calculate the elastic nucleon form factors
	  fELFF.Calculate(interaction);
	  int nucpdgc = target.HitNucPdg();
	  double Gm  = pdg::IsProton(nucpdgc) ? fELFF.Gmp() : fELFF.Gmn();
	  double Ge  = pdg::IsProton(nucpdgc) ? fELFF.Gep() : fELFF.Gen();
	  double Ge2 = Ge*Ge;
	  double Gm2 = Gm*Gm;
	
	  double tau = Q2tilde / (4. * inNucleonMom->Mag2());
	  
	  double h1 = tau*Gm2;
	  double h2 = (1. / tau) * (Ge2 + tau * Gm2);
	
	  double l1 = 2 * (inElectronMom->Dot(outElectronMom));
	  double l2 = (2 / inNucleonMom->Mag2() ) * (2 * inElectronMom->Dot(*inNucleonMom) * outElectronMom.Dot(*inNucleonMom) - inNucleonMom->Mag2()*inElectronMom->Dot(outElectronMom) );
	
	  double LH = l1*h1 + l2 * h2;
	  
	  double xsec = (kAem2 / (Q2tilde*Q2tilde)) * (inNucleonMom->M()) * LH / (outElectronMom.E() * inElectronMom->E() * inNucleonMom->E() ) ;
	
	  // std::cout << "Rosenbluth xsec = " << xsec << std::endl;
	  delete inElectronMom;
	  return xsec;
	
	  ///// CHECK THIS STUFF - CONSTANTS, JACOBIANS, etc
	
	}
	


ElFF/BBA03ELFormFactorsModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/BBA05ELFormFactorsModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/BBA07ELFormFactorsModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/DipoleELFormFactorsModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/ELFormFactors.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/ELFormFactorsModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ElFF/TransverseEnhancementFFModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventGeneratorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventGeneratorListAssembler.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventGeneratorList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventRecord.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EventRecordVisitorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/EVGThreadException.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/GVldContext.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/InteractionGeneratorMap.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/InteractionListAssembler.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/InteractionList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/InteractionListGeneratorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/InteractionSelectorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/PhysInteractionSelector.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/RunningThreadInfo.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/ToyInteractionSelector.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGCore/XSecAlgorithmMap.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGDrivers/GeomAnalyzerI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGDrivers/GEVGDriver.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGDrivers/GEVGPool.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGDrivers/GFluxI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGDrivers/GMCJDriver.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  {
    fGlobPmax = 0;
	  fGlobPmax = 0;
    map<int,TH1D*>::iterator pmax_iter = fPmax.begin();
    for( ; pmax_iter != fPmax.end(); ++pmax_iter) {
	  map<int,TH1D*>::iterator pmax_iter = fPmax.begin();
	  for( ; pmax_iter != fPmax.end(); ++pmax_iter) {
      TH1D * pmax = pmax_iter->second;
      if(pmax) {
        delete pmax; pmax = 0;    
      }
    }
    fPmax.clear();
  }

  // for maximum interaction probability vs E /for given geometry/ I will
  // be using 300 bins up to the maximum energy for the input flux
  // double de   = fEmax/300.;//djk june 5, 2013
  double de   = fEmax/300.;//djk june 5, 2013
  double emin = 0.0;
  double emax = fEmax + de;
  int n = 1 + (int) ((emax-emin)/de);

  PDGCodeList::const_iterator nuiter;
  PDGCodeList::const_iterator tgtiter;

  // loop over all neutrino types generated by the flux driver
  for(nuiter = fNuList.begin(); nuiter != fNuList.end(); ++nuiter) {
    int neutrino_pdgc = *nuiter;
    TH1D * pmax_hst = new TH1D("pmax_hst",
             "max interaction probability vs E | geom",n,emin,emax);
    pmax_hst->SetDirectory(0);

    // loop over energy bins
    for(int ie = 1; ie <= pmax_hst->GetNbinsX(); ie++) {
      double EvLow  = pmax_hst->GetBinCenter(ie) - 0.5*pmax_hst->GetBinWidth(ie); 
      double EvHigh = pmax_hst->GetBinCenter(ie) + 0.5*pmax_hst->GetBinWidth(ie); 
      //double Ev = pmax_hst->GetBinCenter(ie);

       // loop over targets in input geometry, form initial state and compute
	    TH1D * pmax = pmax_iter->second;
	    if(pmax) {
	      delete pmax; pmax = 0;    
	    }
	  }
	  fPmax.clear();
	
	  // for maximum interaction probability vs E /for given geometry/ I will
	  // be using 300 bins up to the maximum energy for the input flux
	  // double de   = fEmax/300.;//djk june 5, 2013
	  double de   = fEmax/300.;//djk june 5, 2013
	  double emin = 0.0;
	  double emax = fEmax + de;
	  int n = 1 + (int) ((emax-emin)/de);
	
	  PDGCodeList::const_iterator nuiter;
	  PDGCodeList::const_iterator tgtiter;
	
	  // loop over all neutrino types generated by the flux driver
	  for(nuiter = fNuList.begin(); nuiter != fNuList.end(); ++nuiter) {
	    int neutrino_pdgc = *nuiter;
	    TH1D * pmax_hst = new TH1D("pmax_hst",
	             "max interaction probability vs E | geom",n,emin,emax);
	    pmax_hst->SetDirectory(0);
	
	    // loop over energy bins
	    for(int ie = 1; ie <= pmax_hst->GetNbinsX(); ie++) {
	      double EvLow  = pmax_hst->GetBinCenter(ie) - 0.5*pmax_hst->GetBinWidth(ie); 
	      double EvHigh = pmax_hst->GetBinCenter(ie) + 0.5*pmax_hst->GetBinWidth(ie); 
	      //double Ev = pmax_hst->GetBinCenter(ie);
	
	       // loop over targets in input geometry, form initial state and compute
  {
    for(nuiter = fNuList.begin(); nuiter != fNuList.end(); ++nuiter) {
	  for(nuiter = fNuList.begin(); nuiter != fNuList.end(); ++nuiter) {
      int neutrino_pdgc = *nuiter;
	    int neutrino_pdgc = *nuiter;
      map<int,TH1D*>::const_iterator pmax_iter = fPmax.find(neutrino_pdgc);
      assert(pmax_iter != fPmax.end());
	    map<int,TH1D*>::const_iterator pmax_iter = fPmax.find(neutrino_pdgc);
	    assert(pmax_iter != fPmax.end());
      TH1D * pmax_hst = pmax_iter->second;
      assert(pmax_hst);
//    double pmax = pmax_hst->GetBinContent(pmax_hst->FindBin(fEmax));
      double pmax = pmax_hst->GetMaximum();
      assert(pmax>0);        
//    fGlobPmax += pmax;
      fGlobPmax = TMath::Max(pmax, fGlobPmax); // ?;
    }
    LOG("GMCJDriver", pNOTICE) << "*** Probability scale = " << fGlobPmax;
  }
}
//___________________________________________________________________________
	    TH1D * pmax_hst = pmax_iter->second;
	    assert(pmax_hst);
	//  double pmax = pmax_hst->GetBinContent(pmax_hst->FindBin(fEmax));
	    double pmax = pmax_hst->GetMaximum();
	    assert(pmax>0);        
	//  fGlobPmax += pmax;
	    fGlobPmax = TMath::Max(pmax, fGlobPmax); // ?;
	  }
	
	  LOG("GMCJDriver", pNOTICE) << "*** Probability scale = " << fGlobPmax;
	}
	//___________________________________________________________________________


EVGDrivers/GMCJMonitor.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  fWatch.Reset(); 
  fWatch.Start();
  fCpuTime = 0;

  // get rehreah rate of set default / protect from invalid refresh rates
  if( gSystem->Getenv("GMCJMONREFRESH") ) {
   fRefreshRate = atoi( gSystem->Getenv("GMCJMONREFRESH") );
  } else fRefreshRate = 100;

  fRefreshRate = TMath::Max(1,fRefreshRate);
}
//____________________________________________________________________________

	  TStopwatch fWatch;
	  fWatch.Reset(); 
	  fWatch.Start();
	  fCpuTime = 0;
	
	  // get rehreah rate of set default / protect from invalid refresh rates
	  if( gSystem->Getenv("GMCJMONREFRESH") ) {
	   fRefreshRate = atoi( gSystem->Getenv("GMCJMONREFRESH") );
	  } else fRefreshRate = 100;
	
	  fRefreshRate = TMath::Max(1,fRefreshRate);
	}
	//____________________________________________________________________________
	


EVGDrivers/PathLengthList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/FermiMover.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/HadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/HadronTransporter.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/InitialStateAppender.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/KineGeneratorWithCache.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/NucBindEnergyAggregator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/NucDeExcitationSim.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/PauliBlocker.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/PrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/UnstableParticleDecayer.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


EVGModules/VertexGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GAstroFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  // Compute detector volume solid angle acceptance across the
  // Coordinate System Rotation:
	  // face of the Earth to use as pdf for generating neutrino positions.
	  //
	
  // GEF translated to detector centre -> THZ
  //
  // ...
	  if(fSolidAngleAcceptance) delete fSolidAngleAcceptance;
	
	  fSolidAngleAcceptance = new TH2D("fSolidAngleAcceptance","",
	      kAstroNPhiBins,0.,2.*kPi,kAstroNCosThetaBins,-1,1);
	  fSolidAngleAcceptance->SetDirectory(0);
	
	  for(int i = 1; i <= kAstroNPhiBins; i++) {
	    for(int j = 1; j <= kAstroNCosThetaBins; j++) {
	
	       double phi      = fSolidAngleAcceptance->GetXaxis()->GetBinCenter(i);
	       double costheta = fSolidAngleAcceptance->GetYaxis()->GetBinCenter(j);
	       double sintheta = TMath::Sqrt(1-costheta*costheta);
	       double cosphi   = TMath::Cos(phi);
	       double sinphi   = TMath::Sin(phi);
	
	       double REarth   = constants::kREarth/units::km;
	
	       double x = REarth*sintheta*cosphi;
	       double y = REarth*sintheta*sinphi;
	       double z = REarth*costheta;
	
	       double r2 = TMath::Power(x-fDetCenter.X(), 2.) +
	                   TMath::Power(y-fDetCenter.Y(), 2.) +
	                   TMath::Power(z-fDetCenter.Z(), 2.);
	
	       double dArea  = kPi*TMath::Power(fDetSize, 2.);
	       double dOmega = dArea / r2;
	
	       fSolidAngleAcceptance->Fill(phi,costheta,dOmega);
	    }//costheta
	  }//phi
	  // normalize
	  double max = fSolidAngleAcceptance->GetMaximum();
	  fSolidAngleAcceptance->Scale(1./max);
	
	  //
	  // Coordinate System Rotation:
	  // GEF translated to detector centre -> THZ
	  //
	  // ...


FluxDrivers/GAtmoFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GBartolAtmoFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GCylindTH1Flux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GFlavorMap.cxx
	void GFlavorMap::Config(std::string config)
	{
	  LOG_BEGIN("FluxBlender", pINFO) 
	    << "GFlavorMap::Config \"" << config << "\"" << LOG_END;
	  
	  if ( config.find("swap") == 0 || 
	       config.find("map")  == 0 || 
	       config.find("genie::flux::GFlavorMap") ) {
	    ParseMapString(config);
	  } else if ( config.find("fixedfrac") == 0 ) {
	    ParseFixedfracString(config);
	  } else {
	    LOG_BEGIN("FluxBlender", pWARN) 
	      << "GFlavorMap::Config don't know how to parse \"" 
	      << config << "\"" << LOG_END;
	    LOG_BEGIN("FluxBlender", pWARN) 
void GFlavorMap::Config(std::string configIn)
{
  std::string config = genie::utils::str::TrimSpaces(configIn);
  LOG_BEGIN("FluxBlender", pINFO) 
    << "GFlavorMap::Config \"" << config << "\"" << LOG_END;
  
  if ( config.find("swap") == 0 || 
       config.find("map")  == 0 || 
       config.find("genie::flux::GFlavorMap") == 0 ) {
    ParseMapString(config);
  } else if ( config.find("fixedfrac") == 0 ) {
    ParseFixedfracString(config);
  } else {
    LOG_BEGIN("FluxBlender", pWARN) 
      << "GFlavorMap::Config don't know how to parse \"" 
      << config << "\"" << LOG_END;
    LOG_BEGIN("FluxBlender", pWARN) 


FluxDrivers/GFlavorMixerFactory.cxx


FluxDrivers/GFlavorMixerI.cxx


FluxDrivers/GFlukaAtmo3DFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GFluxBlender.cxx


FluxDrivers/GFluxDriverFactory.cxx


FluxDrivers/GFluxExposureI.cxx


FluxDrivers/GFluxFileConfigI.cxx
    : fPdgCList(new PDGCodeList)
    , fPdgCListRej(new PDGCodeList)
    , fXMLbasename("")
    , fNCycles(0)
    , fICycle(0)
	    : fXMLbasename(""), fNCycles(0), fZ0(-3.4e38)
	  { ; }
	
    , fZ0(-3.4e38)
  { ; }

  void GFluxFileConfigI::GetBranchInfo(std::vector<std::string>& /* branchNames */,
                                       std::vector<std::string>& /* branchClassNames */,
                                       std::vector<void**>&      /* branchObjPointers */)
  {
    // allow flux driver to report back current status and/or ntuple entry 
    // info for possible recording in the output file by supplying
    // the class name, and a pointer to the object that will be filled
    // as well as a suggested name for the branch.

    // default is not to supply anything
  }

  //___________________________________________________________________________
  TTree* GFluxFileConfigI::GetMetaDataTree()
  {
    return 0;
  }

  //___________________________________________________________________________
	  void GFluxFileConfigI::GetBranchInfo(std::vector<std::string>& branchNames,
	                                       std::vector<std::string>& branchClassNames,
	                                       std::vector<void**>&      branchObjPointers)
	  {
	    // allow flux driver to report back current status and/or ntuple entry 
	    // info for possible recording in the output file by supplying
	    // the class name, and a pointer to the object that will be filled
	    // as well as a suggested name for the branch.
	
	    // default is not to supply anything
	  }
	  TTree* GFluxFileConfigI::GetMetaDataTree()
	  {
	    return 0;
	  }
	
	  //___________________________________________________________________________
    fPdgCList->Copy(particles);
    
	    if (!fPdgCList) {
	      fPdgCList = new PDGCodeList;
	    }
	    fPdgCList->Copy(particles);
	    


FluxDrivers/GJPARCNuFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GMonoEnergeticFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


FluxDrivers/GNuMIFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration

  fCurEntry        = new GNuMIFluxPassThroughInfo;

  fNuFluxTree      =  0;
  fG3NuMI          =  0;
  fG4NuMI          =  0;
  fFlugg           =  0;
  fNuFluxTreeName  = "";
  fNuFluxGen       = "";
  fNFiles          =  0;

  fNEntries        =  0;
  fIEntry          = -1;
  fICycle          =  0;
  fNUse            =  1;
  fIUse            =  999999;

  fNuTot           = 0;
  fFilePOTs        = 0;

  fMaxWeight       = -1;
  fMaxWgtFudge     =  1.05;
  fMaxWgtEntries   = 2500000;
  fMaxEFudge       =  0;

	  fPdgCList        = new PDGCodeList;
	  fPdgCListRej     = new PDGCodeList;
	  fCurEntry        = new GNuMIFluxPassThroughInfo;
	
	  fNuFluxTree      =  0;
	  fG3NuMI          =  0;
	  fG4NuMI          =  0;
	  fFlugg           =  0;
	  fNuFluxTreeName  = "";
	  fNuFluxGen       = "";
	  fNFiles          =  0;
	
	  fNEntries        =  0;
	  fIEntry          = -1;
	  fICycle          =  0;
	  fNUse            =  1;
	  fIUse            =  999999;
	
	  fNuTot           = 0;
	  fFilePOTs        = 0;
	
	  fMaxWeight       = -1;
	  fMaxWgtFudge     =  1.05;
	  fMaxWgtEntries   = 2500000;
	  fMaxEFudge       =  0;
	


FluxDrivers/GSimpleNtpFlux.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  fNEntriesUsed = 0;

  fCurEntry        = new GSimpleNtpEntry;
  fCurNuMI         = new GSimpleNtpNuMI;
  fCurAux          = new GSimpleNtpAux;
  fCurMeta         = new GSimpleNtpMeta;

  fCurEntryCopy    = 0;
  fCurNuMICopy     = 0;
  fCurAuxCopy      = 0;

  fNuFluxTree      = new TChain("flux");
  fNuMetaTree      = new TChain("meta");

  //fNuFluxFilePatterns = "";
  fNuFluxBranchRequest = "entry,numi,aux";  // all branches

  fNFiles          =  0;

  fNEntries        =  0;
  fIEntry          = -1;
  fIFileNumber     =  0;
  fICycle          =  0;
  fNUse            =  1;
  fIUse            =  999999;

  fFilePOTs        = 0;

  fMaxWeight       = -1;

	  fPdgCList        = new PDGCodeList;
	  fPdgCListRej     = new PDGCodeList;
	  fCurEntry        = new GSimpleNtpEntry;
	  fCurNuMI         = new GSimpleNtpNuMI;
	  fCurAux          = new GSimpleNtpAux;
	  fCurMeta         = new GSimpleNtpMeta;
	
	  fCurEntryCopy    = 0;
	  fCurNuMICopy     = 0;
	  fCurAuxCopy      = 0;
	
	  fNuFluxTree      = new TChain("flux");
	  fNuMetaTree      = new TChain("meta");
	
	  //fNuFluxFilePatterns = "";
	  fNuFluxBranchRequest = "entry,numi,aux";  // all branches
	
	  fNFiles          =  0;
	
	  fNEntries        =  0;
	  fIEntry          = -1;
	  fICycle          =  0;
	  fNUse            =  1;
	  fIUse            =  999999;
	
	  fFilePOTs        = 0;
	
	  fMaxWeight       = -1;
	
	  fEffPOTsPerNu    =  0;
	  fAccumPOTs       =  0;
	
	  fGenWeighted     = false;
	  fAllFilesMeta    = true;
	  fAlreadyUnwgt    = false;
	
  fNEntriesUsed    =  0;
  fEffPOTsPerNu    =  0;
  fAccumPOTs       =  0;

  fGenWeighted     = false;
  fAllFilesMeta    = true;
  fAlreadyUnwgt    = false;



Fragmentation/CharmHadronization.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	         int ip  = bremn->GetParent();
	         int ifc = bremn->GetFirstChild();
	         int ilc = bremn->GetLastChild();
	         bremn -> SetParent     ( (ip  == 0 ?  1 : ip +1) );
	         bremn -> SetFirstChild ( (ifc == 0 ? -1 : ifc+1) );
	         bremn -> SetLastChild  ( (ilc == 0 ? -1 : ilc+1) );
	      }
         int jp  = bremn->GetParent();
         int ifc = bremn->GetFirstChild();
         int ilc = bremn->GetLastChild();
         bremn -> SetParent     ( (jp  == 0 ?  1 : jp +1) );
         bremn -> SetFirstChild ( (ifc == 0 ? -1 : ifc+1) );
         bremn -> SetLastChild  ( (ilc == 0 ? -1 : ilc+1) );
      }


Fragmentation/CollinsSpillerFragm.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/FragmentationFunctionI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/FragmentationFunctions.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/HadronizationModelBase.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/HadronizationModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/KNOHadronization.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  for(int i=0; i<200; i++) {
	     double w = fPhaseSpaceGenerator.Generate();   
  for(int idec=0; idec<200; idec++) {
     double w = fPhaseSpaceGenerator.Generate();   


Fragmentation/KNOPythiaHadronization.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/PetersonFragm.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Fragmentation/PythiaHadronization.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/FidShape.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
    dist = rc.Dot(fCylAxis);
	    Double_t dist = rc.Dot(fCylAxis);


Geo/GeomVolSelectorBasic.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/GeomVolSelectorFiducial.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/GeomVolSelectorI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/GeomVolSelectorRockBox.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/GeoUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/PathSegmentList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/PointGeomAnalyzer.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Geo/ROOTGeomAnalyzer.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
    const PathLengthList & pllst = this->ComputePathLengths(nux4, nup4);

	    const PathLengthList & pl = this->ComputePathLengths(nux4, nup4);
	
	    for (pl_iter = pl.begin(); pl_iter != pl.end(); ++pl_iter) {
    for (pl_iter = pllst.begin(); pl_iter != pllst.end(); ++pl_iter) {


GHEP/GHepParticle.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	using std::cout;
	
	const double kPCutOff    = 1e-15;
	const double kOffShellDm = 0.002; // 2 MeV
	
	ClassImp(GHepParticle)
	
	//____________________________________________________________________________
	namespace genie {
	 ostream & operator<< (ostream& stream, const GHepParticle & particle)
	 {
	   particle.Print(stream);
	   return stream;
	 }
	}
	//___________________________________________________________________________
	GHepParticle::GHepParticle() :
	TObject()
	{
	  this->Init();
	}
	//___________________________________________________________________________
	// TParticle-like constructor
	GHepParticle::GHepParticle(int pdg, GHepStatus_t status,
	            int mother1, int mother2, int daughter1, int daughter2,
	                        const TLorentzVector & p, const TLorentzVector & v) :
	TObject(),
	fStatus(status),
	fFirstMother(mother1),
	fLastMother(mother2),
	fFirstDaughter(daughter1),
	fLastDaughter(daughter2)
	{
	  this->SetPdgCode(pdg);
	
	  fP4 = new TLorentzVector(p);
	  fX4 = new TLorentzVector(v);
	
	  fRescatterCode  = -1;
	  fPolzTheta      = -999; 
	  fPolzPhi        = -999;    
	  fIsBound        = false;
	  fRemovalEnergy  = 0.;
	}
	//___________________________________________________________________________
	// TParticle-like constructor
	GHepParticle::GHepParticle(int pdg, GHepStatus_t status,
	         int mother1, int mother2, int daughter1, int daughter2,
	                           double px, double py, double pz, double E,
	                                    double x, double y, double z, double t) :
	TObject(),
	fStatus(status),
	fFirstMother(mother1),
	fLastMother(mother2),
	fFirstDaughter(daughter1),
	fLastDaughter(daughter2)
	{
	  this->SetPdgCode(pdg);
	
	  fP4 = new TLorentzVector(px,py,pz,E);
	  fX4 = new TLorentzVector(x,y,z,t);
	
	  fRescatterCode  = -1;
	  fPolzTheta      = -999; 
	  fPolzPhi        = -999;   
	  fIsBound        = false;
	  fRemovalEnergy  = 0.; 
	}
	//___________________________________________________________________________
	// Copy constructor
	GHepParticle::GHepParticle(const GHepParticle & particle) :
	TObject()
	{
	  this->Init();
	  this->Copy(particle);
	}
	//___________________________________________________________________________
	GHepParticle::GHepParticle(TRootIOCtor*) :
	TObject(),
	fPdgCode(0),
	fStatus(kIStUndefined),
	fRescatterCode(-1),
	fFirstMother(-1),
	fLastMother(-1),
	fFirstDaughter(-1),
	fLastDaughter(-1),
	fP4(0), 
	fX4(0),
	fPolzTheta(-999.),
	fPolzPhi(-999.),
	fRemovalEnergy(0),
	fIsBound(false)
	{
	
	}
	//___________________________________________________________________________
	GHepParticle::~GHepParticle()
	{
	  this->CleanUp();
	}
	//___________________________________________________________________________
	string GHepParticle::Name(void) const
	{
	  this->AssertIsKnownParticle();
	
	  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
	  return p->GetName();
	}
	//___________________________________________________________________________
	double GHepParticle::Mass(void) const
	{
	  this->AssertIsKnownParticle();
	
	  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
	  return p->Mass();
	}
	//___________________________________________________________________________
	double GHepParticle::Charge(void) const
	{
	  this->AssertIsKnownParticle();
	
	  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
	  return p->Charge();
	}
	//___________________________________________________________________________
	double GHepParticle::KinE(bool mass_from_pdg) const
	{
	  if(!fP4) {
	    LOG("GHepParticle", pWARN) << "4-momentum not yet set!";
	    return 0;
	  }
	
	  double E = fP4->Energy();
	  double M = ( (mass_from_pdg) ? this->Mass() : fP4->M() );
	  double K = E-M;
	
	  K = TMath::Max(K,0.);
	  return K;
	}
	//___________________________________________________________________________
	int GHepParticle::Z(void) const
	{
	// Decoding Z from the PDG code
	
	  if(!pdg::IsIon(fPdgCode)) 
	    return -1;
	  else
	    return pdg::IonPdgCodeToZ(fPdgCode);
	}
	//___________________________________________________________________________
	int GHepParticle::A(void) const
	{
	// Decoding A from the PDG code
	
	  if(!pdg::IsIon(fPdgCode)) 
	    return -1;
	  else
	    return pdg::IonPdgCodeToA(fPdgCode);
	}
	//___________________________________________________________________________
	TLorentzVector * GHepParticle::GetP4(void) const 
	{ 
	// see GHepParticle::P4() for a method that does not create a new object and
	// transfers its ownership 
	
	  if(fP4) {
	     TLorentzVector * p4 = new TLorentzVector(*fP4); 
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	     LOG("GHepParticle", pDEBUG) 
	          << "Return vp = " << utils::print::P4AsShortString(p4);
	#endif
	     return p4;
	  } else {
	    LOG("GHepParticle", pWARN) << "NULL 4-momentum TLorentzVector";
	    return 0;
	  }
	}
	//___________________________________________________________________________
	TLorentzVector * GHepParticle::GetX4(void) const 
	{ 
	// see GHepParticle::X4() for a method that does not create a new object and
	// transfers its ownership
	
	  if(fX4) {
	     TLorentzVector * x4 = new TLorentzVector(*fX4); 
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	     LOG("GHepParticle", pDEBUG) 
	         << "Return x4 = " << utils::print::X4AsString(x4);
	#endif
	     return x4;
	  } else {
	    LOG("GHepParticle", pWARN) << "NULL 4-position TLorentzVector";
	    return 0;
	  }
	}
	//___________________________________________________________________________
using std::setiosflags;
using std::cout;

const double kPCutOff    = 1e-15;
const double kOffShellDm = 0.002; // 2 MeV

ClassImp(GHepParticle)

//____________________________________________________________________________
namespace genie {
 ostream & operator<< (ostream& stream, const GHepParticle & particle)
 {
   particle.Print(stream);
   return stream;
 }
}
//___________________________________________________________________________
GHepParticle::GHepParticle() :
TObject()
{
  this->Init();
}
//___________________________________________________________________________
// TParticle-like constructor
GHepParticle::GHepParticle(int pdg, GHepStatus_t status,
            int mother1, int mother2, int daughter1, int daughter2,
                        const TLorentzVector & p, const TLorentzVector & v) :
TObject(),
fStatus(status),
fFirstMother(mother1),
fLastMother(mother2),
fFirstDaughter(daughter1),
fLastDaughter(daughter2)
{
  this->SetPdgCode(pdg);

  fP4 = new TLorentzVector(p);
  fX4 = new TLorentzVector(v);

  fRescatterCode  = -1;
  fPolzTheta      = -999; 
  fPolzPhi        = -999;    
  fIsBound        = false;
  fRemovalEnergy  = 0.;
}
//___________________________________________________________________________
// TParticle-like constructor
GHepParticle::GHepParticle(int pdg, GHepStatus_t status,
         int mother1, int mother2, int daughter1, int daughter2,
                           double px, double py, double pz, double E,
                                    double x, double y, double z, double t) :
TObject(),
fStatus(status),
fFirstMother(mother1),
fLastMother(mother2),
fFirstDaughter(daughter1),
fLastDaughter(daughter2)
{
  this->SetPdgCode(pdg);

  fP4 = new TLorentzVector(px,py,pz,E);
  fX4 = new TLorentzVector(x,y,z,t);

  fRescatterCode  = -1;
  fPolzTheta      = -999; 
  fPolzPhi        = -999;   
  fIsBound        = false;
  fRemovalEnergy  = 0.; 
}
//___________________________________________________________________________
// Copy constructor
GHepParticle::GHepParticle(const GHepParticle & particle) :
TObject()
{
  this->Init();
  this->Copy(particle);
}
//___________________________________________________________________________
GHepParticle::GHepParticle(TRootIOCtor*) :
TObject(),
fPdgCode(0),
fStatus(kIStUndefined),
fRescatterCode(-1),
fFirstMother(-1),
fLastMother(-1),
fFirstDaughter(-1),
fLastDaughter(-1),
fP4(0), 
fX4(0),
fPolzTheta(-999.),
fPolzPhi(-999.),
fRemovalEnergy(0),
fIsBound(false)
{

}
//___________________________________________________________________________
GHepParticle::~GHepParticle()
{
  this->CleanUp();
}
//___________________________________________________________________________
string GHepParticle::Name(void) const
{
  this->AssertIsKnownParticle();

  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
  return p->GetName();
}
//___________________________________________________________________________
double GHepParticle::Mass(void) const
{
  this->AssertIsKnownParticle();

  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
  return p->Mass();
}
//___________________________________________________________________________
double GHepParticle::Charge(void) const
{
  this->AssertIsKnownParticle();

  TParticlePDG * p = PDGLibrary::Instance()->Find(fPdgCode);
  return p->Charge();
}
//___________________________________________________________________________
double GHepParticle::KinE(bool mass_from_pdg) const
{
  if(!fP4) {
    LOG("GHepParticle", pWARN) << "4-momentum not yet set!";
    return 0;
  }

  double E = fP4->Energy();
  double M = ( (mass_from_pdg) ? this->Mass() : fP4->M() );
  double K = E-M;

  K = TMath::Max(K,0.);
  return K;
}
//___________________________________________________________________________
int GHepParticle::Z(void) const
{
// Decoding Z from the PDG code

  if(!pdg::IsIon(fPdgCode)) 
    return -1;
  else
    return pdg::IonPdgCodeToZ(fPdgCode);
}
//___________________________________________________________________________
int GHepParticle::A(void) const
{
// Decoding A from the PDG code

  if(!pdg::IsIon(fPdgCode)) 
    return -1;
  else
    return pdg::IonPdgCodeToA(fPdgCode);
}
//___________________________________________________________________________
TLorentzVector * GHepParticle::GetP4(void) const 
{ 
// see GHepParticle::P4() for a method that does not create a new object and
// transfers its ownership 

  if(fP4) {
     TLorentzVector * p4 = new TLorentzVector(*fP4); 
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
     LOG("GHepParticle", pDEBUG) 
          << "Return vp = " << utils::print::P4AsShortString(p4);
#endif
     return p4;
  } else {
    LOG("GHepParticle", pWARN) << "NULL 4-momentum TLorentzVector";
    return 0;
  }
}
//___________________________________________________________________________
TLorentzVector * GHepParticle::GetX4(void) const 
{ 
// see GHepParticle::X4() for a method that does not create a new object and
// transfers its ownership

  if(fX4) {
     TLorentzVector * x4 = new TLorentzVector(*fX4); 
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
     LOG("GHepParticle", pDEBUG) 
         << "Return x4 = " << utils::print::X4AsString(x4);
#endif
     return x4;
  } else {
    LOG("GHepParticle", pWARN) << "NULL 4-position TLorentzVector";
    return 0;
  }
}
//___________________________________________________________________________
  if(! (p>0) ) {
	  if(! p>0) {


GHEP/GHepRecord.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	using namespace genie;
	
	ClassImp(GHepRecord)
	
	int GHepRecord::fPrintLevel = 3;
	
	//___________________________________________________________________________
	namespace genie {
	 ostream & operator << (ostream & stream, const GHepRecord & rec)
	 {
	   rec.Print(stream);
	   return stream;
	 }
	}
	//___________________________________________________________________________
	GHepRecord::GHepRecord() :
	TClonesArray("genie::GHepParticle")
	{
	  this->InitRecord();
	}
	//___________________________________________________________________________
	GHepRecord::GHepRecord(int size) :
	TClonesArray("genie::GHepParticle", size)
	{
	  this->InitRecord();
	}
	//___________________________________________________________________________
	GHepRecord::GHepRecord(const GHepRecord & record) :
	TClonesArray("genie::GHepParticle", record.GetEntries())
	{
	  this->InitRecord();
	  this->Copy(record);
	}
	//___________________________________________________________________________
	GHepRecord::GHepRecord(TRootIOCtor*) :
	TClonesArray("genie::GHepParticle"),
	fInteraction(0),
	fVtx(0), 
	fEventFlags(0), 
	fEventMask(0),
	fWeight(0.),
	fProb(0.),
	fXSec(0.),
	fDiffXSec(0.)
	{
	
	}
	//___________________________________________________________________________
	GHepRecord::~GHepRecord()
	{
	  this->CleanRecord();
	}
	//___________________________________________________________________________
	Interaction * GHepRecord::Summary(void) const
	{
	  if(!fInteraction) {
	    LOG("GHEP", pWARN) << "Returning NULL interaction";
	  }
	  return fInteraction;
	}
	//___________________________________________________________________________
using std::setiosflags;

using namespace genie;

ClassImp(GHepRecord)

int GHepRecord::fPrintLevel = 3;

//___________________________________________________________________________
namespace genie {
 ostream & operator << (ostream & stream, const GHepRecord & rec)
 {
   rec.Print(stream);
   return stream;
 }
}
//___________________________________________________________________________
GHepRecord::GHepRecord() :
TClonesArray("genie::GHepParticle")
{
  this->InitRecord();
}
//___________________________________________________________________________
GHepRecord::GHepRecord(int size) :
TClonesArray("genie::GHepParticle", size)
{
  this->InitRecord();
}
//___________________________________________________________________________
GHepRecord::GHepRecord(const GHepRecord & record) :
TClonesArray("genie::GHepParticle", record.GetEntries())
{
  this->InitRecord();
  this->Copy(record);
}
//___________________________________________________________________________
GHepRecord::GHepRecord(TRootIOCtor*) :
TClonesArray("genie::GHepParticle"),
fInteraction(0),
fVtx(0), 
fEventFlags(0), 
fEventMask(0),
fWeight(0.),
fProb(0.),
fXSec(0.),
fDiffXSec(0.)
{

}
//___________________________________________________________________________
GHepRecord::~GHepRecord()
{
  this->CleanRecord();
}
//___________________________________________________________________________
Interaction * GHepRecord::Summary(void) const
{
  if(!fInteraction) {
    LOG("GHEP", pWARN) << "Returning NULL interaction";
  }
  return fInteraction;
}
//___________________________________________________________________________


GHEP/GHepRecordHistory.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


GHEP/GHepUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


GHEP/GHepVirtualList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


GHEP/GHepVirtualListFolder.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


GiBUU/GiBUUData.cxx


GiBUU/GiBUURESPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


HadronTransport/HAIntranuke2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


HadronTransport/HAIntranuke2015.cxx


HadronTransport/HAIntranuke.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


HadronTransport/HNIntranuke2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  bool is_kaon    = (pdgc==kPdgKP);
	  bool is_baryon  = (pdgc==kPdgProton || pdgc==kPdgNeutron);
	  bool is_gamma   = (pdgc==kPdgGamma);										
  // bool is_kaon    = (pdgc==kPdgKP);   // UNUSED - comment to quiet compiler warnings
  bool is_baryon  = (pdgc==kPdgProton || pdgc==kPdgNeutron);
  bool is_gamma   = (pdgc==kPdgGamma);										


HadronTransport/HNIntranuke2015.cxx


HadronTransport/HNIntranuke.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  bool is_kaon    = (pdgc==kPdgKP);
	  bool is_baryon  = (pdgc==kPdgProton || pdgc==kPdgNeutron);
	  bool is_gamma   = (pdgc==kPdgGamma);										
  // bool is_kaon    = (pdgc==kPdgKP);  // UNUSED - comment to quiet compiler warnings
  bool is_baryon  = (pdgc==kPdgProton || pdgc==kPdgNeutron);
  bool is_gamma   = (pdgc==kPdgGamma);										


HadronTransport/Intranuke2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	    //	    p->Pdg() == kPdgGamma   ||
		    p->Pdg() == kPdgGamma   ||


HadronTransport/Intranuke2015.cxx


HadronTransport/Intranuke.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	    //	    p->Pdg() == kPdgGamma   ||
		    p->Pdg() == kPdgGamma   ||


HadronTransport/INukeDeltaPropg.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


HadronTransport/INukeException.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


HadronTransport/INukeHadroData2014.cxx
	
	  LOG("INukeData", pDEBUG)  << "Querying hA cross section at ke  = " << ke << " and target " << targA;
	
	  if (hpdgc == kPdgPiP) {
	  // handle pi+
	        if (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
	   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
	   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
	   else {
	     LOG("INukeData", pWARN) 
	         << "Pi+'s don't have this fate: " << INukeHadroFates::AsString(fate);
	     return 0;
	   }
	
	  } else if (hpdgc == kPdgPiM) {
	   // handle pi-
	   if      (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
	   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
	   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
	   else {
	     LOG("INukeData", pWARN) 
	        << "Pi-'s don't have this fate: " << INukeHadroFates::AsString(fate);
	     return 0;
	   }
	
	  } else if (hpdgc == kPdgPi0) {
	   // handle pi0
	        if (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
	   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
	   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
	   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
	   else {
	     LOG("INukeData", pWARN) 
	        << "Pi0's don't have this fate: " << INukeHadroFates::AsString(fate);
	       return 0;
	   }
	  } 
	
	  LOG("INukeData", pWARN) 
	      << "Can't handle particles with pdg code = " << hpdgc;
	  return 0;
	}
	//____________________________________________________________________________
	double INukeHadroData2014::FracAIndep(int hpdgc, INukeFateHA_t fate, double ke) const
	{
	// return the x-section fraction for the input fate for the particle with the input pdg 
	// code at the input kinetic energy
	
	  ke = TMath::Max(fMinKinEnergy,   ke);
	  ke = TMath::Min(fMaxKinEnergyHA, ke);
	
	  LOG("INukeData", pDEBUG)  << "Querying hA cross section at ke = " << ke;
	
	  if(hpdgc == kPdgProton) {
	   /* handle protons */
	        if (fate == kIHAFtCEx    ) return TMath::Max(0., fFracPA_CEx     -> Evaluate (ke));
	   else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracPA_Elas    -> Evaluate (ke));
	   else if (fate == kIHAFtInelas ) return TMath::Max(0., fFracPA_Inel    -> Evaluate (ke));
	   else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracPA_Abs     -> Evaluate (ke));
	   else if (fate == kIHAFtPiProd ) return TMath::Max(0., fFracPA_PiPro   -> Evaluate (ke));
	   else {
	     LOG("INukeData", pWARN) 
	       << "Protons don't have this fate: " << INukeHadroFates::AsString(fate);
	     return 0;
	   }
	
	  } else if (hpdgc == kPdgNeutron) {
	   /* handle neutrons */
	        if (fate == kIHAFtCEx    ) return TMath::Max(0., fFracNA_CEx     -> Evaluate (ke));
	   else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracNA_Elas    -> Evaluate (ke));
	   else if (fate == kIHAFtInelas ) return TMath::Max(0., fFracNA_Inel    -> Evaluate (ke));
	   else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracNA_Abs     -> Evaluate (ke));
	   else if (fate == kIHAFtPiProd ) return TMath::Max(0., fFracNA_PiPro   -> Evaluate (ke));
	   else {
	     LOG("INukeData", pWARN) 
	       << "Neutrons don't have this fate: " << INukeHadroFates::AsString(fate);
	     return 0;
	   }
	
	  } else if (hpdgc == kPdgKP) {
	   /* handle K+ */
	  if (fate == kIHAFtInelas ) return TMath::Max(0., fFracKA_Inel    -> Evaluate (ke));
	  else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracKA_Abs     -> Evaluate (ke));
	  //  else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracKA_Elas    -> Evaluate (ke));
	  else {
	    LOG("INukeData", pWARN) 
	      << "K+'s don't have this fate: " << INukeHadroFates::AsString(fate);
	       return 0;
	   }
	  }
	  LOG("INukeData", pWARN) 
	      << "Can't handle particles with pdg code = " << hpdgc;
	  return 0;
	}
	//____________________________________________________________________________
	double INukeHadroData2014::XSec(int hpdgc, INukeFateHN_t fate, double ke, int targA, int targZ) const
	{
	// return the x-section for the input fate for the particle with the input pdg 
	// code at the input kinetic energy
	//
	  ke = TMath::Max(fMinKinEnergy,   ke);
	  ke = TMath::Min(fMaxKinEnergyHN, ke);
	
	  LOG("INukeData", pDEBUG)  << "Querying hN cross section at ke = " << ke;
	
	  double xsec=0;
	
	    if (hpdgc == kPdgPiP) {
	    /* handle pi+ */
	         if (fate == kIHNFtCEx   ) {xsec = TMath::Max(0., fXSecPipp_CEx  -> Evaluate(ke)) *  targZ;
  targA = TMath::Min(208, targA);  // A <= 208

  LOG("INukeData", pDEBUG)  << "Querying hA cross section at ke  = " << ke << " and target " << targA;

  if (hpdgc == kPdgPiP) {
  // handle pi+
        if (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
   else {
     LOG("INukeData", pWARN) 
         << "Pi+'s don't have this fate: " << INukeHadroFates::AsString(fate);
     return 0;
   }

  } else if (hpdgc == kPdgPiM) {
   // handle pi-
   if      (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
   else {
     LOG("INukeData", pWARN) 
        << "Pi-'s don't have this fate: " << INukeHadroFates::AsString(fate);
     return 0;
   }

  } else if (hpdgc == kPdgPi0) {
   // handle pi0
        if (fate == kIHAFtCEx    ) return TMath::Max(0., TfracPipA_CEx     -> Interpolate (targA,ke));
   else if (fate == kIHAFtElas   ) return TMath::Max(0., TfracPipA_Elas    -> Interpolate (targA,ke));
   else if (fate == kIHAFtInelas ) return TMath::Max(0., TfracPipA_Inelas  -> Interpolate (targA,ke));
   else if (fate == kIHAFtAbs    ) return TMath::Max(0., TfracPipA_Abs     -> Interpolate (targA,ke));
   else if (fate == kIHAFtPiProd ) return TMath::Max(0., TfracPipA_PiPro   -> Interpolate (targA,ke));
   else {
     LOG("INukeData", pWARN) 
        << "Pi0's don't have this fate: " << INukeHadroFates::AsString(fate);
       return 0;
   }
  } 

  LOG("INukeData", pWARN) 
      << "Can't handle particles with pdg code = " << hpdgc;
  return 0;
}
//____________________________________________________________________________
double INukeHadroData2014::FracAIndep(int hpdgc, INukeFateHA_t fate, double ke) const
{
// return the x-section fraction for the input fate for the particle with the input pdg 
// code at the input kinetic energy

  ke = TMath::Max(fMinKinEnergy,   ke);
  ke = TMath::Min(fMaxKinEnergyHA, ke);

  LOG("INukeData", pDEBUG)  << "Querying hA cross section at ke = " << ke;

  if(hpdgc == kPdgProton) {
   /* handle protons */
        if (fate == kIHAFtCEx    ) return TMath::Max(0., fFracPA_CEx     -> Evaluate (ke));
   else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracPA_Elas    -> Evaluate (ke));
   else if (fate == kIHAFtInelas ) return TMath::Max(0., fFracPA_Inel    -> Evaluate (ke));
   else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracPA_Abs     -> Evaluate (ke));
   else if (fate == kIHAFtPiProd ) return TMath::Max(0., fFracPA_PiPro   -> Evaluate (ke));
   else {
     LOG("INukeData", pWARN) 
       << "Protons don't have this fate: " << INukeHadroFates::AsString(fate);
     return 0;
   }

  } else if (hpdgc == kPdgNeutron) {
   /* handle neutrons */
        if (fate == kIHAFtCEx    ) return TMath::Max(0., fFracNA_CEx     -> Evaluate (ke));
   else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracNA_Elas    -> Evaluate (ke));
   else if (fate == kIHAFtInelas ) return TMath::Max(0., fFracNA_Inel    -> Evaluate (ke));
   else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracNA_Abs     -> Evaluate (ke));
   else if (fate == kIHAFtPiProd ) return TMath::Max(0., fFracNA_PiPro   -> Evaluate (ke));
   else {
     LOG("INukeData", pWARN) 
       << "Neutrons don't have this fate: " << INukeHadroFates::AsString(fate);
     return 0;
   }

  } else if (hpdgc == kPdgKP) {
   /* handle K+ */
  if (fate == kIHAFtInelas ) return TMath::Max(0., fFracKA_Inel    -> Evaluate (ke));
  else if (fate == kIHAFtAbs    ) return TMath::Max(0., fFracKA_Abs     -> Evaluate (ke));
  //  else if (fate == kIHAFtElas   ) return TMath::Max(0., fFracKA_Elas    -> Evaluate (ke));
  else {
    LOG("INukeData", pWARN) 
      << "K+'s don't have this fate: " << INukeHadroFates::AsString(fate);
       return 0;
   }
  }
  LOG("INukeData", pWARN) 
      << "Can't handle particles with pdg code = " << hpdgc;
  return 0;
}
//____________________________________________________________________________
double INukeHadroData2014::XSec(int hpdgc, INukeFateHN_t fate, double ke, int targA, int targZ) const
{
// return the x-section for the input fate for the particle with the input pdg 
// code at the input kinetic energy
//
  ke = TMath::Max(fMinKinEnergy,   ke);
  ke = TMath::Min(fMaxKinEnergyHN, ke);

  LOG("INukeData", pDEBUG)  << "Querying hN cross section at ke = " << ke;

  double xsec=0;

    if (hpdgc == kPdgPiP) {
    /* handle pi+ */
         if (fate == kIHNFtCEx   ) {xsec = TMath::Max(0., fXSecPipp_CEx  -> Evaluate(ke)) *  targZ;


HadronTransport/INukeHadroData2015.cxx


HadronTransport/INukeHadroData.cxx


HadronTransport/INukeNucleonCorr.cxx


HadronTransport/INukeOset.cxx


HadronTransport/INukeOsetFormula.cxx


HadronTransport/INukeOsetTable.cxx


HadronTransport/INukeUtils2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  for(int i=0; i<200; i++) {
	     double w = GenPhaseSpace.Generate();
  for(int idec=0; idec<200; idec++) {
     double w = GenPhaseSpace.Generate();


HadronTransport/INukeUtils2015.cxx


HadronTransport/INukeUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  for(int i=0; i<200; i++) {
	     double w = GenPhaseSpace.Generate();
  for(int idec=0; idec<200; idec++) {
     double w = GenPhaseSpace.Generate();


Interaction/InitialState.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	double InitialState::comE() const
	{
string InitialState::AsString(void) const
{
// Code-ify the interaction in a string to be used as (part of a) keys
// Template:
//     nu_pdg:code;tgt-pdg:code;

  ostringstream init_state;

  init_state << "nu-pdg:"  << this->ProbePdg()  << ";";
  init_state << "tgt-pdg:" << this->Tgt().Pdg() << ";";

  return init_state.str();
}
//___________________________________________________________________________
	  TLorentzVector * k4 = this->GetProbeP4(kRfLab);
	  TLorentzVector * p4 = fTgt->HitNucP4Ptr();
	  
	  *k4 += *p4; // now k4 represents centre-of-mass 4-momentum
	  double s = k4->Dot(*k4); // dot-product with itself
	  double E = TMath::Sqrt(s);
	
	  delete k4;
	  
	  return E;
	}
	//___________________________________________________________________________
	string InitialState::AsString(void) const
	{
	// Code-ify the interaction in a string to be used as (part of a) keys
	// Template:
	//     nu_pdg:code;tgt-pdg:code;
	
	  ostringstream init_state;
	
	  init_state << "nu-pdg:"  << this->ProbePdg()  << ";";
	  init_state << "tgt-pdg:" << this->Tgt().Pdg() << ";";
	
	  return init_state.str();
	}
	//___________________________________________________________________________


Interaction/Interaction.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Interaction/Kinematics.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  double xs = this->x(selected);
	  double x = this->x(selected);
	  return (x>0) ? TMath::Log(x) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::Logy(bool selected) const
	{
	  double y = this->y(selected);
  return (xs>0) ? TMath::Log(xs) : -99999;
}
//____________________________________________________________________________
double Kinematics::Logy(bool selected) const
{
  double ys = this->y(selected);
	  return (y>0) ? TMath::Log(y) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::LogQ2(bool selected) const
	{
	  double Q2 = this->Q2(selected);
	  return (Q2>0) ? TMath::Log(Q2) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::LogW(bool selected) const
	{
	  double W = this->W(selected);
	  return (W>0) ? TMath::Log(W) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::Log10x(bool selected) const
	{
	  double x = this->x(selected);
	  return (x>0) ? TMath::Log10(x) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::Log10y(bool selected) const
	{
	  double y = this->y(selected);
	  return (y>0) ? TMath::Log10(y) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::Log10Q2(bool selected) const
	{
	  double Q2 = this->Q2(selected);
	  return (Q2>0) ? TMath::Log10(Q2) : -99999;
	}
	//____________________________________________________________________________
	double Kinematics::Log10W(bool selected) const
	{
	  double W = this->W(selected);
	  return (W>0) ? TMath::Log10(W) : -99999;
	}
	//____________________________________________________________________________
  return (ys>0) ? TMath::Log(ys) : -99999;
}
//____________________________________________________________________________
double Kinematics::LogQ2(bool selected) const
{
  double Q2s = this->Q2(selected);
  return (Q2s>0) ? TMath::Log(Q2s) : -99999;
}
//____________________________________________________________________________
double Kinematics::LogW(bool selected) const
{
  double Ws = this->W(selected);
  return (Ws>0) ? TMath::Log(Ws) : -99999;
}
//____________________________________________________________________________
double Kinematics::Log10x(bool selected) const
{
  double xs = this->x(selected);
  return (xs>0) ? TMath::Log10(xs) : -99999;
}
//____________________________________________________________________________
double Kinematics::Log10y(bool selected) const
{
  double ys = this->y(selected);
  return (ys>0) ? TMath::Log10(ys) : -99999;
}
//____________________________________________________________________________
double Kinematics::Log10Q2(bool selected) const
{
  double Q2s = this->Q2(selected);
  return (Q2s>0) ? TMath::Log10(Q2s) : -99999;
}
//____________________________________________________________________________
double Kinematics::Log10W(bool selected) const
{
  double Ws = this->W(selected);
  return (Ws>0) ? TMath::Log10(Ws) : -99999;
}
//____________________________________________________________________________
void Kinematics::Setx(double xbj, bool selected)
{
// sets the running or selected value of Bjorken scaling variable x

  if(xbj<0 || xbj>1) {
     LOG("Interaction", pWARN)
                      << "Setting unphysical value for x (x = " << xbj << ")";
  }
  KineVar_t kvar = (selected) ? kKVSelx : kKVx;
  this->SetKV(kvar, xbj);
}
//____________________________________________________________________________
	void Kinematics::Setx(double x, bool selected)
	{
	// sets the running or selected value of Bjorken scaling variable x
	
	  if(x<0 || x>1) {
	     LOG("Interaction", pWARN)
	                      << "Setting unphysical value for x (x = " << x << ")";
	  }
	  KineVar_t kvar = (selected) ? kKVSelx : kKVx;
	  this->SetKV(kvar, x);
	}
	//____________________________________________________________________________
void Kinematics::Sety(double inel_y, bool selected)
{
// sets the running or selected value of inelasticity y

  if(inel_y<0 || inel_y>1) {
     LOG("Interaction", pWARN)
                     << "Setting unphysical value for y (y = " << inel_y << ")";
  }
  KineVar_t kvar = (selected) ? kKVSely : kKVy;
  this->SetKV(kvar, inel_y);
}
//____________________________________________________________________________
void Kinematics::SetQ2(double Qsqrd, bool selected)
{
// sets the running or selected value of momentum transfer Q2 (>0)

  if(Qsqrd<0) {
     LOG("Interaction", pWARN)
                 << "Setting unphysical value for Q2 (Q2 = " << Qsqrd << ")";
  }
  KineVar_t kvar = (selected) ? kKVSelQ2 : kKVQ2;
  this->SetKV(kvar, Qsqrd);
}
//____________________________________________________________________________
void Kinematics::Setq2(double qsqrd, bool selected)
{
// sets the running or selected value of momentum transfer q2 (<0)

  if(qsqrd>0) {
     LOG("Interaction", pWARN)
                 << "Setting unphysical value for q2 (q2 = " << qsqrd << ")";
  }
  KineVar_t kvar = (selected) ? kKVSelq2 : kKVq2;
  this->SetKV(kvar, qsqrd);
}
//____________________________________________________________________________
void Kinematics::SetW(double hadr_mass_W, bool selected)
{
// sets the running or selected value of invariant hadronic mass W

  if(hadr_mass_W<0) {
     LOG("Interaction", pWARN)
                   << "Setting unphysical value for W (W = " << hadr_mass_W << ")";
  }
  KineVar_t kvar = (selected) ? kKVSelW : kKVW;
  this->SetKV(kvar, hadr_mass_W);
}
//____________________________________________________________________________
void Kinematics::Sett(double tval, bool selected)
{
  KineVar_t kvar = (selected) ? kKVSelt : kKVt;
  this->SetKV(kvar, tval);
}
//____________________________________________________________________________
void Kinematics::SetFSLeptonP4(const TLorentzVector & p4)
{
  fP4Fsl->SetPxPyPzE(p4.Px(), p4.Py(), p4.Pz(), p4.E());
}
//____________________________________________________________________________
void Kinematics::SetFSLeptonP4(double px, double py, double pz, double E)
{
  fP4Fsl->SetPxPyPzE(px,py,pz,E);
}
//____________________________________________________________________________
void Kinematics::SetHadSystP4(const TLorentzVector & p4)
{
  fP4HadSyst->SetPxPyPzE(p4.Px(), p4.Py(), p4.Pz(), p4.E());
}
//____________________________________________________________________________
void Kinematics::SetHadSystP4(double px, double py, double pz, double E)
{
  fP4HadSyst->SetPxPyPzE(px,py,pz,E);
}
//____________________________________________________________________________
bool Kinematics::KVSet(KineVar_t kv) const
{
  if(fKV.count(kv) == 1) return true;
  else return false;
}
//____________________________________________________________________________
double Kinematics::GetKV(KineVar_t kv) const
{
  if(this->KVSet(kv)) {
     map<KineVar_t, double>::const_iterator iter = fKV.find(kv);
     return iter->second;
  } else {
    LOG("Interaction", pWARN)
        << "Kinematic variable: " << KineVar::AsString(kv) << " was not set";
  }
  return -99999;
}
//____________________________________________________________________________
void Kinematics::SetKV(KineVar_t kv, double value)
{
  LOG("Interaction", pDEBUG)
            << "Setting " << KineVar::AsString(kv) << " to " << value;

  if(this->KVSet(kv)) {
     fKV[kv] = value;
  } else {
     fKV.insert( map<KineVar_t, double>::value_type(kv,value) );
  }
}
//____________________________________________________________________________
void Kinematics::ClearRunningValues(void)
{
// clear the running values (leave the selected ones)
//
  fKV.erase( kKVx  );
  fKV.erase( kKVy  );
  fKV.erase( kKVQ2 );
  fKV.erase( kKVq2 );
  fKV.erase( kKVW  );
  fKV.erase( kKVt  );
}
//____________________________________________________________________________
	void Kinematics::Sety(double y, bool selected)
	{
	// sets the running or selected value of inelasticity y
	
	  if(y<0 || y>1) {
	     LOG("Interaction", pWARN)
	                     << "Setting unphysical value for y (y = " << y << ")";
	  }
	  KineVar_t kvar = (selected) ? kKVSely : kKVy;
	  this->SetKV(kvar, y);
	}
	//____________________________________________________________________________
	void Kinematics::SetQ2(double Q2, bool selected)
	{
	// sets the running or selected value of momentum transfer Q2 (>0)
	
	  if(Q2<0) {
	     LOG("Interaction", pWARN)
	                 << "Setting unphysical value for Q2 (Q2 = " << Q2 << ")";
	  }
	  KineVar_t kvar = (selected) ? kKVSelQ2 : kKVQ2;
	  this->SetKV(kvar, Q2);
	}
	//____________________________________________________________________________
	void Kinematics::Setq2(double q2, bool selected)
	{
	// sets the running or selected value of momentum transfer q2 (<0)
	
	  if(q2>0) {
	     LOG("Interaction", pWARN)
	                 << "Setting unphysical value for q2 (q2 = " << q2 << ")";
	  }
	  KineVar_t kvar = (selected) ? kKVSelq2 : kKVq2;
	  this->SetKV(kvar, q2);
	}
	//____________________________________________________________________________
	void Kinematics::SetW(double W, bool selected)
	{
	// sets the running or selected value of invariant hadronic mass W
	
	  if(W<0) {
	     LOG("Interaction", pWARN)
	                   << "Setting unphysical value for W (W = " << W << ")";
	  }
	  KineVar_t kvar = (selected) ? kKVSelW : kKVW;
	  this->SetKV(kvar, W);
	}
	//____________________________________________________________________________
	void Kinematics::Sett(double t, bool selected)
	{
	  KineVar_t kvar = (selected) ? kKVSelt : kKVt;
	  this->SetKV(kvar, t);
	}
	//____________________________________________________________________________
	void Kinematics::SetFSLeptonP4(const TLorentzVector & p4)
	{
	  fP4Fsl->SetPxPyPzE(p4.Px(), p4.Py(), p4.Pz(), p4.E());
	}
	//____________________________________________________________________________
	void Kinematics::SetFSLeptonP4(double px, double py, double pz, double E)
	{
	  fP4Fsl->SetPxPyPzE(px,py,pz,E);
	}
	//____________________________________________________________________________
	void Kinematics::SetHadSystP4(const TLorentzVector & p4)
	{
	  fP4HadSyst->SetPxPyPzE(p4.Px(), p4.Py(), p4.Pz(), p4.E());
	}
	//____________________________________________________________________________
	void Kinematics::SetHadSystP4(double px, double py, double pz, double E)
	{
	  fP4HadSyst->SetPxPyPzE(px,py,pz,E);
	}
	//____________________________________________________________________________
	bool Kinematics::KVSet(KineVar_t kv) const
	{
	  if(fKV.count(kv) == 1) return true;
	  else return false;
	}
	//____________________________________________________________________________
	double Kinematics::GetKV(KineVar_t kv) const
	{
	  if(this->KVSet(kv)) {
	     map<KineVar_t, double>::const_iterator iter = fKV.find(kv);
	     return iter->second;
	  } else {
	    LOG("Interaction", pWARN)
	        << "Kinematic variable: " << KineVar::AsString(kv) << " was not set";
	  }
	  return -99999;
	}
	//____________________________________________________________________________
	void Kinematics::SetKV(KineVar_t kv, double value)
	{
	  LOG("Interaction", pDEBUG)
	            << "Setting " << KineVar::AsString(kv) << " to " << value;
	
	  if(this->KVSet(kv)) {
	     fKV[kv] = value;
	  } else {
	     fKV.insert( map<KineVar_t, double>::value_type(kv,value) );
	  }
	}
	//____________________________________________________________________________
	void Kinematics::ClearRunningValues(void)
	{
	// clear the running values (leave the selected ones)
	//
	  fKV.erase( kKVx  );
	  fKV.erase( kKVy  );
	  fKV.erase( kKVQ2 );
	  fKV.erase( kKVq2 );
	  fKV.erase( kKVW  );
	  fKV.erase( kKVt  );
	}
	//____________________________________________________________________________


Interaction/KPhaseSpace.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	    double ml   = PDGLibrary::Instance()->Find(fInteraction->FSPrimLeptonPdg())->Mass();
  //double ml   = PDGLibrary::Instance()->Find(fInteraction->FSPrimLeptonPdg())->Mass();
	    double MA   = PDGLibrary::Instance()->Find(tgtpdgc)->Mass();
	    double m    = ml + kPionMass;
	    double m2   = TMath::Power(m,2);
	    double Ethr = m + 0.5*m2/MA;
    double mpi  = pi.IsWeakCC() ? kPionMass : kPi0Mass;
    double MA   = PDGLibrary::Instance()->Find(tgtpdgc)->Mass();
    double m    = ml + mpi;
    double m2   = TMath::Power(m,2);
    double Ethr = m + 0.5*m2/MA;
  // Compute limits for the input kinematic variable irrespective of any other
	// Compute limits for the input kinematic variable irrespective of any other
  // relevant kinematical variable
  //
  assert(fInteraction);

	// relevant kinematical variable
	//
	  assert(fInteraction);
	
  case(kKVt)  : return this->TLim();  break;
    LOG("KPhaseSpace", pERROR) 
      << "Couldn't compute limits for " << KineVar::AsString(kvar);
	   LOG("KPhaseSpace", pERROR) 
	        << "Couldn't compute limits for " << KineVar::AsString(kvar);
    Range1D_t R(-1.,-1);
	   Range1D_t R(-1.,-1);
    return R;
  }
}
//____________________________________________________________________________
double KPhaseSpace::Minimum(KineVar_t kvar) const
{
  Range1D_t lim = this->Limits(kvar);
  return lim.min;
}
//___________________________________________________________________________
double KPhaseSpace::Maximum(KineVar_t kvar) const
{
  Range1D_t lim = this->Limits(kvar);
  return lim.max;
}
//___________________________________________________________________________
bool KPhaseSpace::IsAboveThreshold(void) const
{
  double E    = 0.;
  double Ethr = this->Threshold();

  const ProcessInfo &  pi         = fInteraction->ProcInfo();
  const InitialState & init_state = fInteraction->InitState();

  if (pi.IsCoherent()       || 
      pi.IsInverseMuDecay() || 
      pi.IsIMDAnnihilation() || 
      pi.IsNuElectronElastic()) 
  {
      E = init_state.ProbeE(kRfLab);
  }

  if(pi.IsQuasiElastic()     || 
     pi.IsInverseBetaDecay() ||
     pi.IsResonant()         || 
     pi.IsDeepInelastic()    || 
     pi.IsDiffractive()      || 
     pi.IsSingleKaon()       ||
     pi.IsAMNuGamma()) 
  {
      E = init_state.ProbeE(kRfHitNucRest);
  }

  LOG("KPhaseSpace", pDEBUG) << "E = " << E << ", Ethr = " << Ethr; 
  return (E>Ethr);
}
//___________________________________________________________________________
bool KPhaseSpace::IsAllowed(void) const
{
  const ProcessInfo & pi   = fInteraction->ProcInfo();
  const Kinematics &  kine = fInteraction->Kine();

  // ASK single kaon:
	   return R;
	  }
	}
	//____________________________________________________________________________
	double KPhaseSpace::Minimum(KineVar_t kvar) const
	{
	  Range1D_t lim = this->Limits(kvar);
	  return lim.min;
	}
	//___________________________________________________________________________
	double KPhaseSpace::Maximum(KineVar_t kvar) const
	{
	  Range1D_t lim = this->Limits(kvar);
	  return lim.max;
	}
	//___________________________________________________________________________
	bool KPhaseSpace::IsAboveThreshold(void) const
	{
	  double E    = 0.;
	  double Ethr = this->Threshold();
	
	  const ProcessInfo &  pi         = fInteraction->ProcInfo();
	  const InitialState & init_state = fInteraction->InitState();
	
	  if (pi.IsCoherent()       || 
	      pi.IsInverseMuDecay() || 
	      pi.IsIMDAnnihilation() || 
	      pi.IsNuElectronElastic()) 
	  {
	      E = init_state.ProbeE(kRfLab);
	  }
	
	  if(pi.IsQuasiElastic()     || 
	     pi.IsInverseBetaDecay() ||
	     pi.IsResonant()         || 
	     pi.IsDeepInelastic()    || 
	     pi.IsDiffractive()      || 
	     pi.IsSingleKaon()       ||
	     pi.IsAMNuGamma()) 
	  {
	      E = init_state.ProbeE(kRfHitNucRest);
	  }
	
	  LOG("KPhaseSpace", pDEBUG) << "E = " << E << ", Ethr = " << Ethr; 
	  return (E>Ethr);
	}
	//___________________________________________________________________________
	bool KPhaseSpace::IsAllowed(void) const
	{
	  const ProcessInfo & pi   = fInteraction->ProcInfo();
	  const Kinematics &  kine = fInteraction->Kine();
	
	  // ASK single kaon:
  // Computes momentum transfer (Q2>0) limits @ the input invariant mass
	// Computes momentum transfer (Q2>0) limits @ the input invariant mass
  // The calculation proceeds as in kinematics::InelQ2Lim_W(). 
  // For QEL, W is set to the recoil nucleon mass
  //
	// The calculation proceeds as in kinematics::InelQ2Lim_W(). 
	// For QEL, W is set to the recoil nucleon mass
	
	  Range1D_t Q2l;
	  Q2l.min = -1;
	  Q2l.max = -1;
	
	  const ProcessInfo & pi = fInteraction->ProcInfo();
	  bool is_qel  = pi.IsQuasiElastic()  || pi.IsInverseBetaDecay();
	  bool is_inel = pi.IsDeepInelastic() || pi.IsResonant();
	
	  if(!is_qel && !is_inel) return Q2l;
	
	  const InitialState & init_state = fInteraction->InitState();
	  double Ev  = init_state.ProbeE(kRfHitNucRest);
	  double M   = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
	  double ml  = fInteraction->FSPrimLepton()->Mass();
	
	  double W = 0;
	  if(is_qel) W = fInteraction->RecoilNucleon()->Mass();
	  else       W = kinematics::W(fInteraction);
	
	  if (pi.IsInverseBetaDecay()) {
	     Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W, controls::kMinQ2Limit_VLE);
	  } else {
	     Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W);
	  }
	  return Q2l;
	}
	//____________________________________________________________________________
	Range1D_t KPhaseSpace::q2Lim_W(void) const
	{
	// As Q2Lim_W(void) but with reversed sign (Q2 -> q2)
	//
	  Range1D_t Q2 = this->Q2Lim_W();
	  Range1D_t q2;
	  q2.min = - Q2.max;
	  q2.max = - Q2.min;
	  return q2;
	}
	//____________________________________________________________________________
	Range1D_t KPhaseSpace::Q2Lim(void) const
	{
	// Computes momentum transfer (Q2>0) limits irrespective of the invariant mass
	// For QEL this is identical to Q2Lim_W (since W is fixed)
	// For RES & DIS, the calculation proceeds as in kinematics::InelQ2Lim(). 
	//
	  Range1D_t Q2l;
	  Q2l.min = -1;
	  Q2l.max = -1;
	
	  const ProcessInfo & pi = fInteraction->ProcInfo();
	  bool is_qel  = pi.IsQuasiElastic()  || pi.IsInverseBetaDecay();
	  bool is_inel = pi.IsDeepInelastic() || pi.IsResonant();
	
	  if(!is_qel && !is_inel) return Q2l;
	
	  const InitialState & init_state = fInteraction->InitState();
	  double Ev  = init_state.ProbeE(kRfHitNucRest);
	  double M   = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
	  double ml  = fInteraction->FSPrimLepton()->Mass();
	
	  const XclsTag & xcls = fInteraction->ExclTag();
	
	  // quasi-elastic
	  if(is_qel) {
	    double W = fInteraction->RecoilNucleon()->Mass();
	    if(xcls.IsCharmEvent()) { 
	      int charm_pdgc = xcls.CharmHadronPdg();           
  // TODO: For now, choosing to handle Q2 at fixed W for coherent in the 
  // same way as for the general Q2 limits... but shouldn't we just use
  // W = m_pi? - which we do in Q2Lim() anyway... seems like there are
  // cleanup opportunities here.

  Range1D_t Q2l;
  Q2l.min = -1;
  Q2l.max = -1;

  const ProcessInfo & pi = fInteraction->ProcInfo();
  bool is_qel  = pi.IsQuasiElastic()  || pi.IsInverseBetaDecay();
  bool is_inel = pi.IsDeepInelastic() || pi.IsResonant();
  bool is_coh  = pi.IsCoherent();

  if(!is_qel && !is_inel && !is_coh) return Q2l;

  if(is_coh) {
    return Q2Lim();
  }

  const InitialState & init_state = fInteraction->InitState();
  double Ev  = init_state.ProbeE(kRfHitNucRest);
  double M   = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
  double ml  = fInteraction->FSPrimLepton()->Mass();

  double W = 0;
  if(is_qel) W = fInteraction->RecoilNucleon()->Mass();
  else       W = kinematics::W(fInteraction);

  if (pi.IsInverseBetaDecay()) {
     Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W, controls::kMinQ2Limit_VLE);
  } else {
     Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W);
  }
  return Q2l;
}
//____________________________________________________________________________
Range1D_t KPhaseSpace::q2Lim_W(void) const
{
// As Q2Lim_W(void) but with reversed sign (Q2 -> q2)
//
  Range1D_t Q2 = this->Q2Lim_W();
  Range1D_t q2;
  q2.min = - Q2.max;
  q2.max = - Q2.min;
  return q2;
}
//____________________________________________________________________________
Range1D_t KPhaseSpace::Q2Lim(void) const
{
  // Computes momentum transfer (Q2>0) limits irrespective of the invariant mass
  // For QEL this is identical to Q2Lim_W (since W is fixed)
  // For RES & DIS, the calculation proceeds as in kinematics::InelQ2Lim(). 
  //
  Range1D_t Q2l;
  Q2l.min = -1;
  Q2l.max = -1;

  const ProcessInfo & pi = fInteraction->ProcInfo();
  bool is_qel  = pi.IsQuasiElastic()  || pi.IsInverseBetaDecay();
  bool is_inel = pi.IsDeepInelastic() || pi.IsResonant();
  bool is_coh  = pi.IsCoherent();

  if(!is_qel && !is_inel && !is_coh) return Q2l;

  const InitialState & init_state = fInteraction->InitState();
  double Ev  = init_state.ProbeE(kRfHitNucRest);
  double M   = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
  double ml  = fInteraction->FSPrimLepton()->Mass();

  if(is_coh) {
    bool pionIsCharged = pi.IsWeakCC();
    double mpi = pionIsCharged ? kPionMass : kPi0Mass;
    Q2l = kinematics::CohQ2Lim(M, mpi, ml, Ev);
    return Q2l;
  }

  const XclsTag & xcls = fInteraction->ExclTag();

  // quasi-elastic
  if(is_qel) {
    double W = fInteraction->RecoilNucleon()->Mass();
    if(xcls.IsCharmEvent()) { 
      int charm_pdgc = xcls.CharmHadronPdg();           
	       Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W,controls::kMinQ2Limit_VLE);
	    } else {
	       Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W);
	    }
      Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W,controls::kMinQ2Limit_VLE);
    } else {
      Q2l = kinematics::InelQ2Lim_W(Ev,M,ml,W);
    }
  // Computes x-limits;

	// Computes x-limits;
	
Range1D_t KPhaseSpace::YLim(double xsi) const
{
  // Paschos-Schalla xsi parameter for y-limits in COH
  // From PRD 80, 033005 (2009)
  
  Range1D_t yl;
  yl.min = -1;
  yl.max = -1;

  const ProcessInfo & pi = fInteraction->ProcInfo();

  //COH
  bool is_coh = pi.IsCoherent();
  if(is_coh) {  
    const InitialState & init_state = fInteraction->InitState();
    const Kinematics & kine = fInteraction->Kine();
    double Ev = init_state.ProbeE(kRfHitNucRest);
    double Q2 = kine.Q2();
    bool pionIsCharged = pi.IsWeakCC();
    double Mn = init_state.Tgt().Mass();
    double mpi = pionIsCharged ? kPionMass : kPi0Mass;
    double mlep = fInteraction->FSPrimLepton()->Mass();
    yl = kinematics::CohYLim(Mn, mpi, mlep, Ev, Q2, xsi);
    return yl;
  } else {
    return this->YLim();
  }
}
//____________________________________________________________________________
Range1D_t KPhaseSpace::YLim_X(double xsi) const
{
  // Paschos-Schalla xsi parameter for y-limits in COH
  // From PRD 80, 033005 (2009)
  
  const ProcessInfo & pi = fInteraction->ProcInfo();

  //COH
  bool is_coh = pi.IsCoherent();
  if(is_coh) {  
    return this->YLim(xsi);
  } else {
    return this->YLim_X();
  }
}
//____________________________________________________________________________
Range1D_t KPhaseSpace::TLim(void) const
{
  // t limits for Coherent pion production from 
  //   Kartavtsev, Paschos, and Gounaris, PRD 74 054007, and
  //   Paschos and Schalla, PRD 80, 03305
  // TODO: Attempt to assign t bounds for other reactions?
  Range1D_t tl;
  tl.min = -1;
  tl.max = -1;

  const InitialState & init_state = fInteraction->InitState();
  const ProcessInfo & pi = fInteraction->ProcInfo();
  const Kinematics & kine = fInteraction->Kine();
  double Ev = init_state.ProbeE(kRfHitNucRest);
  double Q2 = kine.Q2();
  double nu = Ev * kine.y();
  bool pionIsCharged = pi.IsWeakCC();
  double mpi = pionIsCharged ? kPionMass : kPi0Mass;

  //COH
  bool is_coh = pi.IsCoherent();
  if(is_coh) {  
    tl.min = 1.0 * (Q2 + mpi * mpi)/(2.0 * nu) * (Q2 + mpi * mpi)/(2.0 * nu);
    tl.max = 0.05;
    return tl;
  }
  // RES+DIS
  // IMD
  // Diffractive is more interesting? TODO: Check on diffractive t limits.
  LOG("KPhaseSpace", pWARN) << "It is not sensible to ask for t limits for non-coherent events.";
  return tl;
}
//____________________________________________________________________________


Interaction/ProcessInfo.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Interaction/Target.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Interaction/XclsTag.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


LlewellynSmith/LwlynSmithFFCC.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


LlewellynSmith/LwlynSmithFF.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


LlewellynSmith/LwlynSmithFFNC.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


LlewellynSmith/LwlynSmithQELCCPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  if(! this -> ValidProcess    (interaction) ) return 0.;
  if(! this -> ValidKinematics (interaction) ) return 0.;

  // Get kinematics & init-state parameters
  const Kinematics &   kinematics = interaction -> Kine();
  const InitialState & init_state = interaction -> InitState();
  const Target & target = init_state.Tgt();

  double E  = init_state.ProbeE(kRfHitNucRest);
  double E2 = TMath::Power(E,2);
  double ml = interaction->FSPrimLepton()->Mass();
  double M  = target.HitNucMass();
  double q2 = kinematics.q2();

	  if(! this -> ValidProcess    (interaction) ) {std::cout << "not a valid process"; return 0.;}
	  if(! this -> ValidKinematics (interaction) ) {std::cout << "not valid kinematics"; return 0.;}
	
	  if (kps == kPSFullDiffQE){
  // One of the xsec terms changes sign for antineutrinos
  bool is_neutrino = pdg::IsNeutrino(init_state.ProbePdg());
  int sign = (is_neutrino) ? -1 : 1;

  // Calculate the QEL form factors
  fFormFactors.Calculate(interaction);    

  double F1V   = fFormFactors.F1V();
  double xiF2V = fFormFactors.xiF2V();
  double FA    = fFormFactors.FA();
  double Fp    = fFormFactors.Fp();

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  LOG("LwlynSmith", pDEBUG) << "\n" << fFormFactors;
#endif

  // Calculate auxiliary parameters
  double ml2     = TMath::Power(ml,    2);
  double M2      = TMath::Power(M,     2);
  double M4      = TMath::Power(M2,    2);
  double FA2     = TMath::Power(FA,    2);
  double Fp2     = TMath::Power(Fp,    2);
  double F1V2    = TMath::Power(F1V,   2);
  double xiF2V2  = TMath::Power(xiF2V, 2);
  double Gfactor = M2*kGF2*fCos8c2 / (8*kPi*E2);
  double s_u     = 4*E*M + q2 - ml2;
  double q2_M2   = q2/M2;

  // Compute free nucleon differential cross section
  double A = (0.25*(ml2-q2)/M2) * (
	      (4-q2_M2)*FA2 - (4+q2_M2)*F1V2 - q2_M2*xiF2V2*(1+0.25*q2_M2)
              -4*q2_M2*F1V*xiF2V - (ml2/M2)*( 
               (F1V2+xiF2V2+2*F1V*xiF2V)+(FA2+4*Fp2+4*FA*Fp)+(q2_M2-4)*Fp2));
  double B = -1 * q2_M2 * FA*(F1V+xiF2V);
  double C = 0.25*(FA2 + F1V2 - 0.25*q2_M2*xiF2V2);

  double xsec = Gfactor * (A + sign*B*s_u/M2 + C*s_u*s_u/M4);

#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  LOG("LwlynSmith", pDEBUG)
     << "dXSec[QEL]/dQ2 [FreeN](E = "<< E << ", Q2 = "<< -q2 << ") = "<< xsec;
  LOG("LwlynSmith", pDEBUG) 
                 << "A(Q2) = " << A << ", B(Q2) = " << B << ", C(Q2) = " << C;
#endif

	    return this->FullDifferentialXSec(interaction);
	  }
	
	  // Get kinematics & init-state parameters
	  const Kinematics &   kinematics = interaction -> Kine();
	  const InitialState & init_state = interaction -> InitState();
	  const Target & target = init_state.Tgt();
	
	  double E  = init_state.ProbeE(kRfHitNucRest);
	  double E2 = TMath::Power(E,2);
	  double ml = interaction->FSPrimLepton()->Mass();
	  double M  = target.HitNucMass();
	  double q2 = kinematics.q2();
	
	  // One of the xsec terms changes sign for antineutrinos
	  bool is_neutrino = pdg::IsNeutrino(init_state.ProbePdg());
	  int sign = (is_neutrino) ? -1 : 1;
	
	  // Calculate the QEL form factors
	  fFormFactors.Calculate(interaction);    
	
	  double F1V   = fFormFactors.F1V();
	  double xiF2V = fFormFactors.xiF2V();
	  double FA    = fFormFactors.FA();
	  double Fp    = fFormFactors.Fp();
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("LwlynSmith", pDEBUG) << "\n" << fFormFactors;
	#endif
	
	  // Calculate auxiliary parameters
	  double ml2     = TMath::Power(ml,    2);
	  double M2      = TMath::Power(M,     2);
	  double M4      = TMath::Power(M2,    2);
	  double FA2     = TMath::Power(FA,    2);
	  double Fp2     = TMath::Power(Fp,    2);
	  double F1V2    = TMath::Power(F1V,   2);
	  double xiF2V2  = TMath::Power(xiF2V, 2);
	  double Gfactor = M2*kGF2*fCos8c2 / (8*kPi*E2);
	  double s_u     = 4*E*M + q2 - ml2;
	  double q2_M2   = q2/M2;
	
	  // Compute free nucleon differential cross section
	  double A = (0.25*(ml2-q2)/M2) * (
		      (4-q2_M2)*FA2 - (4+q2_M2)*F1V2 - q2_M2*xiF2V2*(1+0.25*q2_M2)
	              -4*q2_M2*F1V*xiF2V - (ml2/M2)*( 
	               (F1V2+xiF2V2+2*F1V*xiF2V)+(FA2+4*Fp2+4*FA*Fp)+(q2_M2-4)*Fp2));
	  double B = -1 * q2_M2 * FA*(F1V+xiF2V);
	  double C = 0.25*(FA2 + F1V2 - 0.25*q2_M2*xiF2V2);
	
	  double xsec = Gfactor * (A + sign*B*s_u/M2 + C*s_u*s_u/M4);
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("LwlynSmith", pDEBUG)
	     << "dXSec[QEL]/dQ2 [FreeN](E = "<< E << ", Q2 = "<< -q2 << ") = "<< xsec;
	  LOG("LwlynSmith", pDEBUG) 
	                 << "A(Q2) = " << A << ", B(Q2) = " << B << ", C(Q2) = " << C;
	#endif
	

	double LwlynSmithQELCCPXSec::FullDifferentialXSec(const Interaction *  interaction)const{
	
	  // First we need access to all of the particles in the interaction
	  const Kinematics &   kinematics = interaction -> Kine();
	  const InitialState & init_state = interaction -> InitState();
	
	  const TLorentzVector leptonMom = kinematics.FSLeptonP4();
	  const TLorentzVector outNucleonMom = kinematics.HadSystP4();
	
	  TLorentzVector * neutrinoMom = init_state.GetProbeP4();
	  TLorentzVector * inNucleonMom = init_state.TgtPtr()->HitNucP4Ptr();
	
	  //std::cout << "neutrino, target nucleon, lepton, outNucleon" << std::endl;
	  //neutrinoMom->Print();
	  //inNucleonMom->Print();
	  //leptonMom.Print();
	  //outNucleonMom.Print();
	
	  // Now we calculate q and qTilde
	  TLorentzVector qP4(0,0,0,0);
	  TLorentzVector qTildeP4(0,0,0,0);
	  qP4 = *neutrinoMom - leptonMom;
	  qTildeP4 = outNucleonMom - *inNucleonMom;
	  
	  double Q2tilde = -1 * qTildeP4.Mag2();
	  interaction->KinePtr()->SetQ2(Q2tilde);
	
	//  std::cout << "Q2tilde = " << Q2tilde << std::endl;
	//  std::cout << "Q2 (not tilde)= " << -1 * qP4.Mag2() << std::endl;
	//  std::cout << "Q2 difference (tilde - not) = " << Q2tilde + qP4.Mag2() << std::endl;
	
	  // Calculate the QEL form factors
	  fFormFactors.Calculate(interaction);
	
	  double F1V   = fFormFactors.F1V();
	  double xiF2V = fFormFactors.xiF2V();
	  double FA    = fFormFactors.FA();
	  double Fp    = fFormFactors.Fp();
	//  std::cout << "Form factors! F1V = " << F1V << ", xiF2V = " << xiF2V << ", FA = " << FA << ", Fp = " << Fp << std::endl;
	
	  double Gfactor = kGF2*fCos8c2 / (8*kPi*kPi*inNucleonMom->E()*neutrinoMom->E()*outNucleonMom.E()*leptonMom.E());
	
	//  std::cout << "Gfactor = " << Gfactor << std::endl;
	  
	  // Now, we can calculate the cross section
	  double tau = Q2tilde / (4 * inNucleonMom->Mag2());
	  double h1 = FA*FA*(1 + tau) + tau*(F1V + xiF2V)*(F1V + xiF2V);
	  double h2 = FA*FA + F1V*F1V + tau*xiF2V*xiF2V;
	  double h3 = 2.0 * FA * (F1V + xiF2V);
	  double h4 = 0.25 * xiF2V*xiF2V *(1-tau) + 0.5*F1V*xiF2V + FA*Fp - tau*Fp*Fp;
	  
	//  std::cout << "tau = " << tau << ", h1 = " << h1 << ", h2 = " << h2 <<", h3 = " << h3 <<", h4 = " << h4 <<  std::endl;
	
	  bool is_neutrino = pdg::IsNeutrino(init_state.ProbePdg());
	  int sign = (is_neutrino) ? -1 : 1;
	  double l1 = 2*neutrinoMom->Dot(leptonMom)*(inNucleonMom->Mag2());
	  double l2 = 2*(neutrinoMom->Dot(*inNucleonMom)) * (inNucleonMom->Dot(leptonMom)) - neutrinoMom->Dot(leptonMom)*inNucleonMom->Mag2();
	  double l3 = (neutrinoMom->Dot(*inNucleonMom) * qTildeP4.Dot(leptonMom)) - (neutrinoMom->Dot(qTildeP4) * leptonMom.Dot(*inNucleonMom));
	  l3 *= sign;
	  double l4 = neutrinoMom->Dot(leptonMom) * qTildeP4.Dot(qTildeP4) - 2*neutrinoMom->Dot(qTildeP4)*leptonMom.Dot(qTildeP4);
	  double l5 = neutrinoMom->Dot(*inNucleonMom) * leptonMom.Dot(qTildeP4) + leptonMom.Dot(*inNucleonMom)*neutrinoMom->Dot(qTildeP4) - neutrinoMom->Dot(leptonMom)*inNucleonMom->Dot(qTildeP4);
	
	  double LH = 2 *(l1*h1 + l2*h2 + l3*h3 + l4*h4 + l5*h2);
	
	//  std::cout << "LH = " << LH << std::endl;
	  delete neutrinoMom;
	  
	  return Gfactor * LH;
	
	}


Masterclass/FastSimCherenkov.cxx


Masterclass/FastSimScintCalo.cxx


Masterclass/GNuMcMainFrame.cxx


Masterclass/MCTruthDisplay.cxx


MEC/MECGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	*/
	//____________________________________________________________________________
	
	#include <TMath.h>
	
	#include "Base/XSecAlgorithmI.h"
	#include "Conventions/Constants.h"
	#include "Conventions/Controls.h"
	#include "EVGCore/EVGThreadException.h"
	#include "EVGCore/RunningThreadInfo.h"
	#include "EVGCore/EventGeneratorI.h"
	#include "GHEP/GHepStatus.h"
	#include "GHEP/GHepFlags.h"
	#include "GHEP/GHepParticle.h"
	#include "GHEP/GHepRecord.h"
	#include "Messenger/Messenger.h"
	#include "MEC/MECGenerator.h"
	#include "Numerical/RandomGen.h"
	#include "Nuclear/NuclearModelI.h"
	#include "PDG/PDGCodes.h"
	#include "PDG/PDGUtils.h"
	#include "PDG/PDGLibrary.h"
	#include "Utils/KineUtils.h"
	#include "Utils/PrintUtils.h"
	
 @ Nov 20, 2015 - CA, SD  
   Add proper exception handling for failure of phase space decay.
*/
//____________________________________________________________________________

#include <TMath.h>

#include "Base/XSecAlgorithmI.h"
#include "Conventions/Constants.h"
#include "Conventions/Controls.h"
#include "EVGCore/EVGThreadException.h"
#include "EVGCore/RunningThreadInfo.h"
#include "EVGCore/EventGeneratorI.h"
#include "GHEP/GHepStatus.h"
#include "GHEP/GHepFlags.h"
#include "GHEP/GHepParticle.h"
#include "GHEP/GHepRecord.h"
#include "Messenger/Messenger.h"
#include "MEC/MECGenerator.h"
#include "Numerical/RandomGen.h"
#include "Nuclear/NuclearModelI.h"
#include "PDG/PDGCodes.h"
#include "PDG/PDGUtils.h"
#include "PDG/PDGLibrary.h"
#include "Utils/KineUtils.h"
#include "Utils/PrintUtils.h"

     event->EventFlags()->SetBitNumber(kHadroSysGenErr, true);
	     exception.SwitchOnFastForward();
     exception.SwitchOnStepBack();
     exception.SetReturnStep(0);
	  for(int i=0; i<200; i++) {
	     double w = fPhaseSpaceGenerator.Generate();   
  for(int idec=0; idec<200; idec++) {
     double w = fPhaseSpaceGenerator.Generate();   
       event->EventFlags()->SetBitNumber(kHadroSysGenErr, true);
	       exception.SwitchOnFastForward();
       exception.SwitchOnStepBack();
       exception.SetReturnStep(0);


MEC/MECInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


MEC/MECPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  double Tmu = (1.-y)*Ev;
	
	  // Calculate d^2xsec/dWdQ2 - first form factor which is common to both
  // double Tmu = (1.-y)*Ev;  // UNUSED - comment to quiet compiler warnings

  // Calculate d^2xsec/dWdQ2 - first form factor which is common to both


Messenger/Messenger.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


MuELoss/BetheBlochModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


MuELoss/BezrukovBugaevModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  double Vmax = 1. - 0.75*kSqrte* (kMuonMass/E) * TMath::Power(Z,1/3.);
	
  double Vmax = 1. - 0.75*kSqrtNapierConst* (kMuonMass/E) * TMath::Power(Z,1/3.);

  if (! (v >0)) return 0;
	  if (! v >0) return 0;
  if (   v >1)  return 0;
  if (! (fE>0)) return 0;

  double a    = kAem;
  double pi   = kPi;
  double mmu2 = kMuonMass2;
  double v2   = TMath::Power(v,2.);
  double t    = mmu2 *v2/(1-v);
  double k    = 1. - 2./v + 2./v2;
  double A13  = TMath::Power(fA,1./3.);
  double M1_2 = 0.54; // m1^2 in photonuclear diff. xsec formula (in GeV^2)
  double M2_2 = 1.80; // m2^2 in photonuclear diff. xsec formula (in GeV^2)
  double M1_2_t = M1_2 / t;
  double M2_2_t = M2_2 / t;
  double mmu2_t = mmu2 / t;
  double d      = M1_2 / (t + M1_2);

  // Calculate the cross section (in ub) for photonuclear interaction
  double Ep   = v*fE; // photon energy (GeV)
  double loge = TMath::Log(0.0213*Ep); // factor 0.0213 has units of GeV^-1
  double sig  = 114.3 + 1.647 * loge*loge; // in ub

  // Calculate the factor G (dimensionless) appearing in the differential
	  if (  v >1) return 0;
	  if (! fE>0) return 0;
	
	  double a    = kAem;
	  double pi   = kPi;
	  double mmu2 = kMuonMass2;
	  double v2   = TMath::Power(v,2.);
	  double t    = mmu2 *v2/(1-v);
	  double k    = 1. - 2./v + 2./v2;
	  double A13  = TMath::Power(fA,1./3.);
	  double M1_2 = 0.54; // m1^2 in photonuclear diff. xsec formula (in GeV^2)
	  double M2_2 = 1.80; // m2^2 in photonuclear diff. xsec formula (in GeV^2)
	  double M1_2_t = M1_2 / t;
	  double M2_2_t = M2_2 / t;
	  double mmu2_t = mmu2 / t;
	  double d      = M1_2 / (t + M1_2);
	
	  // Calculate the cross section (in ub) for photonuclear interaction
	  double Ep   = v*fE; // photon energy (GeV)
	  double loge = TMath::Log(0.0213*Ep); // factor 0.0213 has units of GeV^-1
	  double sig  = 114.3 + 1.647 * loge*loge; // in ub
	
	  // Calculate the factor G (dimensionless) appearing in the differential


MuELoss/KokoulinPetrukhinModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	////#include "Numerical/IntegratorI.h"
	  double Vmax = 1. - 0.75*kSqrte* (kMuonMass/E) * TMath::Power(Z,1/3.);
	
	  // claculate the limits of the asymmetry parameter of the e+e- pair
  double Vmax = 1. - 0.75*kSqrtNapierConst* (kMuonMass/E) * TMath::Power(Z,1/3.);

  // claculate the limits of the asymmetry parameter of the e+e- pair
  if (! (v >0)) return 0;
	  if (! v >0) return 0;
  if (   v >1)  return 0;
  if (! (fE>0)) return 0;

  double pmax_v = (1. - 6.*kMuonMass2 / (fE*fE*(1.-v)) ) * 
	  if (  v >1) return 0;
	  if (! fE>0) return 0;
	
	  double pmax_v = (1. - 6.*kMuonMass2 / (fE*fE*(1.-v)) ) * 
	  double LmB  = 1. + (2.*me*R * kSqrte * Zm13 * (1+xi) * (1+Ym)) / (fE*v*(1-p2) );
  double LmB  = 1. + (2.*me*R * kSqrtNapierConst * Zm13 * (1+xi) * (1+Ym)) / (fE*v*(1-p2) );
	  double LeB  = 1. + (2.*me*R*kSqrte*Zm13*x_Y) / (fE*v*(1-p2));
  double LeB  = 1. + (2.*me*R*kSqrtNapierConst*Zm13*x_Y) / (fE*v*(1-p2));


MuELoss/MuELossI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


MuELoss/PetrukhinShestakovModel.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	////#include "Numerical/IntegratorI.h"
	  double Vmax = 1. - 0.75*kSqrte* (kMuonMass/E) * TMath::Power(Z,1/3.);
	
  double Vmax = 1. - 0.75*kSqrtNapierConst* (kMuonMass/E) * TMath::Power(Z,1/3.);

gsl::PetrukhinShestakovIntegrand::PetrukhinShestakovIntegrand(double E, double Z) :
ROOT::Math::IBaseFunctionOneDim()
{
  fE = E;
  fZ = Z;
}
//____________________________________________________________________________
gsl::PetrukhinShestakovIntegrand::~PetrukhinShestakovIntegrand()
{

}
//____________________________________________________________________________
unsigned int gsl::PetrukhinShestakovIntegrand::NDim(void) const
{
  return 1;
}
//____________________________________________________________________________
double gsl::PetrukhinShestakovIntegrand::DoEval(double xin) const
{
// Calculate the Bethe-Heitler cross section ds/dv for muon bremsstrahlung
// Returns v*(ds/dv)

  double v  = xin; // v, the fraction of energy transfered to the photon
  double v2 = TMath::Power(v,2.);

  if (! (v >0)) return 0;
  if (   v >1)  return 0;
  if (! (fE>0)) return 0;

  // Some constants...
  double Z2    = TMath::Power(fZ,2.);
  double Zm13  = TMath::Power(fZ,-1./3.);
  double Zm23  = TMath::Power(fZ,-2./3.);
  double a3    = TMath::Power(kAem,3.); // (e/m coupling const)^3
  double me    = kElectronMass;
  double mmu   = kMuonMass;
  double mmu2  = kMuonMass2;
  double mmue  = mmu/me;
  double memu  = me/mmu;
  double memu2 = TMath::Power(memu,2);

  // Calculate the minimum monentum transfer to the nucleus (in GeV)
  double delta = (mmu2/fE) * 0.5*v/(1.-v);

  // Calculate the fi(delta) factor for the bremsstrahlung cross section
  // ds/dv according to the Petrukhin/Shestakov formula (dimensionless)
  double a  = ( (fZ<10) ? 189.*mmue * Zm13 : 189.*mmue * (2./3.)*Zm23 );
  double b  = 1. + (189./me) * Zm13 * kSqrtNapierConst * delta;
  double fi = TMath::Log(a/b);

  // Calculate the Bethe-Heitler cross section ds/dv for muon bremsstrahlung
  double ds_dv  = (a3*memu2*kLe2) * (4*Z2) * (fi) * (4/3.-4*v/3.+v2)/v;
  double vds_dv = v*ds_dv;
  return vds_dv; // in GeV^-2
}
//____________________________________________________________________________
ROOT::Math::IBaseFunctionOneDim *
  gsl::PetrukhinShestakovIntegrand::Clone(void) const
{ 
  return new gsl::PetrukhinShestakovIntegrand(fE, fZ);
}
//____________________________________________________________________________

	//void PetrukhinShestakovModel::Configure(const Registry & config)
	//{
	//  Algorithm::Configure(config);
	//  this->LoadConfig();
	//}
	////____________________________________________________________________________
	//void PetrukhinShestakovModel::Configure(string config)
	//{
	//  Algorithm::Configure(config);
	//  this->LoadConfig();
	//}
	////____________________________________________________________________________
	//void PetrukhinShestakovModel::LoadConfig(void)
	//{
	////  fIntegrator = dynamic_cast<const IntegratorI *>(this->SubAlg("Integrator"));
	////  assert(fIntegrator);
	//}
	//____________________________________________________________________________
	gsl::PetrukhinShestakovIntegrand::PetrukhinShestakovIntegrand(double E, double Z) :
	ROOT::Math::IBaseFunctionOneDim()
	{
	  fE = E;
	  fZ = Z;
	}
	//____________________________________________________________________________
	gsl::PetrukhinShestakovIntegrand::~PetrukhinShestakovIntegrand()
	{
	
	}
	//____________________________________________________________________________
	unsigned int gsl::PetrukhinShestakovIntegrand::NDim(void) const
	{
	  return 1;
	}
	//____________________________________________________________________________
	double gsl::PetrukhinShestakovIntegrand::DoEval(double xin) const
	{
	// Calculate the Bethe-Heitler cross section ds/dv for muon bremsstrahlung
	// Returns v*(ds/dv)
	
	  double v  = xin; // v, the fraction of energy transfered to the photon
	  double v2 = TMath::Power(v,2.);
	
	  if (! v >0) return 0;
	  if (  v >1) return 0;
	  if (! fE>0) return 0;
	
	  // Some constants...
	  double Z2    = TMath::Power(fZ,2.);
	  double Zm13  = TMath::Power(fZ,-1./3.);
	  double Zm23  = TMath::Power(fZ,-2./3.);
	  double a3    = TMath::Power(kAem,3.); // (e/m coupling const)^3
	  double me    = kElectronMass;
	  double mmu   = kMuonMass;
	  double mmu2  = kMuonMass2;
	  double mmue  = mmu/me;
	  double memu  = me/mmu;
	  double memu2 = TMath::Power(memu,2);
	
	  // Calculate the minimum monentum transfer to the nucleus (in GeV)
	  double delta = (mmu2/fE) * 0.5*v/(1.-v);
	
	  // Calculate the fi(delta) factor for the bremsstrahlung cross section
	  // ds/dv according to the Petrukhin/Shestakov formula (dimensionless)
	  double a  = ( (fZ<10) ? 189.*mmue * Zm13 : 189.*mmue * (2./3.)*Zm23 );
	  double b  = 1. + (189./me) * Zm13 * kSqrte * delta;
	  double fi = TMath::Log(a/b);
	
	  // Calculate the Bethe-Heitler cross section ds/dv for muon bremsstrahlung
	  double ds_dv  = (a3*memu2*kLe2) * (4*Z2) * (fi) * (4/3.-4*v/3.+v2)/v;
	  double vds_dv = v*ds_dv;
	  return vds_dv; // in GeV^-2
	}
	//____________________________________________________________________________
	ROOT::Math::IBaseFunctionOneDim *
	  gsl::PetrukhinShestakovIntegrand::Clone(void) const
	{ 
	  return new gsl::PetrukhinShestakovIntegrand(fE, fZ);
	}
	//____________________________________________________________________________
	


Ntuple/NtpMCDTime.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCEventRecord.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCJobConfig.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCJobEnv.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCRecHeader.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCRecordI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpMCTreeHeader.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Ntuple/NtpWriter.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/EffectiveSF.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	// Returns the probability of the bin containing p.  I don't know what w is
// Returns the probability of the bin with given momentum. I don't know what w 
// is supposed to be, but I copied its implementation from Bodek-Ritchie.
// Implements the interface.
//____________________________________________________________________________
double EffectiveSF::Prob(double mom, double w, const Target & target) const
{
  if(w < 0) {
	// supposed to be, but I copied its implementation from Bodek-Ritchie.
	// Implements the interface.
	//____________________________________________________________________________
	double EffectiveSF::Prob(double p, double w, const Target & target) const
	{
	  if(w < 0) {
     TH1D * prob_distr = this->ProbDistro(target);
     int bin = prob_distr->FindBin(mom);
     double y  = prob_distr->GetBinContent(bin);
     double dx = prob_distr->GetBinWidth(bin);
     double prob  = y * dx;
     return prob;
  }
  return 1;
}
//____________________________________________________________________________
// Check the map of nucleons to see if we have a probability distribution to
// compute with.  If not, make one.
//____________________________________________________________________________
TH1D * EffectiveSF::ProbDistro(const Target & target) const
{
  //-- return stored /if already computed/
  map<string, TH1D*>::iterator it = fProbDistroMap.find(target.AsString());
  if(it != fProbDistroMap.end()) return it->second;

  LOG("EffectiveSF", pNOTICE)
             << "Computing P = f(p_nucleon) for: " << target.AsString();
  LOG("EffectiveSF", pNOTICE)
               << "P(cut-off) = " << fPCutOff << ", P(max) = " << fPMax;

  //-- get information for the nuclear target
  int nucleon_pdgc = target.HitNucPdg();
  assert( pdg::IsProton(nucleon_pdgc) || pdg::IsNeutron(nucleon_pdgc) );
  return this->MakeEffectiveSF(target);
	
}
//____________________________________________________________________________
// If transverse enhancement form factor modification is enabled, we must
// increase the 2p2h contribution to account for the QE peak enhancement.
	     TH1D * prob = this->ProbDistro(target);
	     int bin = prob->FindBin(p);
	     double y  = prob->GetBinContent(bin);
	     double dx = prob->GetBinWidth(bin);
	     double p  = y * dx;
	     return p;
	  }
	  return 1;
	}
	//____________________________________________________________________________
	// Check the map of nucleons to see if we have a probability distribution to
	// compute with.  If not, make one.
	//____________________________________________________________________________
	TH1D * EffectiveSF::ProbDistro(const Target & target) const
	{
	  //-- return stored /if already computed/
	  map<string, TH1D*>::iterator it = fProbDistroMap.find(target.AsString());
	  if(it != fProbDistroMap.end()) return it->second;
	
	  LOG("EffectiveSF", pNOTICE)
	             << "Computing P = f(p_nucleon) for: " << target.AsString();
	  LOG("EffectiveSF", pNOTICE)
	               << "P(cut-off) = " << fPCutOff << ", P(max) = " << fPMax;
	
	  //-- get information for the nuclear target
	  int nucleon_pdgc = target.HitNucPdg();
	  assert( pdg::IsProton(nucleon_pdgc) || pdg::IsNeutron(nucleon_pdgc) );
	  return this->MakeEffectiveSF(target);
		
	}
	//____________________________________________________________________________
	// If transverse enhancement form factor modification is enabled, we must
	// increase the 2p2h contribution to account for the QE peak enhancement.


Nuclear/FermiMomentumTable.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/FermiMomentumTablePool.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/FGMBodekRitchie.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
double FGMBodekRitchie::Prob(double mom, double w, const Target & target) const
{
	double FGMBodekRitchie::Prob(double p, double w, const Target & target) const
	{
     TH1D * prob_distr = this->ProbDistro(target);
     int bin = prob_distr->FindBin(mom);
     double y  = prob_distr->GetBinContent(bin);
     double dx = prob_distr->GetBinWidth(bin);
     double prob = y*dx;
     return prob;
  }
  return 1;
}
//____________________________________________________________________________
TH1D * FGMBodekRitchie::ProbDistro(const Target & target) const
{
  //-- return stored /if already computed/
  map<string, TH1D*>::iterator it = fProbDistroMap.find(target.AsString());
  if(it != fProbDistroMap.end()) return it->second;

  LOG("BodekRitchie", pNOTICE)
             << "Computing P = f(p_nucleon) for: " << target.AsString();
  LOG("BodekRitchie", pNOTICE)
               << "P(cut-off) = " << fPCutOff << ", P(max) = " << fPMax;

  //-- get information for the nuclear target
  int target_pdgc  = pdg::IonPdgCode(target.A(), target.Z());
  int nucleon_pdgc = target.HitNucPdg();
  assert( pdg::IsProton(nucleon_pdgc) || pdg::IsNeutron(nucleon_pdgc) );
  double Z = (double) target.Z();
  double N = (double) target.N();
  double A = (double) target.A();

  //-- look up the Fermi momentum for this Target
  FermiMomentumTablePool * kftp = FermiMomentumTablePool::Instance();
  const FermiMomentumTable * kft  = kftp->GetTable(fKFTable);
  double KF = kft->FindClosestKF(target_pdgc, nucleon_pdgc);
  LOG("BodekRitchie", pNOTICE) << "KF = " << KF;

  //-- correct the Fermi momentum for the struck nucleon
  assert(target.HitNucIsSet());
  bool is_p = pdg::IsProton(nucleon_pdgc);
  if(is_p) KF *= TMath::Power( 2*Z/A, 1./3.);
  else     KF *= TMath::Power( 2*N/A, 1./3.);
  LOG("BodekRitchie", pINFO) << "Corrected KF = " << KF;

  double a  = 2.0;
  double C  = 4. * kPi * TMath::Power(KF,3) / 3.;
  double R  = 1. / (1.- KF/4.);
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
  LOG("BodekRitchie", pDEBUG) << "a  = " << a;
  LOG("BodekRitchie", pDEBUG) << "C  = " << C;
  LOG("BodekRitchie", pDEBUG) << "R  = " << R;
#endif

  //-- create the probability distribution

  int npbins = (int) (1000*fPMax);
  TH1D * prob = new TH1D("", "", npbins, 0, fPMax);
  prob->SetDirectory(0);

  double dp = fPMax / (npbins-1);
  double iC = (C>0) ? 1./C : 0.;
  double kfa_pi_2 = TMath::Power(KF*a/kPi,2);

  for(int i = 0; i < npbins; i++) {
     double p  = i * dp;
     double p2 = TMath::Power(p,2);

     // calculate |phi(p)|^2
     double phi2 = 0;
     if (p <= KF)
        phi2 = iC * (1. - 6.*kfa_pi_2);
     else if ( p > KF && p < fPCutOff)
        phi2 = iC * (2*R*kfa_pi_2*TMath::Power(KF/p,4.));

     // calculate probability density : dProbability/dp
     double dP_dp = 4*kPi * p2 * phi2;
#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
     LOG("BodekRitchie", pDEBUG) << "p = " << p << ", dP/dp = " << dP_dp;
#endif
     prob->Fill(p, dP_dp);
  }

  //-- normalize the probability distribution
  prob->Scale( 1.0 / prob->Integral("width") );

  //-- store
  fProbDistroMap.insert(
      map<string, TH1D*>::value_type(target.AsString(),prob));

  return prob; 
}
//____________________________________________________________________________
	     TH1D * prob = this->ProbDistro(target);
	     int bin = prob->FindBin(p);
	     double y  = prob->GetBinContent(bin);
	     double dx = prob->GetBinWidth(bin);
	     double p  = y*dx;
	     return p;
	  }
	  return 1;
	}
	//____________________________________________________________________________
	TH1D * FGMBodekRitchie::ProbDistro(const Target & target) const
	{
	  //-- return stored /if already computed/
	  map<string, TH1D*>::iterator it = fProbDistroMap.find(target.AsString());
	  if(it != fProbDistroMap.end()) return it->second;
	
	  LOG("BodekRitchie", pNOTICE)
	             << "Computing P = f(p_nucleon) for: " << target.AsString();
	  LOG("BodekRitchie", pNOTICE)
	               << "P(cut-off) = " << fPCutOff << ", P(max) = " << fPMax;
	
	  //-- get information for the nuclear target
	  int target_pdgc  = pdg::IonPdgCode(target.A(), target.Z());
	  int nucleon_pdgc = target.HitNucPdg();
	  assert( pdg::IsProton(nucleon_pdgc) || pdg::IsNeutron(nucleon_pdgc) );
	  double Z = (double) target.Z();
	  double N = (double) target.N();
	  double A = (double) target.A();
	
	  //-- look up the Fermi momentum for this Target
	  FermiMomentumTablePool * kftp = FermiMomentumTablePool::Instance();
	  const FermiMomentumTable * kft  = kftp->GetTable(fKFTable);
	  double KF = kft->FindClosestKF(target_pdgc, nucleon_pdgc);
	  LOG("BodekRitchie", pNOTICE) << "KF = " << KF;
	
	  //-- correct the Fermi momentum for the struck nucleon
	  assert(target.HitNucIsSet());
	  bool is_p = pdg::IsProton(nucleon_pdgc);
	  if(is_p) KF *= TMath::Power( 2*Z/A, 1./3.);
	  else     KF *= TMath::Power( 2*N/A, 1./3.);
	  LOG("BodekRitchie", pINFO) << "Corrected KF = " << KF;
	
	  double a  = 2.0;
	  double C  = 4. * kPi * TMath::Power(KF,3) / 3.;
	  double R  = 1. / (1.- KF/4.);
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("BodekRitchie", pDEBUG) << "a  = " << a;
	  LOG("BodekRitchie", pDEBUG) << "C  = " << C;
	  LOG("BodekRitchie", pDEBUG) << "R  = " << R;
	#endif
	
	  //-- create the probability distribution
	
	  int npbins = (int) (1000*fPMax);
	  TH1D * prob = new TH1D("", "", npbins, 0, fPMax);
	  prob->SetDirectory(0);
	
	  double dp = fPMax / (npbins-1);
	  double iC = (C>0) ? 1./C : 0.;
	  double kfa_pi_2 = TMath::Power(KF*a/kPi,2);
	
	  for(int i = 0; i < npbins; i++) {
	     double p  = i * dp;
	     double p2 = TMath::Power(p,2);
	
	     // calculate |phi(p)|^2
	     double phi2 = 0;
	     if (p <= KF)
	        phi2 = iC * (1. - 6.*kfa_pi_2);
	     else if ( p > KF && p < fPCutOff)
	        phi2 = iC * (2*R*kfa_pi_2*TMath::Power(KF/p,4.));
	
	     // calculate probability density : dProbability/dp
	     double dP_dp = 4*kPi * p2 * phi2;
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	     LOG("BodekRitchie", pDEBUG) << "p = " << p << ", dP/dp = " << dP_dp;
	#endif
	     prob->Fill(p, dP_dp);
	  }
	
	  //-- normalize the probability distribution
	  prob->Scale( 1.0 / prob->Integral("width") );
	
	  //-- store
	  fProbDistroMap.insert(
	      map<string, TH1D*>::value_type(target.AsString(),prob));
	
	  return prob; 
	}
	//____________________________________________________________________________


Nuclear/NuclearData.cxx


Nuclear/NuclearModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/NuclearModelMap.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/SpectralFunc1d.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Nuclear/SpectralFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	    fFermiMoverInteractionType = kFermiMoveBenharSF;
	
	  std::cerr << data_dir << std::endl;


NucleonDecay/DummyInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NucleonDecay/DummyPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NucleonDecay/NucleonDecayPrimaryVtxGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	  for(int i=0; i<200; i++) {
	     double w = fPhaseSpaceGenerator.Generate();   
  for(int idec=0; idec<200; idec++) {
     double w = fPhaseSpaceGenerator.Generate();   


NucleonDecay/NucleonDecayUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/BardinIMDRadCorPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/IMDAnnihilationPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/NuEInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/NuEKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/NuElectronPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/NuEPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuE/NuETargetRemnantGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuGamma/AMNuGammaGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuGamma/AMNuGammaInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


NuGamma/H3AMNuGammaPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Numerical/BLI2D.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
#include <limits>

  fZmax = TMath::Max(z, fZmax);

	  fZmax = TMath::Min(z, fZmax);
	
	  fZmin = 0.;
	  fZmax = 0.;
	  fDX   = 0.;
	  fDY   = 0.;
	  fX    = 0;
	  fY    = 0;
	  fZ    = 0;
	
  fZmin = std::numeric_limits<double>::max();
  fZmax = std::numeric_limits<double>::min();
  fDX   = 0.;
  fDY   = 0.;
  fX    = 0;
  fY    = 0;
  fZ    = 0;

	    fZmin = 0.;
	    fZmax = 0.;
	
	    fDX = (xmax-xmin)/(nx-1);
	    fDY = (ymax-ymin)/(ny-1);
	
	    fX = new double[fNX];
	    fY = new double[fNY];
    fZmin = std::numeric_limits<double>::max();
    fZmax = std::numeric_limits<double>::min();

    fDX = (xmax-xmin)/(nx-1);
    fDY = (ymax-ymin)/(ny-1);

    fX = new double[fNX];
    fY = new double[fNY];
  fZmax = TMath::Max(z, fZmax);

	  fZmax = TMath::Min(z, fZmax);
	
	  fZmin  = 0.;
	  fZmax  = 0.;
	  fX     = 0;
	  fY     = 0;
	  fZ     = 0;
	
  fZmin  = std::numeric_limits<double>::max();
  fZmax  = std::numeric_limits<double>::min(); 
  fX     = 0;
  fY     = 0;
  fZ     = 0;

	    fZmin = 0.;
	    fZmax = 0.;
	
	    fX = new double[fNX];
	    fY = new double[fNY];
    fZmin = std::numeric_limits<double>::max();
    fZmax = std::numeric_limits<double>::min();

    fX = new double[fNX];
    fY = new double[fNY];


Numerical/GFunc.cxx


Numerical/RandomGen.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Numerical/Spline.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	using namespace genie;
	
	ClassImp(Spline)
	
	//___________________________________________________________________________
	namespace genie
	{
	  ostream & operator << (ostream & stream, const Spline & spl)
	  {
	     spl.Print(stream);
	     return stream;
	  }
	}
	//___________________________________________________________________________
	Spline::Spline()
	{
	  this->InitSpline();
	}
	//___________________________________________________________________________
	Spline::Spline(string filename, string xtag, string ytag, bool is_xml) :
	TObject()
	{
	  string fmt = (is_xml) ? "XML" : "ASCII";
	
	  LOG("Spline", pDEBUG)
	      << "Constructing spline from data in " << fmt << " file: " << filename;
	
	  this->InitSpline();
	
	  if(is_xml)
	     this->LoadFromXmlFile(filename, xtag, ytag);
	  else
	     this->LoadFromAsciiFile(filename);
	}
	//___________________________________________________________________________
	Spline::Spline(TNtupleD * ntuple, string var, string cut) :
	TObject()
	{
	  LOG("Spline", pDEBUG) << "Constructing spline from data in a TNtuple";
	
	  this->InitSpline();
	  this->LoadFromNtuple(ntuple, var, cut);
	}
	//___________________________________________________________________________
	Spline::Spline(TTree * tree, string var, string cut) :
	TObject()
	{
	  LOG("Spline", pDEBUG) << "Constructing spline from data in a TTree";
	
	  this->InitSpline();
	  this->LoadFromTree(tree, var, cut);
	}
	//___________________________________________________________________________
	Spline::Spline(TSQLServer * db, string query) :
	TObject()
	{
	  LOG("Spline", pDEBUG) << "Constructing spline from data in a MySQL server";
	
	  this->InitSpline();
	  this->LoadFromDBase(db, query);
	}
	//___________________________________________________________________________
	Spline::Spline(int nentries, double x[], double y[]) :
	TObject()
	{
	  LOG("Spline", pDEBUG)
	                 << "Constructing spline from the arrays passed to the ctor";
	
	  this->InitSpline();
	  this->BuildSpline(nentries, x, y);
	}
	//___________________________________________________________________________
	Spline::Spline(int nentries, float x[], float y[]) :
	TObject()
	{
	  LOG("Spline", pDEBUG)
	                 << "Constructing spline from the arrays passed to the ctor";
	
	  double * dblx = new double[nentries];
	  double * dbly = new double[nentries];
	
	  for(int i = 0; i < nentries; i++) {
	     dblx[i] = double( x[i] );
	     dbly[i] = double( y[i] );
	  }
	
	  this->InitSpline();
	  this->BuildSpline(nentries, dblx, dbly);
	
	  delete [] x;
	  delete [] y;
	}
	//___________________________________________________________________________
	Spline::Spline(const Spline & spline) :
	  TObject(), fInterpolator(0)
	{
	  LOG("Spline", pDEBUG) << "Spline copy constructor";
	
	  this->LoadFromTSpline3( *spline.GetAsTSpline(), spline.NKnots() );
	}
	//___________________________________________________________________________
	Spline::Spline(const TSpline3 & spline, int nknots) :
	  TObject(), fInterpolator(0)
	{
	  LOG("Spline", pDEBUG)
	                    << "Constructing spline from the input TSpline3 object";
	
	  this->LoadFromTSpline3( spline, nknots );
	}
	//___________________________________________________________________________
	Spline::~Spline()
	{
	  if(fInterpolator) delete fInterpolator;
	}
	//___________________________________________________________________________
	bool Spline::LoadFromXmlFile(string filename, string xtag, string ytag)
	{
	  LOG("Spline", pDEBUG) << "Retrieving data from file: " << filename;
	
using std::setiosflags;

using namespace genie;

ClassImp(Spline)

//___________________________________________________________________________
namespace genie
{
  ostream & operator << (ostream & stream, const Spline & spl)
  {
     spl.Print(stream);
     return stream;
  }
}
//___________________________________________________________________________
Spline::Spline()
{
  this->InitSpline();
}
//___________________________________________________________________________
Spline::Spline(string filename, string xtag, string ytag, bool is_xml) :
TObject()
{
  string fmt = (is_xml) ? "XML" : "ASCII";

  LOG("Spline", pDEBUG)
      << "Constructing spline from data in " << fmt << " file: " << filename;

  this->InitSpline();

  if(is_xml)
     this->LoadFromXmlFile(filename, xtag, ytag);
  else
     this->LoadFromAsciiFile(filename);
}
//___________________________________________________________________________
Spline::Spline(TNtupleD * ntuple, string var, string cut) :
TObject()
{
  LOG("Spline", pDEBUG) << "Constructing spline from data in a TNtuple";

  this->InitSpline();
  this->LoadFromNtuple(ntuple, var, cut);
}
//___________________________________________________________________________
Spline::Spline(TTree * tree, string var, string cut) :
TObject()
{
  LOG("Spline", pDEBUG) << "Constructing spline from data in a TTree";

  this->InitSpline();
  this->LoadFromTree(tree, var, cut);
}
//___________________________________________________________________________
Spline::Spline(TSQLServer * db, string query) :
TObject()
{
  LOG("Spline", pDEBUG) << "Constructing spline from data in a MySQL server";

  this->InitSpline();
  this->LoadFromDBase(db, query);
}
//___________________________________________________________________________
Spline::Spline(int nentries, double x[], double y[]) :
TObject()
{
  LOG("Spline", pDEBUG)
                 << "Constructing spline from the arrays passed to the ctor";

  this->InitSpline();
  this->BuildSpline(nentries, x, y);
}
//___________________________________________________________________________
Spline::Spline(int nentries, float x[], float y[]) :
TObject()
{
  LOG("Spline", pDEBUG)
                 << "Constructing spline from the arrays passed to the ctor";

  double * dblx = new double[nentries];
  double * dbly = new double[nentries];

  for(int i = 0; i < nentries; i++) {
     dblx[i] = double( x[i] );
     dbly[i] = double( y[i] );
  }

  this->InitSpline();
  this->BuildSpline(nentries, dblx, dbly);

  delete [] x;
  delete [] y;
}
//___________________________________________________________________________
Spline::Spline(const Spline & spline) :
  TObject(), fInterpolator(0)
{
  LOG("Spline", pDEBUG) << "Spline copy constructor";

  this->LoadFromTSpline3( *spline.GetAsTSpline(), spline.NKnots() );
}
//___________________________________________________________________________
Spline::Spline(const TSpline3 & spline, int nknots) :
  TObject(), fInterpolator(0)
{
  LOG("Spline", pDEBUG)
                    << "Constructing spline from the input TSpline3 object";

  this->LoadFromTSpline3( spline, nknots );
}
//___________________________________________________________________________
Spline::~Spline()
{
  if(fInterpolator) delete fInterpolator;
}
//___________________________________________________________________________
bool Spline::LoadFromXmlFile(string filename, string xtag, string ytag)
{
  LOG("Spline", pDEBUG) << "Retrieving data from file: " << filename;



PartonModel/QPMDISPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PartonModel/QPMDISStrucFuncBase.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PartonModel/QPMDISStrucFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Paschos/P33PaschosLalakulichPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PDF/PDF.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PDF/PDFLIB.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	    if(!gSystem->OpenDirectory(lhapath)) lhapath_ok = false;
	  }
	  if(!lhapath_ok) {
	   LOG("PDF", pFATAL) 
	     << "\n"
	     << "** LHAPDF won't be able to read-in the PDF data. \n"
	     << "** The LHAPATH env. variable is not properly (or at all) defined. \n"
	     << "** Please, set LHAPATH to <lhapdf_top_dir>/PDFsets/ \n"
	     << "** See http://projects.hepforge.org/lhapdf/ for more details. \n\n";
	   gAbortingInErr = true;
	   exit(1);
	  }
	
	#else
	  //
	  // PDFLIB
	  //
	  char   param[20][20];
	  double val[20];
	  strcpy(param[0], "Init0");
	  pdfset_(param, val); // call pdfset from the fortran PDFLIB library
	
	#endif
	}
	//____________________________________________________________________________
      void *dirp = gSystem->OpenDirectory(lhapath);
      if (dirp) gSystem->FreeDirectory(dirp);
      else lhapath_ok = false;
  }
  if(!lhapath_ok) {
   LOG("PDF", pFATAL) 
     << "\n"
     << "** LHAPDF won't be able to read-in the PDF data. \n"
     << "** The LHAPATH env. variable is not properly (or at all) defined. \n"
     << "** Please, set LHAPATH to <lhapdf_top_dir>/PDFsets/ \n"
     << "** See http://projects.hepforge.org/lhapdf/ for more details. \n\n";
   gAbortingInErr = true;
   exit(1);
  }

#else
  //
  // PDFLIB
  //
  char   param[20][20];
  double val[20];
  strcpy(param[0], "Init0");
  pdfset_(param, val); // call pdfset from the fortran PDFLIB library

#endif
}
//____________________________________________________________________________


PDF/PDFModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PDG/PDGCodeList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


PDG/PDGLibrary.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
  const char* altpdgtable = gSystem->Getenv("GENIE_PDG_TABLE");
  if ( altpdgtable ) {
    if ( ! (gSystem->AccessPathName(altpdgtable) ) ) {
	  if(gSystem->Getenv("GENIE")) {
        LOG("PDG", pINFO) << "Load PDG data from $GENIE_PDG_TABLE: "
                          << altpdgtable;
        fDatabasePDG->ReadPDGTable( altpdgtable );
        return true;
    } 
  }

  if ( gSystem->Getenv("GENIE") ) {
    string path = base_dir + 
      string("/data/evgen/catalogues/pdg/genie_pdg_table.txt");

    if ( ! (gSystem->AccessPathName(path.c_str()) ) ) {
        LOG("PDG", pINFO) << "Load PDG data from: " << path;
        fDatabasePDG->ReadPDGTable( path.c_str() );
        return true;
    } 
  }

  // no PDG data in $GENIE/config/ - Try $ROOTSYS/etc/

  if(gSystem->Getenv("ROOTSYS")) {
    string base_dir  = string( gSystem->Getenv("ROOTSYS") );
	    string path = base_dir + string("/data/evgen/catalogues/pdg/genie_pdg_table.txt");
	
	    if ( ! (gSystem->AccessPathName(path.c_str()) ) ) {
	        LOG("PDG", pINFO) << "Load PDG data from: " << path;
	        fDatabasePDG->ReadPDGTable( path.c_str() );
	        return true;
	    } 
	  }
	
	  // no PDG data in $GENIE/config/ - Try $ROOTSYS/etc/
	
	  if(gSystem->Getenv("ROOTSYS")) {
	    string base_dir  = string( gSystem->Getenv("ROOTSYS") );


PDG/PDGUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


QEL/QELHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


QEL/QELInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  if (fIsCC && !fIsCharm && !fIsStrange) 
	  if (fIsEM) 
     return this->CreateInteractionListCC(init_state);
  else 
  if (fIsNC && !fIsCharm && !fIsStrange) 
	     return this->CreateInteractionListEM(init_state);
	  else 
	  if (fIsCC && !fIsCharm && !fIsStrange) 
	     return this->CreateInteractionListCC(init_state);
	  else 
	  if (fIsNC && !fIsCharm && !fIsStrange) 
	  if (fIsCC &&  fIsCharm) 
  if (fIsEM) 
	     return this->CreateInteractionListCharmCC(init_state);
	  else 
	  if (fIsCC &&  fIsStrange) 
     return this->CreateInteractionListEM(init_state);
  else 
  if (fIsCC &&  fIsCharm) 
     return this->CreateInteractionListCharmCC(init_state);
  else 
  if (fIsCC &&  fIsStrange) 


QEL/QELKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


QEL/QELPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Registry/Registry.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
void Registry::Get(RgKey key, const RegistryItemI * & item) const
{
  RgIMapConstIter entry = fRegistry.find(key);
  item = entry->second;
}
//____________________________________________________________________________
	void Registry::Get(RgKey key, const RegistryItemI * item) const
	{
	  RgIMapConstIter entry = fRegistry.find(key);
	  item = entry->second;
	}
	//____________________________________________________________________________


Registry/RegistryItem.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Registry/RegistryItemTypeDef.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/BergerSehgalRESPXSec2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
*/
//____________________________________________________________________________

	 Author: Costas Andreopoulos <costas.andreopoulos \at stfc.ac.uk>
#include "ReinSehgal/BergerSehgalRESPXSec2014.h"

	         University of Liverpool & STFC Rutherford Appleton Lab 
	
	 For the class documentation see the corresponding header file.
	
	 Important revisions after version 2.0.0 :
	
	 @ Oct 05, 2009 - CA
	   Modified code to handle charged lepton scattering too.
	   Also, the helicity amplitude code now returns a `const RSHelicityAmpl &'.
	 @ July 23, 2010 - CA
	   BaryonResParams, and BreitWignerI, BaryonResDataSetI implementations are
	   now redundant. Get resonance parameters from BaryonResUtils and use the
	   Breit-Weigner functions from utils::bwfunc.
	 @ December 15, 2014 - JN, SD
	   Add new version due to Jarek Nowak.  Based on parameters set in
	   UserPhysicsOptions.xml.  Default is Berger-Sehgal (Phys. Rev. D76, 
	   113004 (2007)) with new GA and new GV.  Additional model due to Kuzmin, 
	   Lyubushkin, and Naumov (Mod. Phys. Lett. A19 (2004) 2815 and Phys. Part. 
	   Nucl. 35 (2004) S133) also available.  Each of these models
	   includes effect of lepton mass.  BS adds a new pole diagram.  
	   New GA and GV form factors are based on studies with MiniBooNE data.
	 @ Dec 22, 2014 - GP
	   Incorporating changes from J. Nowak into a new class (was 
	   ReinSehgalRESPXSec, now BergerSehgalRESPXSec2014).
	*/
	//____________________________________________________________________________
	
	#include <TMath.h>
	#include <TSystem.h>
	
	#include "Algorithm/AlgFactory.h"
	#include "Algorithm/AlgConfigPool.h"
	#include "Base/XSecIntegratorI.h"
	#include "BaryonResonance/BaryonResUtils.h"
	#include "Conventions/GBuild.h"
	#include "Conventions/Constants.h"
	#include "Conventions/RefFrame.h"
	#include "Conventions/KineVar.h"
	#include "Conventions/Units.h"
	#include "Messenger/Messenger.h"
	#include "Numerical/Spline.h"
	#include "PDG/PDGCodes.h"
	#include "PDG/PDGUtils.h"
	#include "ReinSehgal/BergerSehgalRESPXSec2014.h"
	#include "ReinSehgal/RSHelicityAmplModelI.h"
	#include "ReinSehgal/RSHelicityAmpl.h"
	#include "Utils/KineUtils.h"
	#include "Utils/MathUtils.h"
	#include "Utils/Range1.h"
	#include "Utils/BWFunc.h"
	

//____________________________________________________________________________
BergerSehgalRESPXSec2014::BergerSehgalRESPXSec2014() :
BSKLNBaseRESPXSec2014("genie::BergerSehgalRESPXSec2014")
{
  this->fKLN = false;
  this->fBRS = true;
}
//____________________________________________________________________________
BergerSehgalRESPXSec2014::BergerSehgalRESPXSec2014(string config) :
BSKLNBaseRESPXSec2014("genie::BergerSehgalRESPXSec2014", config)
{
  this->fKLN = false;
  this->fBRS = true;
}
//____________________________________________________________________________
BergerSehgalRESPXSec2014::~BergerSehgalRESPXSec2014()
{

}
//____________________________________________________________________________
	using namespace genie::constants;
	
	//____________________________________________________________________________
	BergerSehgalRESPXSec2014::BergerSehgalRESPXSec2014() :
	  XSecAlgorithmI("genie::BergerSehgalRESPXSec2014")
	{
	  fNuTauRdSpl    = 0;
	  fNuTauBarRdSpl = 0;
	}
	//____________________________________________________________________________
	BergerSehgalRESPXSec2014::BergerSehgalRESPXSec2014(string config) :
	  XSecAlgorithmI("genie::BergerSehgalRESPXSec2014", config)
	{
	  fNuTauRdSpl    = 0;
	  fNuTauBarRdSpl = 0;
	}
	//____________________________________________________________________________
	BergerSehgalRESPXSec2014::~BergerSehgalRESPXSec2014()
	{
	  if(fNuTauRdSpl)    delete fNuTauRdSpl;
	  if(fNuTauBarRdSpl) delete fNuTauBarRdSpl;
	}
	//____________________________________________________________________________
	double BergerSehgalRESPXSec2014::XSec(
	    const Interaction * interaction, KinePhaseSpace_t kps) const
	{
	  if(! this -> ValidProcess    (interaction) ) return 0.;
	  if(! this -> ValidKinematics (interaction) ) return 0.;
	
	  const InitialState & init_state = interaction -> InitState();
	  const ProcessInfo &  proc_info  = interaction -> ProcInfo();
	  const Target & target = init_state.Tgt();
	
	  // Get kinematical parameters
	  const Kinematics & kinematics = interaction -> Kine();
	  double W  = kinematics.W();
	  double q2 = kinematics.q2();
	  double costh = kinematics.FSLeptonP4().CosTheta();
	
	  // Under the DIS/RES joining scheme, xsec(RES)=0 for W>=Wcut
	  if(fUsingDisResJoin) {
	    if(W>=fWcut) {
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	      LOG("BergerSehgalRESPXSec2014", pDEBUG)
	        << "RES/DIS Join Scheme: XSec[RES, W=" << W 
	        << " >= Wcut=" << fWcut << "] = 0";
	#endif
	      return 0;
	    }
	  }
	
	  // Get the input baryon resonance
	  Resonance_t resonance = interaction->ExclTag().Resonance();
	  string      resname   = utils::res::AsString(resonance);
	  bool        is_delta  = utils::res::IsDelta (resonance);
	
	  // Get the neutrino, hit nucleon & weak current
	  int  nucpdgc   = target.HitNucPdg();
	  int  probepdgc = init_state.ProbePdg();
	  bool is_nu     = pdg::IsNeutrino         (probepdgc);
	  bool is_nubar  = pdg::IsAntiNeutrino     (probepdgc);
	  bool is_lplus  = pdg::IsPosChargedLepton (probepdgc);
	  bool is_lminus = pdg::IsNegChargedLepton (probepdgc);
	  bool is_p      = pdg::IsProton  (nucpdgc);
	  bool is_n      = pdg::IsNeutron (nucpdgc);
	  bool is_CC     = proc_info.IsWeakCC();
	  bool is_NC     = proc_info.IsWeakNC();
	  bool is_EM     = proc_info.IsEM();
	
	  //  bool new_GV = fGA; //JN
	  //  bool new_GA = fGV; //JN
	
	
	  if(is_CC && !is_delta) {
	    if((is_nu && is_p) || (is_nubar && is_n)) return 0;
	  }
	
	  // Get baryon resonance parameters
	  int    IR  = utils::res::ResonanceIndex    (resonance);
	  int    LR  = utils::res::OrbitalAngularMom (resonance);
	  double MR  = utils::res::Mass              (resonance);
	  double WR  = utils::res::Width             (resonance);
	  double NR  = utils::res::BWNorm            (resonance);
	
	  // Following NeuGEN, avoid problems with underlying unphysical
	  // model assumptions by restricting the allowed W phase space
	  // around the resonance peak
	  if      (W > MR + fN0ResMaxNWidths * WR && IR==0) return 0.;
	  else if (W > MR + fN2ResMaxNWidths * WR && IR==2) return 0.;
	  else if (W > MR + fGnResMaxNWidths * WR)          return 0.;
	
	  // Compute auxiliary & kinematical factors 
	  double E      = init_state.ProbeE(kRfHitNucRest);
	  double Mnuc   = target.HitNucMass(); 
	  double W2     = TMath::Power(W,    2);
	  double Mnuc2  = TMath::Power(Mnuc, 2);
	  double k      = 0.5 * (W2 - Mnuc2)/Mnuc;
	  double v      = k - 0.5 * q2/Mnuc;
	  double v2     = TMath::Power(v, 2);
	  double Q2     = v2 - q2;
	  double Q      = TMath::Sqrt(Q2);
	  double Eprime = E - v;
	  double U      = 0.5 * (E + Eprime + Q) / E;
	  double V      = 0.5 * (E + Eprime - Q) / E;
	  double U2     = TMath::Power(U, 2);
	  double V2     = TMath::Power(V, 2);
	  double UV     = U*V;
	
	
	  //JN parameter from the KUZMIN et al.
	
	  //  bool is_RS  = true;
	  bool is_KNL = false;
	  if(fKNL && is_CC) is_KNL=true;
	
	  bool is_BRS = false;
	  if(fBRS && is_CC) is_BRS=true;
	
	  double ml    = interaction->FSPrimLepton()->Mass();
	  double Pl    = TMath::Sqrt(Eprime*Eprime - ml*ml);
	
	  double vstar = (Mnuc*v + q2)/W;  //missing W
	  double Qstar = TMath::Sqrt(-q2 + vstar*vstar);
	  double sqrtq2 = TMath::Sqrt(-q2);
	  double a = 1. + 0.5*(W2-q2+Mnuc2)/Mnuc/W;
	
	
	  double KNL_Alambda_plus  = 0;
	  double KNL_Alambda_minus = 0;
	  double KNL_j0_plus  = 0;
	  double KNL_j0_minus = 0;
	  double KNL_jx_plus  = 0;
	  double KNL_jx_minus = 0;
	  double KNL_jy_plus  = 0;
	  double KNL_jy_minus = 0;
	  double KNL_jz_plus  = 0;
	  double KNL_jz_minus = 0;
	  double KNL_Qstar_plus =0;
	  double KNL_Qstar_minus =0;
	
	  double KNL_K = Q/E/TMath::Sqrt(2*(-q2));
	
	
	  double KNL_cL_plus  = 0;
	  double KNL_cL_minus = 0;
	
	  double KNL_cR_plus  = 0;
	  double KNL_cR_minus = 0;
	
	
	  double KNL_cS_plus  = 0;
	  double KNL_cS_minus = 0;
	
	  double KNL_vstar_plus = 0 ;
	  double KNL_vstar_minus = 0 ;
	
	
	
	  if(is_CC && (is_KNL || is_BRS)){
	
	    LOG("BergerSehgalRESPXSec2014",pINFO) "costh1="<<costh;    
	    costh = (q2 - ml*ml + 2.*E*Eprime)/2./E/Pl;
	    //ml=0;
	    LOG("BergerSehgalRESPXSec2014",pINFO) "q2="<<q2<< "m2="<<ml*ml<<" 2.*E*Eprime="<<2.*E*Eprime<<" nom="<< (q2 - ml*ml + 2.*E*Eprime)<<" den="<<2.*E*Pl;
	    LOG("BergerSehgalRESPXSec2014",pINFO) "costh2="<<costh;
	    Pl    = TMath::Sqrt(Eprime*Eprime - ml*ml);
	
	
	    if(costh <= -1. + 1e-7) {
	      LOG("BergerSehgalRESPXSec2014", pDEBUG)
	        << "Changing costh = " << costh << " to -1";
	      costh = -1 + 1e-6;
	    }
	    if(costh >= 1. - 1e-7){
	      LOG("BergerSehgalRESPXSec2014", pDEBUG)
	        << "Changing costh = " << costh << " to 1";
	      costh = 1 - 1e-6;
	    }
	    vstar = (Mnuc*v + q2)/W;//missing W
	    Qstar = TMath::Sqrt(-q2 + vstar*vstar);
	
	
	    KNL_Alambda_plus  = TMath::Sqrt(E*(Eprime - Pl));
	    KNL_Alambda_minus = TMath::Sqrt(E*(Eprime + Pl));
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"+++++++++++++++++++++++";
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"E="<<E << " K= "<<KNL_K;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"El="<<Eprime<<" Pl="<<Pl<<" ml="<<ml;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"W="<<W<<" Q="<<Q<<" q2="<<q2;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"A-="<<KNL_Alambda_minus<<" A+="<<KNL_Alambda_plus;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"xxxxxxxxxxxxxxxxxxxxxxx";
	
	    KNL_j0_plus  = KNL_Alambda_plus /W * TMath::Sqrt(1 - costh) * (Mnuc - Eprime - Pl);
	    KNL_j0_minus = KNL_Alambda_minus/W * TMath::Sqrt(1 + costh) * (Mnuc - Eprime + Pl);
	
	    KNL_jx_plus  = KNL_Alambda_plus/ Q * TMath::Sqrt(1 + costh) * (Pl - E);
	    KNL_jx_minus = KNL_Alambda_minus/Q * TMath::Sqrt(1 - costh) * (Pl + E);
	
	    KNL_jy_plus  =  KNL_Alambda_plus  * TMath::Sqrt(1 + costh);
	    KNL_jy_minus = -KNL_Alambda_minus * TMath::Sqrt(1 - costh);
	
	    KNL_jz_plus  = KNL_Alambda_plus /W/Q *  TMath::Sqrt(1 - costh) * ( (E + Pl)*(Mnuc -Eprime) + Pl*(  E + 2*E*costh -Pl) );
	    KNL_jz_minus = KNL_Alambda_minus/W/Q *  TMath::Sqrt(1 + costh) * ( (E - Pl)*(Mnuc -Eprime) + Pl*( -E + 2*E*costh -Pl) );
	
	    if (is_nu || is_lminus) {
	      KNL_Qstar_plus  = sqrtq2 * KNL_j0_plus  / TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	      KNL_Qstar_minus = sqrtq2 * KNL_j0_minus / TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	    }
	
	    else if (is_nubar || is_lplus){
	      KNL_Qstar_plus  = sqrtq2 * KNL_j0_minus / TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	      KNL_Qstar_minus = sqrtq2 * KNL_j0_plus / TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	    }
	
	    if (is_nu || is_lminus) {
	      KNL_vstar_plus  = sqrtq2 * KNL_jz_plus  / TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	      KNL_vstar_minus = sqrtq2 * KNL_jz_minus / TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	    }
	    else if (is_nubar || is_lplus) {
	      KNL_vstar_minus  = sqrtq2 * KNL_jz_plus / TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	      KNL_vstar_plus   = sqrtq2 * KNL_jz_minus / TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	    }
	
	    if(is_nu || is_lminus){
	      KNL_cL_plus  = TMath::Sqrt(0.5)* KNL_K * (KNL_jx_plus  - KNL_jy_plus);
	      KNL_cL_minus = TMath::Sqrt(0.5)* KNL_K * (KNL_jx_minus - KNL_jy_minus);
	
	      KNL_cR_plus  = TMath::Sqrt(0.5)* KNL_K * (KNL_jx_plus  + KNL_jy_plus);
	      KNL_cR_minus = TMath::Sqrt(0.5)* KNL_K * (KNL_jx_minus + KNL_jy_minus);
	
	      KNL_cS_plus   = KNL_K *  TMath::Sqrt(TMath::Abs(KNL_j0_plus *KNL_j0_plus  - KNL_jz_plus *KNL_jz_plus ) );
	      KNL_cS_minus  = KNL_K *  TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	    }
	
	    if (is_nubar || is_lplus) {
	      KNL_cL_plus  =  1 * TMath::Sqrt(0.5)* KNL_K * (KNL_jx_minus - KNL_jy_minus);
	      KNL_cL_minus = -1 * TMath::Sqrt(0.5)* KNL_K * (KNL_jx_plus  - KNL_jy_plus);
	
	      KNL_cR_plus  =  1 * TMath::Sqrt(0.5)* KNL_K * (KNL_jx_minus + KNL_jy_minus);
	      KNL_cR_minus = -1 * TMath::Sqrt(0.5)* KNL_K * (KNL_jx_plus  + KNL_jy_plus);
	
	      KNL_cS_plus  = -1 * KNL_K *  TMath::Sqrt(TMath::Abs(KNL_j0_minus*KNL_j0_minus - KNL_jz_minus*KNL_jz_minus) );
	      KNL_cS_minus =  1 * KNL_K *  TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	    }
	  }
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"j0-="<<KNL_j0_minus<<" j0+="<<KNL_j0_plus;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"jx-="<<KNL_jx_minus<<" jx+="<<KNL_jx_plus;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"jy-="<<KNL_jy_minus<<" jy+="<<KNL_jy_plus;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"jz-="<<KNL_jz_minus<<" jz+="<<KNL_jz_plus;
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) "sqrt2="<<sqrtq2<<" jz+=:"<<KNL_jz_plus<<" j0+="<<KNL_j0_plus<<" denom="<<TMath::Sqrt(TMath::Abs(KNL_j0_plus*KNL_j0_plus - KNL_jz_plus*KNL_jz_plus) );
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"vstar-="<<KNL_vstar_minus<<" vstar+="<<KNL_vstar_plus;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"Qstar-="<<KNL_Qstar_minus<<" Qstar+="<<KNL_Qstar_plus;
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("BergerSehgalRESPXSec2014", pDEBUG) 
	    << "Kinematical params V = " << V << ", U = " << U;
	#endif
	
	  // Calculate the Feynman-Kislinger-Ravndall parameters
	
	  double Go  = TMath::Power(1 - 0.25 * q2/Mnuc2, 0.5-IR);
	  double GV  = Go * TMath::Power( 1./(1-q2/fMv2), 2);
	  double GA  = Go * TMath::Power( 1./(1-q2/fMa2), 2);
	
	
	  //JN New form factors code
	  //  new_GV = false; //JN
	  //  new_GA = true; //JN
	
	  if(fGV){
	
	        LOG("BergerSehgal2014",pDEBUG) <<"Using new GV";
	    double CV0 =  1./(1-q2/fMv2/4.);
	    double CV3 =  2.13 * CV0 * TMath::Power( 1-q2/fMv2,-2);
	    double CV4 = -1.51 * CV0 * TMath::Power( 1-q2/fMv2,-2);
	    double CV5 =  0.48 * CV0 * TMath::Power( 1-q2/fMv2/0.766, -2);
	
	
	    double GV3 =   0.5 / TMath::Sqrt(3) * ( CV3 * (W + Mnuc)/Mnuc
	        + CV4 * (W2 + q2 -Mnuc2)/2./Mnuc2 
	        + CV5 * (W2 - q2 -Mnuc2)/2./Mnuc2 );
	
	    double GV1 = - 0.5 / TMath::Sqrt(3) * ( CV3 * (Mnuc2 -q2 +Mnuc*W)/W/Mnuc
	        + CV4 * (W2 +q2 - Mnuc2)/2./Mnuc2 
	        + CV5 * (W2 -q2 - Mnuc2)/2./Mnuc2 );
	
	    GV = 0.5 * TMath::Power( 1 - q2/(Mnuc + W)/(Mnuc + W), 0.5-IR)
	      * TMath::Sqrt( 3 * GV3*GV3 + GV1*GV1);
	
	
	  }
	
	  if(fGA){
	
	    LOG("BergerSehgalRESPXSec2014",pDEBUG) <<"Using new GA";
	
	    double CA5_0 = 1.2;
	    double CA5 = CA5_0 *  TMath::Power( 1./(1-q2/fMa2), 2);
	    //  GA = 0.5 * TMath::Sqrt(3.) * TMath::Power( 1 - q2/(Mnuc + W)/(Mnuc + W), 0.5-IR) * (1- (W2 +q2 -Mnuc2)/8./Mnuc2) * CA5/fZeta;
	    GA = 0.5 * TMath::Sqrt(3.) * TMath::Power( 1 - q2/(Mnuc + W)/(Mnuc + W), 0.5-IR) * (1- (W2 +q2 -Mnuc2)/8./Mnuc2) * CA5;
	
	    //    LOG("BergerSehgal2014",pINFO) << 0.5 * TMath::Sqrt(3.) * TMath::Power( 1 - q2/(Mnuc + W)/(Mnuc + W), 0.5-IR)* (1- (W2 +q2 -Mnuc2)/8./Mnuc2);
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"GA= " <<GA << "  C5A= " <<CA5;
	  }
	
	  //JN end of new form factors code
	
	
	
	  if(is_EM) { 
	    GA = 0.; // zero the axial term for EM scattering
	  }
	
	  double d      = TMath::Power(W+Mnuc,2.) - q2;
	  double sq2omg = TMath::Sqrt(2./fOmega);
	  double nomg   = IR * fOmega;
	  double mq_w   = Mnuc*Q/W;
	
	  fFKR.Lamda  = sq2omg * mq_w;
	  fFKR.Tv     = GV / (3.*W*sq2omg);
	  fFKR.Rv     = kSqrt2 * mq_w*(W+Mnuc)*GV / d;
	  fFKR.S      = (-q2/Q2) * (3*W*Mnuc + q2 - Mnuc2) * GV / (6*Mnuc2);
	  fFKR.Ta     = (2./3.) * (fZeta/sq2omg) * mq_w * GA / d;
	  fFKR.Ra     = (kSqrt2/6.) * fZeta * (GA/W) * (W+Mnuc + 2*nomg*W/d );
	  fFKR.B      = fZeta/(3.*W*sq2omg) * (1 + (W2-Mnuc2+q2)/ d) * GA;
	  fFKR.C      = fZeta/(6.*Q) * (W2 - Mnuc2 + nomg*(W2-Mnuc2+q2)/d) * (GA/Mnuc);
	  fFKR.R      = fFKR.Rv;
	  fFKR.Rplus  = - (fFKR.Rv + fFKR.Ra);
	  fFKR.Rminus = - (fFKR.Rv - fFKR.Ra);
	  fFKR.T      = fFKR.Tv;
	  fFKR.Tplus  = - (fFKR.Tv + fFKR.Ta);
	  fFKR.Tminus = - (fFKR.Tv - fFKR.Ta);
	
	  //JN KNL
	  double KNL_S_plus = 0;
	  double KNL_S_minus = 0;
	  double KNL_B_plus = 0;
	  double KNL_B_minus = 0;
	  double KNL_C_plus = 0;
	  double KNL_C_minus = 0;
	
	  if(is_CC && is_KNL){
	    KNL_S_plus  = (KNL_vstar_plus*vstar  - KNL_Qstar_plus *Qstar )* (Mnuc2 -q2 - 3*W*Mnuc ) * GV / (6*Mnuc2)/Q2; //possibly missing minus sign ()
	    KNL_S_minus = (KNL_vstar_minus*vstar - KNL_Qstar_minus*Qstar )* (Mnuc2 -q2 - 3*W*Mnuc ) * GV / (6*Mnuc2)/Q2;
	
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"KNL S= " <<KNL_S_plus<<"\t"<<KNL_S_minus<<"\t"<<fFKR.S;
	
	    KNL_B_plus  = fZeta/(3.*W*sq2omg)/Qstar * (KNL_Qstar_plus  + KNL_vstar_plus *Qstar/a/Mnuc ) * GA;
	    KNL_B_minus = fZeta/(3.*W*sq2omg)/Qstar * (KNL_Qstar_minus + KNL_vstar_minus*Qstar/a/Mnuc ) * GA;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"KNL B= " <<KNL_B_plus<<"\t"<<KNL_B_minus<<"\t"<<fFKR.B;
	
	    KNL_C_plus = ( (KNL_Qstar_plus*Qstar - KNL_vstar_plus*vstar ) * ( 1./3. + vstar/a/Mnuc)
	        + KNL_vstar_plus*(2./3.*W +q2/a/Mnuc + nomg/3./a/Mnuc) )* fZeta * (GA/2./W/Qstar);
	
	    KNL_C_minus = ( (KNL_Qstar_minus*Qstar - KNL_vstar_minus*vstar ) * ( 1./3. + vstar/a/Mnuc)
	        + KNL_vstar_minus*(2./3.*W +q2/a/Mnuc + nomg/3./a/Mnuc) )* fZeta * (GA/2./W/Qstar);
	
	    LOG("BergerSehgalRESPXSec2014",pINFO)  <<"KNL C= "<<KNL_C_plus<<"\t"<<KNL_C_minus<<"\t"<<fFKR.C;
	  }
	  double BRS_S_plus = 0;
	  double BRS_S_minus = 0;
	  double BRS_B_plus = 0;
	  double BRS_B_minus = 0;
	  double BRS_C_plus = 0;
	  double BRS_C_minus = 0;
	
	
	  if(is_CC && is_BRS){
	
	    KNL_S_plus  = (KNL_vstar_plus*vstar  - KNL_Qstar_plus *Qstar )* (Mnuc2 -q2 - 3*W*Mnuc ) * GV / (6*Mnuc2)/Q2;
	    KNL_S_minus = (KNL_vstar_minus*vstar - KNL_Qstar_minus*Qstar )* (Mnuc2 -q2 - 3*W*Mnuc ) * GV / (6*Mnuc2)/Q2;
	
	
	    KNL_B_plus  = fZeta/(3.*W*sq2omg)/Qstar * (KNL_Qstar_plus  + KNL_vstar_plus *Qstar/a/Mnuc ) * GA;
	    KNL_B_minus = fZeta/(3.*W*sq2omg)/Qstar * (KNL_Qstar_minus + KNL_vstar_minus*Qstar/a/Mnuc ) * GA;
	
	
	    KNL_C_plus = ( (KNL_Qstar_plus*Qstar - KNL_vstar_plus*vstar ) * ( 1./3. + vstar/a/Mnuc)
	        + KNL_vstar_plus*(2./3.*W +q2/a/Mnuc + nomg/3./a/Mnuc) )* fZeta * (GA/2./W/Qstar);
	
	    KNL_C_minus = ( (KNL_Qstar_minus*Qstar - KNL_vstar_minus*vstar ) * ( 1./3. + vstar/a/Mnuc)
	        + KNL_vstar_minus*(2./3.*W +q2/a/Mnuc + nomg/3./a/Mnuc) )* fZeta * (GA/2./W/Qstar);
	
	    BRS_S_plus = KNL_S_plus;
	    BRS_S_minus = KNL_S_minus;
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"BRS S= " <<KNL_S_plus<<"\t"<<KNL_S_minus<<"\t"<<fFKR.S;
	
	    BRS_B_plus = KNL_B_plus + fZeta*GA/2./W/Qstar*( KNL_Qstar_plus*vstar - KNL_vstar_plus*Qstar)
	      *( 2./3 /sq2omg *(vstar + Qstar*Qstar/Mnuc/a))/(kPionMass2 -q2);
	
	    BRS_B_minus = KNL_B_minus + fZeta*GA/2./W/Qstar*( KNL_Qstar_minus*vstar - KNL_vstar_minus*Qstar)
	      *( 2./3 /sq2omg *(vstar + Qstar*Qstar/Mnuc/a))/(kPionMass2 -q2);
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"BRS B= " <<KNL_B_plus<<"\t"<<KNL_B_minus<<"\t"<<fFKR.B;
	
	    BRS_C_plus = KNL_C_plus  + fZeta*GA/2./W/Qstar*( KNL_Qstar_plus*vstar - KNL_vstar_plus*Qstar)
	      * Qstar*(2./3.*W +q2/Mnuc/a +nomg/3./a/Mnuc)/(kPionMass2 -q2);
	
	    BRS_C_minus = KNL_C_minus  + fZeta*GA/2./W/Qstar*( KNL_Qstar_minus*vstar - KNL_vstar_minus*Qstar)
	      * Qstar*(2./3.*W +q2/Mnuc/a +nomg/3./a/Mnuc)/(kPionMass2 -q2);
	    LOG("BergerSehgalRESPXSec2014",pINFO) <<"BRS C= " <<KNL_C_plus<<"\t"<<KNL_C_minus<<"\t"<<fFKR.C;
	
	  }
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("FKR", pDEBUG) 
	    << "FKR params for RES = " << resname << " : " << fFKR;
	#endif
	
	  // Calculate the Rein-Sehgal Helicity Amplitudes
	  double sigL_minus = 0;
	  double sigR_minus = 0;
	  double sigS_minus = 0;
	
	  double sigL_plus = 0;
	  double sigR_plus = 0;
	  double sigS_plus = 0;
	
	  const RSHelicityAmplModelI * hamplmod = 0;
	  const RSHelicityAmplModelI * hamplmod_KNL_minus = 0;
	  const RSHelicityAmplModelI * hamplmod_KNL_plus = 0;
	  const RSHelicityAmplModelI * hamplmod_BRS_minus = 0;
	  const RSHelicityAmplModelI * hamplmod_BRS_plus = 0;
	
	  double g2 = kGF2;
	
	  double sig0 = 0.125*(g2/kPi)*(-q2/Q2)*(W/Mnuc);
	  double scLR = W/Mnuc;
	  double scS  = (Mnuc/W)*(-Q2/q2);
	
	  double sigL =0;
	  double sigR =0;
	  double sigS =0;
	
	  double sigRSL =0;
	  double sigRSR =0;
	  double sigRSS =0;
	
	  /*
	     hamplmod = fHAmplModelCC;
	     const RSHelicityAmpl & hampl = hamplmod->Compute(resonance, fFKR);
	
	     sigRSL = scLR* (hampl.Amp2Plus3 () + hampl.Amp2Plus1 ());
	     sigRSR = scLR* (hampl.Amp2Minus3() + hampl.Amp2Minus1());
	     sigRSS = scS * (hampl.Amp20Plus () + hampl.Amp20Minus());
	
	*/
	  //<<<<<<<<<
	  if(is_CC && !(is_KNL || is_BRS) ) {
	
	    hamplmod = fHAmplModelCC;
	  }
	  else
	    if(is_NC) {
	      if (is_p) { hamplmod = fHAmplModelNCp;}
	      else      { hamplmod = fHAmplModelNCn;}
	    }
	    else
	      if(is_EM) {
	        if (is_p) { hamplmod = fHAmplModelEMp;}
	        else      { hamplmod = fHAmplModelEMn;}
	      }
	      else
	        if(is_CC && is_KNL ){
	          fFKR.S = KNL_S_minus;        //2 times fFKR.S?
	          fFKR.B = KNL_B_minus;
	          fFKR.S = KNL_C_minus;
	
	          hamplmod_KNL_minus = fHAmplModelCC;
	
	          assert(hamplmod_KNL_minus);
	
	          const RSHelicityAmpl & hampl_KNL_minus = hamplmod_KNL_minus->Compute(resonance, fFKR);
	
	          sigL_minus = (hampl_KNL_minus.Amp2Plus3 () + hampl_KNL_minus.Amp2Plus1 ());
	          sigR_minus = (hampl_KNL_minus.Amp2Minus3() + hampl_KNL_minus.Amp2Minus1());
	          sigS_minus = (hampl_KNL_minus.Amp20Plus () + hampl_KNL_minus.Amp20Minus());
	
	
	          fFKR.S = KNL_S_plus;
	          fFKR.B = KNL_B_plus;
	          fFKR.S = KNL_C_plus;
	          hamplmod_KNL_plus = fHAmplModelCC;
	          assert(hamplmod_KNL_plus);
	
	          const RSHelicityAmpl & hampl_KNL_plus = hamplmod_KNL_plus->Compute(resonance, fFKR);
	
	          sigL_plus = (hampl_KNL_plus.Amp2Plus3 () + hampl_KNL_plus.Amp2Plus1 ());
	          sigR_plus = (hampl_KNL_plus.Amp2Minus3() + hampl_KNL_plus.Amp2Minus1());
	          sigS_plus = (hampl_KNL_plus.Amp20Plus () + hampl_KNL_plus.Amp20Minus());
	
	        }
	        else
	          if(is_CC && is_BRS ){
	            fFKR.S = BRS_S_minus;
	            fFKR.B = BRS_B_minus;
	            fFKR.S = BRS_C_minus;
	
	            hamplmod_BRS_minus = fHAmplModelCC;
	            assert(hamplmod_BRS_minus);
	
	            const RSHelicityAmpl & hampl_BRS_minus = hamplmod_BRS_minus->Compute(resonance, fFKR);
	
	            sigL_minus = (hampl_BRS_minus.Amp2Plus3 () + hampl_BRS_minus.Amp2Plus1 ());
	            sigR_minus = (hampl_BRS_minus.Amp2Minus3() + hampl_BRS_minus.Amp2Minus1());
	            sigS_minus = (hampl_BRS_minus.Amp20Plus () + hampl_BRS_minus.Amp20Minus());
	
	            fFKR.S = BRS_S_plus;
	            fFKR.B = BRS_B_plus;
	            fFKR.S = BRS_C_plus;
	            hamplmod_BRS_plus = fHAmplModelCC;
	            assert(hamplmod_BRS_plus);
	
	            const RSHelicityAmpl & hampl_BRS_plus = hamplmod_BRS_plus->Compute(resonance, fFKR);
	
	            sigL_plus = (hampl_BRS_plus.Amp2Plus3 () + hampl_BRS_plus.Amp2Plus1 ());
	            sigR_plus = (hampl_BRS_plus.Amp2Minus3() + hampl_BRS_plus.Amp2Minus1());
	            sigS_plus = (hampl_BRS_plus.Amp20Plus () + hampl_BRS_plus.Amp20Minus());
	          }
	  /*
	     if(is_CC) { 
	     hamplmod = fHAmplModelCC; 
	     }
	     else 
	     if(is_NC) { 
	     if (is_p) { hamplmod = fHAmplModelNCp;}
	     else      { hamplmod = fHAmplModelNCn;}
	     }
	     else 
	     if(is_EM) { 
	     if (is_p) { hamplmod = fHAmplModelEMp;}
	     else      { hamplmod = fHAmplModelEMn;}
	     }
	     assert(hamplmod);
	
	     const RSHelicityAmpl & hampl = hamplmod->Compute(resonance, fFKR); 
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	  LOG("RSHAmpl", pDEBUG)
	    << "Helicity Amplitudes for RES = " << resname << " : " << hampl;
	#endif
	     */
	
	  //JNtest double g2 = kGF2;
	  // For EM interaction replace  G_{Fermi} with :
	  // a_{em} * pi / ( sqrt(2) * sin^2(theta_weinberg) * Mass_{W}^2 }
	  // See C.Quigg, Gauge Theories of the Strong, Weak and E/M Interactions,
	  // ISBN 0-8053-6021-2, p.112 (6.3.57)
	  // Also, take int account that the photon propagator is 1/p^2 but the
	  // W propagator is 1/(p^2-Mass_{W}^2), so weight the EM case with
	  // Mass_{W}^4 / q^4
	  // So, overall:
	  // G_{Fermi}^2 --> a_{em}^2 * pi^2 / (2 * sin^4(theta_weinberg) * q^{4})
	  //
	    if(is_EM) {
	      double q4 = q2*q2;
	      g2 = kAem2 * kPi2 / (2.0 * fSin48w * q4); 
	    }
	
	// Compute the cross section
	
	/*
	   double sig0 = 0.125*(g2/kPi)*(-q2/Q2)*(W/Mnuc);
	   double scLR = W/Mnuc;
	   double scS  = (Mnuc/W)*(-Q2/q2);
	
	   JN test */
	//  double sigL = scLR* (hampl.Amp2Plus3 () + hampl.Amp2Plus1 ());
	//  double sigR = scLR* (hampl.Amp2Minus3() + hampl.Amp2Minus1());
	//  double sigS = scS * (hampl.Amp20Plus () + hampl.Amp20Minus());
	
	/*
	   double sigL =0;
	   double sigR =0;
	   double sigS =0;
	   JN tests  */
	
	if( is_KNL || is_BRS){
	
	  sigL_minus *= scLR;
	  sigR_minus *= scLR;
	  sigS_minus *= scS;
	
	  sigL_plus *= scLR;
	  sigR_plus *= scLR;
	  sigS_plus *= scS;
	  LOG("BergerSehgalRESPXSec2014",pINFO) <<"sL,R,S minus="<<sigL_minus<<","<<sigR_minus<<","<<sigS_minus;
	  LOG("BergerSehgalRESPXSec2014",pINFO) <<"sL,R,S plus ="<<sigL_plus <<","<<sigR_plus <<","<<sigS_plus;
	}
	else {
	  assert(hamplmod);
	
	  const RSHelicityAmpl & hampl = hamplmod->Compute(resonance, fFKR);
	
	  sigL = scLR* (hampl.Amp2Plus3 () + hampl.Amp2Plus1 ());
	  sigR = scLR* (hampl.Amp2Minus3() + hampl.Amp2Minus1());
	  sigS = scS * (hampl.Amp20Plus () + hampl.Amp20Minus());
	}
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	LOG("BergerSehgalRESPXSec2014", pDEBUG) << "sig_{0} = " << sig0;
	LOG("BergerSehgalRESPXSec2014", pDEBUG) << "sig_{L} = " << sigL;
	LOG("BergerSehgalRESPXSec2014", pDEBUG) << "sig_{R} = " << sigR;
	LOG("BergerSehgalRESPXSec2014", pDEBUG) << "sig_{S} = " << sigS;
	#endif
	
	double xsec = 0.0;
	
	if(is_KNL || is_BRS){
	  xsec =  TMath::Power(KNL_cL_minus,2)*sigL_minus + TMath::Power(KNL_cL_plus,2)*sigL_plus
	    + TMath::Power(KNL_cR_minus,2)*sigR_minus + TMath::Power(KNL_cR_plus,2)*sigR_plus
	    + TMath::Power(KNL_cS_minus,2)*sigS_minus + TMath::Power(KNL_cS_plus,2)*sigS_plus;
	  xsec *=sig0;
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"A-="<<KNL_Alambda_minus<<" A+="<<KNL_Alambda_plus;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<q2<<"\t"<<xsec<<"\t"<<sig0*(V2*sigR + U2*sigL + 2*UV*sigS)<<"\t"<<xsec/(sig0*(V2*sigRSR + U2*sigRSL + 2*UV*sigRSS));
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"fFKR.B="<<fFKR.B<<" fFKR.C="<<fFKR.C<<" fFKR.S="<<fFKR.S;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"CL-="<<TMath::Power(KNL_cL_minus,2)<<" CL+="<<TMath::Power(KNL_cL_plus,2)<<" U2="<<U2;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"SL-="<<sigL_minus<<" SL+="<<sigL_plus<<" SL="<<sigRSL;
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"CR-="<<TMath::Power(KNL_cR_minus,2)<<" CR+="<<TMath::Power(KNL_cR_plus,2)<<" V2="<<V2;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"SR-="<<sigR_minus<<" SR+="<<sigR_plus<<" sR="<<sigRSR;
	
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"CS-="<<TMath::Power(KNL_cS_minus,2)<<" CS+="<<TMath::Power(KNL_cS_plus,2)<<" UV="<<UV;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<"SS-="<<sigL_minus<<" SS+="<<sigS_plus<<" sS="<<sigRSS;
	     LOG("BergerSehgalRESPXSec2014",pINFO) <<">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>\n";
	
	}
	else{
	  if (is_nu || is_lminus) {
	    xsec = sig0*(V2*sigR + U2*sigL + 2*UV*sigS);
	  } 
	  else 
	    if (is_nubar || is_lplus) {
	      xsec = sig0*(U2*sigR + V2*sigL + 2*UV*sigS);
	    } 
	  xsec = TMath::Max(0.,xsec);
	}
	double mult = 1.0;
	if(is_CC && is_delta) {
	  if((is_nu && is_p) || (is_nubar && is_n)) mult=3.0;
	}
	xsec *= mult;
	
	// Check whether the cross section is to be weighted with a
	// Breit-Wigner distribution (default: true)
	double bw = 1.0;
	if(fWghtBW) {
	  bw = utils::bwfunc::BreitWignerL(W,LR,MR,WR,NR); 
	} 
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	LOG("BergerSehgalRESPXSec2014", pDEBUG) << "BreitWigner(RES=" 
	  << resname << ", W=" << W << ") = " << bw;
	#endif
	xsec *= bw; 
	
	// Apply NeuGEN nutau cross section reduction factors
	double rf = 1.0;
	Spline * spl = 0;
	if (is_CC && fUsingNuTauScaling) {
	  if (pdg::IsNuTau(probepdgc)) {
	    spl = fNuTauRdSpl;
	  }
	  else if (pdg::IsAntiNuTau(probepdgc)) {
	    spl = fNuTauBarRdSpl;
	  }
	  if(spl) {
	    if(E <spl->XMax()) rf = spl->Evaluate(E);
	  }
	}
	xsec *= rf;
	
	#ifdef __GENIE_LOW_LEVEL_MESG_ENABLED__
	LOG("BergerSehgalRESPXSec2014", pINFO) 
	  << "\n d2xsec/dQ2dW"  << "[" << interaction->AsString()
	  << "](W=" << W << ", q2=" << q2 << ", E=" << E << ") = " << xsec;
	#endif
	
	// The algorithm computes d^2xsec/dWdQ2
	// Check whether variable tranformation is needed
	if(kps!=kPSWQ2fE) {
	  double J = utils::kinematics::Jacobian(interaction,kPSWQ2fE,kps);
	  xsec *= J;
	}
	
	// If requested return the free nucleon xsec even for input nuclear tgt
	if( interaction->TestBit(kIAssumeFreeNucleon) ) return xsec;
	
	// Take into account the number of scattering centers in the target
	int NNucl = (is_p) ? target.Z() : target.N();
	
	xsec*=NNucl; // nuclear xsec (no nuclear suppression factor)
	
	return xsec;
	}
	//____________________________________________________________________________
	double BergerSehgalRESPXSec2014::Integral(const Interaction * interaction) const
	{
	  double xsec = fXSecIntegrator->Integrate(this,interaction);
	  return xsec;
	}
	//____________________________________________________________________________
	bool BergerSehgalRESPXSec2014::ValidProcess(const Interaction * interaction) const
	{
	  if(interaction->TestBit(kISkipProcessChk)) return true;
	
	  const InitialState & init_state = interaction->InitState();
	  const ProcessInfo &  proc_info  = interaction->ProcInfo();
	  const XclsTag &      xcls       = interaction->ExclTag();
	
	  if(!proc_info.IsResonant()) return false;
	  if(!xcls.KnownResonance())  return false;
	
	  int  hitnuc = init_state.Tgt().HitNucPdg();
	  bool is_pn = (pdg::IsProton(hitnuc) || pdg::IsNeutron(hitnuc));
	
	  if (!is_pn) return false;
	
	  int  probe   = init_state.ProbePdg();
	  bool is_weak = proc_info.IsWeak(); 
	  bool is_em   = proc_info.IsEM();
	  bool nu_weak = (pdg::IsNeutralLepton(probe) && is_weak);
	  bool l_em    = (pdg::IsChargedLepton(probe) && is_em  );
	
	  if (!nu_weak && !l_em) return false;
	
	  return true;
	}
	//____________________________________________________________________________
	void BergerSehgalRESPXSec2014::Configure(const Registry & config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void BergerSehgalRESPXSec2014::Configure(string config)
	{
	  Algorithm::Configure(config);
	  this->LoadConfig();
	}
	//____________________________________________________________________________
	void BergerSehgalRESPXSec2014::LoadConfig(void)
	{
	  AlgConfigPool * confp = AlgConfigPool::Instance();
	  const Registry * gc = confp->GlobalParameterList();
	
	  // Load all configuration data or set defaults
	
	  LOG("RSHAmpl", pWARN)
	    << "get to beg = ";
	  fZeta  = fConfig->GetDoubleDef( "Zeta",  gc->GetDouble("RS-Zeta")  );
	  LOG("RSHAmpl", pWARN)
	    << "load fZeta";
	  fOmega = fConfig->GetDoubleDef( "Omega", gc->GetDouble("RS-Omega") );
	  LOG("RSHAmpl", pWARN)
	    << "load Omega";
	  fKNL = fConfig->GetBoolDef("is_KNL", gc->GetBool("is_KNL"));
	  LOG("RSHAmpl", pWARN)
	    << "load is_KNL";
	  fBRS = fConfig->GetBoolDef("is_BRS", gc->GetBool("is_BRS"));
	  fGA  = fConfig->GetBoolDef("minibooneGA", gc->GetBool("minibooneGA"));
	  fGV  = fConfig->GetBoolDef("minibooneGV", gc->GetBool("minibooneGV"));
	
	  double ma  = fConfig->GetDoubleDef( "Ma", gc->GetDouble("RES-Ma") );
	  double mv  = fConfig->GetDoubleDef( "Mv", gc->GetDouble("RES-Mv") );
	
	  fMa2 = TMath::Power(ma,2);
	  fMv2 = TMath::Power(mv,2);
	
	  fWghtBW = fConfig->GetBoolDef("BreitWignerWeight", true);
	
	  double thw = fConfig->GetDoubleDef(
	      "weinberg-angle", gc->GetDouble("WeinbergAngle"));
	
	  fSin48w = TMath::Power( TMath::Sin(thw), 4 );
	
	  // Load all the sub-algorithms needed
	
	  fHAmplModelCC     = 0;
	  fHAmplModelNCp    = 0;
	  fHAmplModelNCn    = 0;
	  fHAmplModelEMp    = 0;
	  fHAmplModelEMn    = 0;
	
	  AlgFactory * algf = AlgFactory::Instance();
	
	  fHAmplModelCC  = dynamic_cast<const RSHelicityAmplModelI *> (
	      algf->GetAlgorithm("genie::RSHelicityAmplModelCC","Default"));
	  fHAmplModelNCp = dynamic_cast<const RSHelicityAmplModelI *> (
	      algf->GetAlgorithm("genie::RSHelicityAmplModelNCp","Default"));
	  fHAmplModelNCn = dynamic_cast<const RSHelicityAmplModelI *> (
	      algf->GetAlgorithm("genie::RSHelicityAmplModelNCn","Default"));
	  fHAmplModelEMp = dynamic_cast<const RSHelicityAmplModelI *> (
	      algf->GetAlgorithm("genie::RSHelicityAmplModelEMp","Default"));
	  fHAmplModelEMn = dynamic_cast<const RSHelicityAmplModelI *> (
	      algf->GetAlgorithm("genie::RSHelicityAmplModelEMn","Default"));
	
	  assert( fHAmplModelCC  );
	  assert( fHAmplModelNCp );
	  assert( fHAmplModelNCn );
	  assert( fHAmplModelEMp );
	  assert( fHAmplModelEMn );
	
	  // Use algorithm within a DIS/RES join scheme. If yes get Wcut
	  fUsingDisResJoin = fConfig->GetBoolDef(
	      "UseDRJoinScheme", gc->GetBool("UseDRJoinScheme"));
	  fWcut = 999999;
	  if(fUsingDisResJoin) {
	    fWcut = fConfig->GetDoubleDef("Wcut",gc->GetDouble("Wcut"));
	  }
	
	  // NeuGEN limits in the allowed resonance phase space:
	  // W < min{ Wmin(physical), (res mass) + x * (res width) }
	  // It limits the integration area around the peak and avoids the
	  // problem with huge xsec increase at low Q2 and high W.
	  // In correspondence with Hugh, Rein said that the underlying problem
	  // are unphysical assumptions in the model. 
	  fN2ResMaxNWidths = fConfig->GetDoubleDef("MaxNWidthForN2Res", 2.0);
	  fN0ResMaxNWidths = fConfig->GetDoubleDef("MaxNWidthForN0Res", 6.0);
	  fGnResMaxNWidths = fConfig->GetDoubleDef("MaxNWidthForGNRes", 4.0);
	
	  // NeuGEN reduction factors for nu_tau: a gross estimate of the effect of
	  // neglected form factors in the R/S model
	  fUsingNuTauScaling = fConfig->GetBoolDef("UseNuTauScalingFactors", true);
	  if(fUsingNuTauScaling) {
	    if(fNuTauRdSpl)    delete fNuTauRdSpl;
	    if(fNuTauBarRdSpl) delete fNuTauBarRdSpl;
	
	    assert(gSystem->Getenv("GENIE"));
	    string base = gSystem->Getenv("GENIE");
	
	    string filename = base + "/data/evgen/rein_sehgal/res/nutau_xsec_scaling_factors.dat";
	    LOG("BergerSehgalRESPXSec2014", pINFO) 
	      << "Loading nu_tau xsec reduction spline from: " << filename;
	    fNuTauRdSpl = new Spline(filename);
	
	    filename = base + "/data/evgen/rein_sehgal/res/nutaubar_xsec_scaling_factors.dat";
	    LOG("BergerSehgalRESPXSec2014", pINFO) 
	      << "Loading bar{nu_tau} xsec reduction spline from: " << filename;
	    fNuTauBarRdSpl = new Spline(filename);
	  }
	
	  // load the differential cross section integrator
	  fXSecIntegrator =
	    dynamic_cast<const XSecIntegratorI *> (this->SubAlg("XSec-Integrator"));
	  assert(fXSecIntegrator);
	}
	//____________________________________________________________________________


ReinSehgal/BSKLNBaseRESPXSec2014.cxx


ReinSehgal/FKR.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/KuzminLyubushkinNaumovRESPXSec2014.cxx


ReinSehgal/ReinDFRPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/ReinSehgalCOHPiPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  if (!(target.A()>1))          return false;
  if (!pdg::IsNeutrino(nu) && !pdg::IsAntiNeutrino(nu)) return false;

	  if (!target.A()>1)            return false;
	  if (!pdg::IsNeutrino(nu) && !pdg::IsAntiNeutrino(nu)) return false;
	


ReinSehgal/ReinSehgalRESPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/ReinSehgalRESXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/ReinSehgalRESXSecWithCache.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/ReinSehgalSPPPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
#include "Algorithm/AlgConfigPool.h"
  AlgConfigPool * confp = AlgConfigPool::Instance();
	  assert( fConfig->Exists("ResonanceNameList") );
  const Registry * gc = confp->GlobalParameterList();
  string resonances = fConfig->GetStringDef(
                     "ResonanceNameList", gc->GetString("ResonanceNameList"));
  fResList.DecodeFromNameList(resonances);

  //-- load the differential cross section integrator
  fXSecIntegrator =
      dynamic_cast<const XSecIntegratorI *> (this->SubAlg("XSec-Integrator"));
  assert(fXSecIntegrator);
}
//____________________________________________________________________________
	  string resonanes = fConfig->GetString("ResonanceNameList");
	  fResList.DecodeFromNameList(resonanes);
	
	  //-- load the differential cross section integrator
	  fXSecIntegrator =
	      dynamic_cast<const XSecIntegratorI *> (this->SubAlg("XSec-Integrator"));
	  assert(fXSecIntegrator);
	}
	//____________________________________________________________________________


ReinSehgal/ReinSehgalSPPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmpl.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelCC.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelEMn.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelEMp.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelI.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelNCn.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReinSehgal/RSHelicityAmplModelNCp.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RESHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RESInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RESKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RESPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RSPPHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RSPPInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


RES/RSPPResonanceSelector.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReWeight/GReWeightAGKY.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_AGKY_DEBUG_
	
	double GReWeightAGKY::CalcChisq(void)
	{
	  double chisq =
	    TMath::Power(fPeakBaryonXFTwkDial, 2.) +
	    TMath::Power(fAvgPT2TwkDial,       2.);
	
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeight.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeight::CalcChisq(void) 
	{
	// calculate the sum of penalty terms for all tweaked physics parameters
	//
	  double tot_chisq = 0.0;
	
	  map<string, GReWeightI *>::iterator it = fWghtCalc.begin();
	  for( ; it != fWghtCalc.end(); ++it) {
	    GReWeightI * wcalc = it->second;
	    double chisq = wcalc->CalcChisq(); 
	    LOG("ReW", pNOTICE) 
	       << "Calculator: " << it->first << " => chisq = " << chisq;	
	    tot_chisq *= chisq;
	  }
	  return tot_chisq;
	}
	//____________________________________________________________________________
	
}
//____________________________________________________________________________


	  double chi2val = this->CalcChisq();
	
	  LOG("ReW", pNOTICE) << "Chisq_{penalty} = " << chi2val;
	}
	//____________________________________________________________________________
	
	


ReWeight/GReWeightDISNuclMod.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightDISNuclMod::CalcChisq(void)
	{
	  return 0.;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightFGM.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_FGM_DEBUG_
	
	double GReWeightFGM::CalcChisq(void)
	{
double GReWeightFGM::RewCCQEPauliSupViaKF(const EventRecord & event) 
{
  bool kF_tweaked = (TMath::Abs(fKFTwkDial) > controls::kASmallNum);
  if(!kF_tweaked) return 1.;

  bool is_qe = event.Summary()->ProcInfo().IsQuasiElastic();
  bool is_cc = event.Summary()->ProcInfo().IsWeakCC();
  if(!is_qe || !is_cc) return 1.;

  const Target & target = event.Summary()->InitState().Tgt();
  if (!target.IsNucleus()) {
	  return 0.;
	}
	//_______________________________________________________________________________________
	double GReWeightFGM::RewCCQEPauliSupViaKF(const EventRecord & event) 
	{
	  bool kF_tweaked = (TMath::Abs(fKFTwkDial) > controls::kASmallNum);
	  if(!kF_tweaked) return 1.;
	
	  bool is_qe = event.Summary()->ProcInfo().IsQuasiElastic();
	  bool is_cc = event.Summary()->ProcInfo().IsWeakCC();
	  if(!is_qe || !is_cc) return 1.;
	
	  const Target & target = event.Summary()->InitState().Tgt();
	  if (!target.IsNucleus()) {
	  GHepParticle * tgt = event.TargetNucleus();
  GHepParticle * tgtnucleus = event.TargetNucleus();
  if(!tgtnucleus) return 1.; // scattering off free-nucleon 

  GHepParticle * hitnucleon = event.HitNucleon();
  if(!hitnucleon) return 1.;

  const double kPmax = 0.5;
  double p = hitnucleon->P4()->Vect().Mag();
  if(p > kPmax) return 1.;

	  if(!tgt) return 1.; // scattering off free-nucleon 
	
	  GHepParticle * hitnuc = event.HitNucleon();
	  if(!hitnuc) return 1.;
	
	  const double kPmax = 0.5;
	  double p = hitnuc->P4()->Vect().Mag();
	  if(p > kPmax) return 1.;
	
  int tgtpdg = tgtnucleus -> Pdg();
  int nucpdg = hitnucleon -> Pdg();

	  int tgtpdg = tgt    -> Pdg();
	  int nucpdg = hitnuc -> Pdg();
	


ReWeight/GReWeightFZone.cxx
	 Copyright (c) 2003-2013, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightFZone::CalcChisq(void)
	{
	  double chisq = TMath::Power(fFZoneTwkDial, 2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightINuke.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_INUKE_DEBUG_NTP_
	
	double GReWeightINuke::CalcChisq(void)
	{
	  return fINukeRwParams.ChisqPenalty();
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightINukeParams.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReWeight/GReWeightIOBranchDesc.cxx


ReWeight/GReWeightIORecord.cxx


ReWeight/GReWeightNonResonanceBkg.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightNonResonanceBkg::CalcChisq()
	{
	  double chisq = 0.;
	  map<GSyst_t,double>::const_iterator it = fRTwkDial.begin();
	  for( ; it != fRTwkDial.end(); ++it) {
	    double twk_dial = it->second;
	    chisq += TMath::Power(twk_dial, 2.);
	  }
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecCCQE.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_CCQE_DEBUG_
	
	double GReWeightNuXSecCCQE::CalcChisq()
	{
	  double chisq = 0.;
	  if(fMode==kModeMa) {   
	     chisq += TMath::Power(fMaTwkDial, 2.);
	  }
	  else
	  if(fMode==kModeNormAndMaShape) { 
	     chisq += TMath::Power(fNormTwkDial, 2.);
	     chisq += TMath::Power(fMaTwkDial,   2.);
	  }
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecCCQEvec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_CCQE_VEC_DEBUG_
	
	double GReWeightNuXSecCCQEvec::CalcChisq()
	{
	  double chisq = TMath::Power(fFFTwkDial, 2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecCCRES.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_CCRES_DEBUG_
	
	double GReWeightNuXSecCCRES::CalcChisq()
	{
	  double chisq = 0.;
	  if(fMode==kModeMaMv) {   
	     chisq += TMath::Power(fMaTwkDial, 2.);
	     chisq += TMath::Power(fMvTwkDial, 2.);
	  }
	  else
	  if(fMode==kModeNormAndMaMvShape) { 
	     chisq += TMath::Power(fNormTwkDial, 2.);
	     chisq += TMath::Power(fMaTwkDial,   2.);
	     chisq += TMath::Power(fMvTwkDial,   2.);
	  }
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecCOH.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightNuXSecCOH::CalcChisq()
	{
	  double chisq = 
	          TMath::Power(fMaTwkDial, 2.) +
	          TMath::Power(fR0TwkDial, 2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecDIS.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_DIS_DEBUG_
	
	double GReWeightNuXSecDIS::CalcChisq(void)
	{
	  double chisq = 
	      TMath::Power(fAhtBYTwkDial,  2.) +
	      TMath::Power(fBhtBYTwkDial,  2.) +
	      TMath::Power(fCV1uBYTwkDial, 2.) +
	      TMath::Power(fCV2uBYTwkDial, 2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecHelper.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReWeight/GReWeightNuXSecNC.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightNuXSecNC::CalcChisq(void)
	{
	  double chisq = TMath::Power(fNCTwkDial,  2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecNCEL.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_NCEL_DEBUG_
	
	double GReWeightNuXSecNCEL::CalcChisq()
	{
	  double chisq = 0;
	  chisq += TMath::Power(fMaTwkDial,   2.);
	  chisq += TMath::Power(fEtaTwkDial,  2.);
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightNuXSecNCRES.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	double GReWeightNuXSecNCRES::CalcChisq()
	{
	  double chisq = 0.;
	  if(fMode==kModeMaMv) {   
	     chisq += TMath::Power(fMaTwkDial, 2.);
	     chisq += TMath::Power(fMvTwkDial, 2.);
	  }
	  else
	  if(fMode==kModeNormAndMaMvShape) { 
	     chisq += TMath::Power(fNormTwkDial, 2.);
	     chisq += TMath::Power(fMaTwkDial,   2.);
	     chisq += TMath::Power(fMvTwkDial,   2.);
	  }
	  return chisq;
	}
	//_______________________________________________________________________________________


ReWeight/GReWeightResonanceDecay.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#define _G_REWEIGHT_RESDEC_DEBUG_
	
	double GReWeightResonanceDecay::CalcChisq(void)
	{
	  double chisq =
double GReWeightResonanceDecay::RewBR(const EventRecord & event)
{
  bool tweaked_br1gamma = (TMath::Abs(fBR1gammaTwkDial) > controls::kASmallNum);
  bool tweaked_br1eta   = (TMath::Abs(fBR1etaTwkDial)   > controls::kASmallNum);

  bool tweaked = (tweaked_br1gamma || tweaked_br1eta);
  if(!tweaked) return 1.;

  double wght = 1.;

  GSystUncertainty * uncertainty = GSystUncertainty::Instance();

  LOG("ReW", pDEBUG) << "Checking resonance decay mode.";

  GHepParticle * p = 0;
  TIter iter(&event);
	    TMath::Power(fBR1gammaTwkDial,       2.) +
	    TMath::Power(fBR1etaTwkDial,         2.) +
	    TMath::Power(fThetaDelta2NpiTwkDial, 2.);
	
	  return chisq;
	}
	//_______________________________________________________________________________________
	double GReWeightResonanceDecay::RewBR(const EventRecord & event)
	{
	  bool tweaked_br1gamma = (TMath::Abs(fBR1gammaTwkDial) > controls::kASmallNum);
	  bool tweaked_br1eta   = (TMath::Abs(fBR1etaTwkDial)   > controls::kASmallNum);
	
	  bool tweaked = (tweaked_br1gamma || tweaked_br1eta);
	  if(!tweaked) return 1.;
	
	  double wght = 1.;
	
	  GSystUncertainty * uncertainty = GSystUncertainty::Instance();
	
	  LOG("ReW", pDEBUG) << "Checking resonance decay mode.";
	
	  GHepParticle * p = 0;
	  TIter iter(&event);


ReWeight/GReWeightUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReWeight/GSystSet.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


ReWeight/GSystUncertainty.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


SingleKaon/AlamSimoAtharVacasSKPXSec2014.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	                  const Interaction * interaction, KinePhaseSpace_t kps) const
	{
	  // Check whether interaction is valid
              const Interaction * interaction, KinePhaseSpace_t /*kps*/) const
{
  // Check whether interaction is valid
  int nTargetNeutrons = target->N();
  
  // Initialisation begins here
  // --------------------------
	  int nTargetNeutrons = target->Z();
	  
	  // Initialisation begins here
	  // --------------------------


SingleKaon/AlamSimoAtharVacasSKXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


SingleKaon/SKHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


SingleKaon/SKInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


SingleKaon/SKKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


SingleKaon/SKPrimaryLeptonGenerator.cxx
	  Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
  Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/AppInit.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	//#include "Conventions/XmlParserStatus.h"
	#include "Messenger/Messenger.h"
	#include "Numerical/RandomGen.h"
#include <TSystem.h>

//#include "Conventions/XmlParserStatus.h"
#include "Messenger/Messenger.h"
#include "Numerical/RandomGen.h"
	
#include "Utils/StringUtils.h"

  // expand in case of embedded env var or ~
	  // file was specified & exists - load table
	  if(utils::system::FileExists(inpfile)) {
  string expandedinpfile = gSystem->ExpandPathName(inpfile.c_str());

  // file was specified & exists - load table
  if(utils::system::FileExists(expandedinpfile)) {
	    XSecSplineList * xspl = XSecSplineList::Instance();
	    XmlParserStatus_t status = xspl->LoadFromXml(inpfile);
	    if(status != kXmlOK) {
	      LOG("AppInit", pFATAL)
	         << "Problem reading file: " << inpfile;
	       gAbortingInErr = true;
	       exit(1);
	    }
	  } 
	
	  // file doesn't exist
	  else {
	    // if one was specified, report & exit
	    if(inpfile.size() > 0) {
	       LOG("AppInit", pFATAL)
	          << "Input cross-section file [" << inpfile << "] does not exist!";
	       gAbortingInErr = true;
	       exit(1);
	    } 
	    // if one was not specified, warn and decide whether to exit based on the
	    // input `require_table' flag
	    else {
	      if(!require_table) {
	         LOG("AppInit", pWARN) << "No cross-section file was specified in the application inputs";
	         LOG("AppInit", pWARN) << "If none is loaded, event generation might be inefficient";
	      } else {
	         LOG("AppInit", pFATAL) << "No cross-section file was specified in the application inputs";
	         LOG("AppInit", pFATAL) << "This is mandatory as, otherwise, event generation will be prohibitively inefficient";
	         gAbortingInErr = true;
	         exit(1);
	      }
	    }
	  }
	
	}
	//___________________________________________________________________________
	void genie::utils::app_init::MesgThresholds(string inp_file)
	{
	  if(inp_file.size() > 0) {
	     Messenger * m = Messenger::Instance();
	     bool ok = m->SetPrioritiesFromXmlFile(inp_file);
	     if(!ok) {
	       LOG("AppInit", pWARN) 
	          << "Could not load customized mesg thresholds from: " 
	          << inp_file;
	     }
	  }
	
	}
	//___________________________________________________________________________
	void genie::utils::app_init::CacheFile(string inp_file)
	{
	  if(inp_file.size() > 0) {
	    Cache::Instance()->OpenCacheFile(inp_file);
	  }
	}
	//___________________________________________________________________________
	
    xspl = XSecSplineList::Instance();
    XmlParserStatus_t status = xspl->LoadFromXml(expandedinpfile);
    if(status != kXmlOK) {
      LOG("AppInit", pFATAL)
         << "Problem reading file: " << expandedinpfile;
       gAbortingInErr = true;
       exit(1);
    }
  } 

  // file doesn't exist
  else {
    // if one was specified, report & exit
    if(inpfile.size() > 0) {
       LOG("AppInit", pFATAL)
          << "Input cross-section file [" << inpfile << "] does not exist!";
       gAbortingInErr = true;
       exit(1);
    } 
    // if one was not specified, warn and decide whether to exit based on the
    // input `require_table' flag
    else {
      if(!require_table) {
         LOG("AppInit", pWARN) << "No cross-section file was specified in the application inputs";
         LOG("AppInit", pWARN) << "If none is loaded, event generation might be inefficient";
      } else {
         LOG("AppInit", pFATAL) << "No cross-section file was specified in the application inputs";
         LOG("AppInit", pFATAL) << "This is mandatory as, otherwise, event generation will be prohibitively inefficient";
         gAbortingInErr = true;
         exit(1);
      }
    }
  }

}
//___________________________________________________________________________
void genie::utils::app_init::MesgThresholds(string filelist)
{
  std::vector<std::string> files = genie::utils::str::Split(filelist,":;,");
  for (size_t i=0; i < files.size(); ++i ) {
    std::string inp_file = files[i];
    if(inp_file.size() > 0) {
      Messenger * m = Messenger::Instance();
      bool ok = m->SetPrioritiesFromXmlFile(inp_file);
      if(!ok) {
        LOG("AppInit", pWARN) 
          << "Could not load customized mesg thresholds from: " 
          << inp_file;
      }
    }
  }

}
//___________________________________________________________________________
void genie::utils::app_init::CacheFile(string inp_file)
{
  if(inp_file.size() > 0) {
    Cache::Instance()->OpenCacheFile(inp_file);
  }
}
//___________________________________________________________________________



Utils/BWFunc.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/CacheBranchFx.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/CacheBranchNtp.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/Cache.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/CmdLnArgParser.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/ConfigIsotopeMapUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/FragmRecUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/GArray.cxx


Utils/GSimFiles.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	         University of Liverpool & STFC Rutherford Appleton Lab
	
	 For the class documentation see the corresponding header file.
	
	 Important revisions after version 2.0.0 :
	 @ Oct 13, 2009 - CA
	   This class was first added in version 2.5.1
	*/
	//____________________________________________________________________________
	
	#include <cstdlib>
	
	#include "libxml/parser.h"
	#include "libxml/xmlmemory.h"
	#include "libxml/xmlreader.h"
	
	#include "Messenger/Messenger.h"
	#include "Utils/GSimFiles.h"
	#include "Utils/StringUtils.h"
	
         University of Liverpool & STFC Rutherford Appleton Laboratory

 For the class documentation see the corresponding header file.
*/
//____________________________________________________________________________

#include <cstdlib>

#include "libxml/parser.h"
#include "libxml/xmlmemory.h"
#include "libxml/xmlreader.h"

#include "Messenger/Messenger.h"
#include "Utils/GSimFiles.h"
#include "Utils/StringUtils.h"

int GSimFiles::FindModelID(string tag) const
{
  int imodel = 0;
	string GSimFiles::ModelTag(int imodel) const
	{
	  return (*fModelTag)[imodel];
	}
	//____________________________________________________________________________
	TFile* GSimFiles::XSecFile(int imodel) const
	{
	  return (*fXSecFile)[imodel];
	}
	//____________________________________________________________________________
	string GSimFiles::XSecFileName(int imodel) const
	{
	  return (*fXSecFileName)[imodel];
	}
	//____________________________________________________________________________
	TChain* GSimFiles::EvtChain(int imodel) const
	{
	  return (*fEvtChain)[imodel];
	}
	//____________________________________________________________________________
  vector<string>::const_iterator it = fModelTag->begin();
  for( ; it != fModelTag->end(); ++it) {
    if(*it == tag) return imodel;
    imodel++;
  }
  return -1;
}
//____________________________________________________________________________
string GSimFiles::ModelTag(int imodel) const
{
  return (*fModelTag)[imodel];
}
//____________________________________________________________________________
TFile* GSimFiles::XSecFile(int imodel) const
{
  return (*fXSecFile)[imodel];
}
//____________________________________________________________________________
string GSimFiles::XSecFileName(int imodel) const
{
  return (*fXSecFileName)[imodel];
}
//____________________________________________________________________________
TChain* GSimFiles::EvtChain(int imodel) const
{
  return (*fEvtChain)[imodel];
}
//____________________________________________________________________________
	bool GSimFiles::LoadFromFile(string xmlfile)
	{
const string & GSimFiles::PathToXMLFile(void) const
{
	  LOG("GSimFiles", pNOTICE) << "Loading: " << xmlfile;
	
   return fPath2XMLFile;
}
//____________________________________________________________________________
bool GSimFiles::LoadFromFile(string xmlfile)
{
  LOG("GSimFiles", pNOTICE) << "Loading: " << xmlfile;

	
  
  fPath2XMLFile = xmlfile;

	  for(int imodel=0; imodel < this->NModels(); imodel++) {
  stream << "loaded from path: " << fPath2XMLFile << endl;
  for(int imodel=0; imodel < this->NModels(); imodel++) {

	}
	//____________________________________________________________________________
  fPath2XMLFile = "";

}
//____________________________________________________________________________
	}
	//____________________________________________________________________________
	
   fPath2XMLFile = "";

}
//____________________________________________________________________________



Utils/GSLUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/GUIUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/HadXSUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	
	*/
	//____________________________________________________________________________
	
	#include <TMath.h>
	
	#include "Conventions/Constants.h"
	#include "Conventions/Units.h"
	#include "Utils/HadXSUtils.h"
	
 @ Jul 18, 2013 - Daniel Scully
 Added pion-nucleon cross-sections from C. Berger, provided via D. Cherdack
*/
//____________________________________________________________________________

#include <TMath.h>

#include "Conventions/Constants.h"
#include "Conventions/Units.h"
#include "Utils/HadXSUtils.h"

double genie::utils::hadxs::InelasticPionNucleonXSec(double Epion,
    bool isChargedPion)
{
	double genie::utils::hadxs::InelasticPionNucleonXSec(double Epion)
	{
	  double Epion2 = TMath::Power(Epion,2);
  double mpi  = kPionMass;
  double mpi2 = kPionMass2;
	  double P      = TMath::Sqrt( TMath::Max(0.,Epion2-kPionMass2) );
	
  if (!isChargedPion) {
	  if(P<=0) return 0;
	
	  double log10P  = TMath::Log10(P);
	  int    N = (int) ((log10P - kInelMinLog10P)/kIneldLog10P) + 1;
	
	  double xs=0.;
	  if ((log10P - kInelMinLog10P) < 0.0) xs = (P/0.1059)*kInelSig[0];
	  else if (N>kInelNDataPoints-2) xs = kInelSig[kInelNDataPoints-1];
	  else {
	   double log10Pn = kInelMinLog10P +  (N-1) * kIneldLog10P;
	   double delta   = (kInelSig[N]-kInelSig[N-1])/kIneldLog10P;
    mpi  = kPi0Mass;
    mpi2 = mpi * mpi;
  }
  double Epion2 = TMath::Power(Epion,2);
  double P      = TMath::Sqrt( TMath::Max(0.,Epion2-mpi2) );

  if(P<=0) return 0;

  double log10P  = TMath::Log10(P);
  int    N = (int) ((log10P - kInelMinLog10P)/kIneldLog10P) + 1;

  double xs=0.;
  if ((log10P - kInelMinLog10P) < 0.0) xs = (P/0.1059)*kInelSig[0];
  else if (N>kInelNDataPoints-2) xs = kInelSig[kInelNDataPoints-1];
  else {
   double log10Pn = kInelMinLog10P +  (N-1) * kIneldLog10P;
   double delta   = (kInelSig[N]-kInelSig[N-1])/kIneldLog10P;
double genie::utils::hadxs::TotalPionNucleonXSec(double Epion,
    bool isChargedPion)
{
	double genie::utils::hadxs::TotalPionNucleonXSec(double Epion)
	{
	  double Epion2 = TMath::Power(Epion,2);
  double mpi  = kPionMass;
  double mpi2 = kPionMass2;
	  double P      = TMath::Sqrt( TMath::Max(0.,Epion2-kPionMass2) );
	
  if (!isChargedPion) {
	  if(P<=0) return 0;
	
	  double log10P  = TMath::Log10(P);
	  int    N = (int) ((log10P - kInelMinLog10P)/kIneldLog10P) + 1;
	
	  double xs=0.;
	  if ((log10P - kInelMinLog10P) < 0.0) xs = (P/0.1059)*kTotSig[0];
	  else if (N>kInelNDataPoints-2) xs = kTotSig[kInelNDataPoints-1];
	  else {
	   double log10Pn = kTotMinLog10P +  (N-1) * kTotdLog10P;
	   double delta   = (kTotSig[N]-kTotSig[N-1])/kTotdLog10P;
    mpi  = kPi0Mass;
    mpi2 = mpi * mpi;
  }
  double Epion2 = TMath::Power(Epion,2);
  double P      = TMath::Sqrt( TMath::Max(0.,Epion2-mpi2) );

  if(P<=0) return 0;

  double log10P  = TMath::Log10(P);
  int    N = (int) ((log10P - kInelMinLog10P)/kIneldLog10P) + 1;

  double xs=0.;
  if ((log10P - kInelMinLog10P) < 0.0) xs = (P/0.1059)*kTotSig[0];
  else if (N>kInelNDataPoints-2) xs = kTotSig[kInelNDataPoints-1];
  else {
   double log10Pn = kTotMinLog10P +  (N-1) * kTotdLog10P;
   double delta   = (kTotSig[N]-kTotSig[N-1])/kTotdLog10P;
	
double genie::utils::hadxs::berger::InelasticPionNucleonXSec(double Epion, 
    bool isChargedPion)
{
  const double total = PionNucleonXSec(Epion, true, isChargedPion);
  const double elastic = PionNucleonXSec(Epion, false, isChargedPion);
  return (total - elastic);
}
//____________________________________________________________________________
double genie::utils::hadxs::berger::TotalPionNucleonXSec(double Epion, 
    bool isChargedPion)
{
  return PionNucleonXSec(Epion, true, isChargedPion);
}
//____________________________________________________________________________
double genie::utils::hadxs::berger::PionNucleonXSec(double Epion, bool get_total, 
    bool isChargedPion)
{
  // Convert inputs from Genie to those expected by Berger's code:

  double mpi  = kPionMass;
  double mpi2 = kPionMass2;
  if (!isChargedPion) {
    mpi  = kPi0Mass;
    mpi2 = mpi * mpi;
  }
  
  double Epion2 = TMath::Power(Epion,2);
  double ppi = TMath::Sqrt( TMath::Max(0., Epion2 - mpi2) );
  
  if( ppi <= 0.0 ) return 0.0;
  
  int out;
  if( get_total ) out = 0;  // Total pion-nucleon cross-section
  else out = 1;             // Elastic pion-nucleon cross-section
  
  const double M_pi = mpi;        // TODO: used to be kPionMass prior to charge checks
  const double M_p = kProtonMass; // TODO: should be kNucleonMass  ??
  const double pi = kPi;
  
  // Now this is the Berger's code...
  
  double afit=1.0;
  double afit2=1.9;
  double afit3=0.27;
  double afit4=0.34;
  double afit5=0.75;
  double afit6=1.7;

  double epi = TMath::Sqrt(M_pi*M_pi + ppi*ppi);
  double sx  = M_p*M_p + M_pi*M_pi + 2.0 * epi * M_p;
  double Wx  = TMath::Sqrt(sx);

  double s12x   = TMath::Sqrt((sx - TMath::Power((M_pi+M_p),2)) * (sx - (M_pi-M_p)*(M_pi-M_p)));
  double ppistx = s12x/2.0/Wx;

  double Wdel  = 1.232;
  double arg1  = (Wdel*Wdel - (M_p + M_pi)*(M_p + M_pi))*(Wdel*Wdel - (M_p -M_pi)*(M_p -M_pi));
  if(arg1<=0) arg1 = 0.0;
  double gamx  = 0.15 * TMath::Power((6.0*ppistx),3) / (1.0 + (6*ppistx)*(6*ppistx));
  double bwnrx = 1.0 / (4.0*(Wx - Wdel)*(Wx - Wdel) + gamx*gamx);
  double f1x   = afit * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gamx*gamx * bwnrx;
  double f4x   = afit4 * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gamx*gamx * bwnrx;

  double Wres2  = 1.98;
  double Gres2  = 0.6;
  double arg2   = (Wres2*Wres2 - (M_p+M_pi)*(M_p+M_pi)) * (Wres2*Wres2 - (M_p - M_pi)*(M_p - M_pi));
  if(arg2<=0) arg2 = 0.0;
  double pp2    = TMath::Sqrt(arg2)/2.0/Wres2;
  double gam2x  = Gres2 * TMath::Power((ppistx/pp2),3);
  double bwnr2x = 1.0 / (4.0 * (Wx-Wres2)*(Wx-Wres2) + gam2x*gam2x);
  double f2x    = afit2 * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gam2x*gam2x * bwnr2x;

  double Wres3  = 1.7;
  double Gres3  = 0.27;
  double arg3   = (Wres3*Wres3 - (M_p+M_pi)*(M_p+M_pi)) * (Wres3*Wres3 - (M_p - M_pi)*(M_p - M_pi));
  if(arg3<=0) arg3 = 0.0;
  double pp3    = TMath::Sqrt(arg3)/2.0/Wres3;
  double gam3x  = Gres3 * TMath::Power((ppistx/pp3),3);
  double bwnr3x = 1.0 / (4.0 * (Wx-Wres3)*(Wx-Wres3) + gam3x*gam3x);
  double f3x    = afit3 * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gam3x*gam3x * bwnr3x;

  double Wres5  = 1.52;
  double Gres5  = 0.10;
  double arg5   = (Wres5*Wres5 - (M_p+M_pi)*(M_p+M_pi)) * (Wres5*Wres5 - (M_p - M_pi)*(M_p - M_pi));
  if(arg5<=0) arg5 = 0.0;
  double pp5    = TMath::Sqrt(arg5)/2.0/Wres5;
  double gam5x  = Gres5 * (ppistx/pp5);
  double bwnr5x = 1.0 / (4.0 * (Wx-Wres5)*(Wx-Wres5) + gam5x*gam5x);
  double f5x    = afit5 * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gam5x*gam5x * bwnr5x;

  double Wres6  = 1.69;
  double Gres6  = 0.140;
  double arg6   = (Wres6*Wres6 - (M_p+M_pi)*(M_p+M_pi)) * (Wres6*Wres6 - (M_p - M_pi)*(M_p - M_pi));
  if(arg6<=0) arg6 = 0.0;
  double pp6    = TMath::Sqrt(arg6)/2.0/Wres6;
  double gam6x  = Gres6 * (ppistx/pp6);
  double bwnr6x = 1.0 / (4.0 * (Wx-Wres6)*(Wx-Wres6) + gam6x*gam6x);
  double f6x    = afit6 * 0.3892 * 8.0 * pi / (ppistx*ppistx) * gam6x*gam6x * bwnr6x;

  double output = -9999.99;
  if(out==0){
    double bgplusx  = 0.834 * ppi + 1.77 * ppi*ppi;
    double sigplusx = f1x + 0.86 * f2x + 0.7 * f3x + bgplusx;
    if(ppi>1.9) sigplusx = 20.1 + 15.4 / TMath::Sqrt(ppi);
    double bgminx  = 17.8 * ppi + 6.22 * ppi*ppi - 3.1 * ppi*ppi*ppi;
    double sigminx = 0.94 * f4x + 0.65 *f5x + 0.61 * f6x + bgminx;
    if(ppi>1.2) sigminx = 21.64 + 17.29 / TMath::Sqrt(ppi);
    double sigma_t = (sigplusx + sigminx) / 2.0;
    output = sigma_t;
  }else if(out==1){
    double sgpelx = f1x + 0.411 * f2x;
    if(ppi>1.9) sgpelx = 2.38 + 17.55 / ppi;
    double sgmelx = 0.275 * f4x + 0.268 * f5x + 0.281 * f6x + 11.83 * ppi - 3.39 * ppi*ppi;
    if(ppi>1.5) sgmelx = 3.4 + 11.35 / ppi;
    double sigma_el = (sgpelx + sgmelx) / 2.0;
    output = sigma_el;
  }
  
  // Berger's code over, convert to Genie units and return
  return (output * units::mb);
}
//____________________________________________________________________________
// Berger code for calculating the pion-Carbon xsec. If A is not 12 the restults are extrapolated to a nucleus of size A.
int genie::utils::hadxs::berger::PionNucleusXSec(double tpi, double ppistar, double t_new, double A, double &tpilow, double &siglow, double &tpihigh, double &sighigh){

  //Berger code for Tpi<=1.0
  //Returns the entire dsigma(pi + N -> pi + N)/dt term based on pi-Carbon scattering data
  double binedges[13] = {0.000, 0.076, 0.080, 0.100, 0.148, 0.162, 0.226, 0.486, 0.584, 0.662, 0.766, 0.870, 1.000};
  double parones[13]  = {0.0, 11600.0, 14700.0, 18300.0, 21300.0, 22400.0, 16400.0, 5730.0, 4610.0, 4570.0, 4930.0, 5140.0, 5140.0};
  double partwos[13]  = {0.0, 116.0, 109.0, 89.8, 91.0, 89.2, 80.8, 54.6, 55.2, 58.4, 60.5, 62.2, 62.2};
  double factors[13]  = {0.0, 0.1612, 0.1662, 0.1906, 0.2452, 0.2604, 0.3273, 0.5784, 0.6682, 0.7384, 0.8304, 0.9206, 0.9206};

  if(tpi>binedges[12]) return 1;
  int btu = 1;
  while(true){
    if(tpi>binedges[btu]) btu++;
    else                  break;
  }
  btu--;
  if(btu<0) btu = 0;

  tpilow  = binedges[btu];
  tpihigh = binedges[btu + 1];

  double dsigdzlow = -9999.99;
  if(btu==0) dsigdzlow = 0.0;
  else       dsigdzlow = 2.0 * factors[btu]*factors[btu]
    * parones[btu]*TMath::Power(A/12.0,1.3333333)
      * TMath::Exp( -1.0 * partwos[btu]*TMath::Power(A/12.0,0.6666666) * t_new * factors[btu]*factors[btu] / (ppistar*ppistar) );
  siglow = dsigdzlow;

  double dsigdzhigh = -9999.99;
  btu++;
  if(btu>12) btu        = 12;
  if(btu==0) dsigdzhigh = 0.0;
  else       dsigdzhigh = 2.0 * factors[btu]*factors[btu]
    * parones[btu]*TMath::Power(A/12.0,1.3333333)
      * TMath::Exp( -1.0 * partwos[btu]*TMath::Power(A/12.0,0.6666666) * t_new * factors[btu]*factors[btu] / (ppistar*ppistar) );
  sighigh = dsigdzhigh;

  return 0;
}
//_____________________________________________________________________________


Utils/KineUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  // transformation: {Q2,y}|E -> {x,y}|E
  //
  else
  if ( TransformMatched(fromps,tops,kPSQ2yfE,kPSxyfE,forward) )
  {
    const InitialState & init_state = i->InitState();
    double Ev = init_state.ProbeE(kRfHitNucRest);
    double M  = init_state.Tgt().HitNucP4Ptr()->M();
    double y  = kine.y();
    J = 2*y*Ev*M;
  }

  //
	  double Mn2 = Mn * Mn;
	  double mlep2 = mlep * mlep;
	  double s = Mn2 + 2.0 * Mn * Ev;
	  double W2min = CohW2Min(Mn, mpi);
	  
	  // Looks like Q2min = A * B - C
	  double A = (s - Mn * Mn) / 2.0;
	  double a = 1.0;
	  double b = mlep2 / s;
	  double c = W2min / s;
	  double lambda = a * a + b * b + c * c - 2.0 * a * b - 2.0 * a * c - 2.0 * b * c;
	  double B = 1 - TMath::Sqrt(lambda);
	  double C = 0.5 * (W2min + mlep2 - Mn2 * (W2min - mlep2) / s );
	
	  Range1D_t Q2;
	  Q2.min = A * B - C;
	  Q2.max = std::numeric_limits<double>::max();  // Value must be overriden in user options
	  return Q2;
	}
	//____________________________________________________________________________
	Range1D_t genie::utils::kinematics::Cohq2Lim(double Mn, double mpi, double mlep, double Ev)
	{
	  Range1D_t Q2 = utils::kinematics::CohQ2Lim(Mn, mpi, mlep, Ev);
	  Range1D_t q2;
	  q2.min = - Q2.max;
	  q2.max = - Q2.min;
	  return q2;
	}
	//____________________________________________________________________________
	Range1D_t genie::utils::kinematics::CohW2Lim(double Mn, double mpi, double mlep, 
	    double Ev, double Q2)
	{
	  Range1D_t W2l;
  // The expressions for Q^2 min appears in PRD 74, 054007 (2006) by 
  // Kartavtsev, Paschos, and Gounaris

  Range1D_t Q2;
  Q2.min = 0.0;
  Q2.max = std::numeric_limits<double>::max();  // Value must be overriden in user options

  double Mn2 = Mn * Mn;
  double mlep2 = mlep * mlep;
  double s = Mn2 + 2.0 * Mn * Ev;
  double W2min = CohW2Min(Mn, mpi);
  
  // Looks like Q2min = A * B - C, where A, B, and C are complicated
  double a = 1.0;
  double b = mlep2 / s;
  double c = W2min / s;
  double lambda = a * a + b * b + c * c - 2.0 * a * b - 2.0 * a * c - 2.0 * b * c;
  if (lambda > 0) {
    double A = (s - Mn * Mn) / 2.0;
    double B = 1 - TMath::Sqrt(lambda);
    double C = 0.5 * (W2min + mlep2 - Mn2 * (W2min - mlep2) / s );
    if (A * B - C < 0) {
      SLOG("KineLimits", pERROR) 
        << "Q2 kinematic limits calculation failed for CohQ2Lim. "
        << "Assuming Q2min = 0.0";
    }
    Q2.min = TMath::Max(0., A * B - C);
  } else {
    SLOG("KineLimits", pERROR) 
      << "Q2 kinematic limits calculation failed for CohQ2Lim. "
      << "Assuming Q2min = 0.0";
  }

  return Q2;
}
//____________________________________________________________________________
Range1D_t genie::utils::kinematics::Cohq2Lim(double Mn, double mpi, double mlep, double Ev)
{
  Range1D_t Q2 = utils::kinematics::CohQ2Lim(Mn, mpi, mlep, Ev);
  Range1D_t q2;
  q2.min = - Q2.max;
  q2.max = - Q2.min;
  return q2;
}
//____________________________________________________________________________
Range1D_t genie::utils::kinematics::CohW2Lim(double Mn, double mpi, double mlep, 
    double Ev, double Q2)
{
  // These expressions for W^2 min and max appear in PRD 74, 054007 (2006) by
  // Kartavtsev, Paschos, and Gounaris

  Range1D_t W2l;
	  double T1 = 0.25 * s * s * Mnterm * Mnterm * Mlterm;
	  double T2 = Q2 - (0.5 * s * Mnterm) + (0.5 * mlep * mlep * Mnterm);
	
  // Here T1, T2 are generically "term 1" and "term 2" in a long expression
  double T1 = 0.25 * s * s * Mnterm * Mnterm * Mlterm;
  double T2 = Q2 - (0.5 * s * Mnterm) + (0.5 * mlep * mlep * Mnterm);

	  return (Mn + mpi) * (Mn + mpi);
	}
	//____________________________________________________________________________
	// Kinematical Transformations:
	//____________________________________________________________________________
	double genie::utils::kinematics::Q2toQD2(double Q2)
	{
	// Q2 -> QD2 transformation. QD2 takes out the dipole form of the form factors
	// making the differential cross section to be flatter and speeding up the
	// kinematical selection.
	
	  assert(Q2>0);
	  return TMath::Power(1+Q2/controls::kMQD2, -1);
	}
	//____________________________________________________________________________
	double genie::utils::kinematics::QD2toQ2(double QD2)
	{
	  assert(QD2>0);
	  return controls::kMQD2*(1/QD2-1);
	}
	//____________________________________________________________________________
	double genie::utils::kinematics::Q2(const Interaction * const interaction)
	{
	// Get Q^2 from kinematics object
	// If Q^2 is not set but x,y are, then compute Q2 from x,y
	
	  const Kinematics & kinematics = interaction->Kine();
	
	  if (kinematics.KVSet(kKVQ2) || kinematics.KVSet(kKVq2)) {
	    double Q2 = kinematics.Q2();
	    return Q2;
	  }
	  if (kinematics.KVSet(kKVy)) {
	    const InitialState & init_state = interaction->InitState();
	    double Mn = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
	    double x  = kinematics.x();
	    double y  = kinematics.y();
	    double Ev = init_state.ProbeE(kRfHitNucRest);
	    double Q2 = 2*Mn*Ev*x*y;
	    return Q2;
	  }
	  SLOG("KineLimits", pERROR) << "Couldn't compute Q^2 for \n"<< *interaction;
	  return 0;
	}
	//____________________________________________________________________________
	double genie::utils::kinematics::W(const Interaction * const interaction)
	{
	  const ProcessInfo & process_info = interaction->ProcInfo();
	
	  if(process_info.IsQuasiElastic()) {
	    // hadronic inv. mass is equal to the recoil nucleon on-shell mass
	    int rpdgc = interaction->RecoilNucleonPdg();
	    double M = PDGLibrary::Instance()->Find(rpdgc)->Mass();
	    return M;
	  }
	
	  const Kinematics & kinematics = interaction->Kine();
	  if(kinematics.KVSet(kKVW)) {
	    double W = kinematics.W();
	    return W;
	  }
	  if(kinematics.KVSet(kKVx) && kinematics.KVSet(kKVy)) {
	    const InitialState & init_state = interaction->InitState();
	    double Ev = init_state.ProbeE(kRfHitNucRest);
	    double M  = init_state.Tgt().HitNucP4Ptr()->M(); 
	    double M2 = M*M;
	    double x  = kinematics.x();
	    double y  = kinematics.y();
	    double W2 = TMath::Max(0., M2 + 2*Ev*M*y*(1-x));
	    double W  = TMath::Sqrt(W2);
	    return W;
	  }
	  SLOG("KineLimits", pERROR) << "Couldn't compute W for \n"<< *interaction;
	  return 0;
	}
	//___________________________________________________________________________
  // These expressions for W^2 min and max appear in PRD 74, 054007 (2006) by
  // Kartavtsev, Paschos, and Gounaris

  return (Mn + mpi) * (Mn + mpi);
}
//____________________________________________________________________________
// Kinematical Transformations:
//____________________________________________________________________________
double genie::utils::kinematics::Q2toQD2(double Q2)
{
// Q2 -> QD2 transformation. QD2 takes out the dipole form of the form factors
// making the differential cross section to be flatter and speeding up the
// kinematical selection.

  assert(Q2>0);
  return TMath::Power(1+Q2/controls::kMQD2, -1);
}
//____________________________________________________________________________
double genie::utils::kinematics::QD2toQ2(double QD2)
{
  assert(QD2>0);
  return controls::kMQD2*(1/QD2-1);
}
//____________________________________________________________________________
double genie::utils::kinematics::Q2(const Interaction * const interaction)
{
// Get Q^2 from kinematics object
// If Q^2 is not set but x,y are, then compute Q2 from x,y

  const Kinematics & kinematics = interaction->Kine();

  if (kinematics.KVSet(kKVQ2) || kinematics.KVSet(kKVq2)) {
    double Q2 = kinematics.Q2();
    return Q2;
  }
  if (kinematics.KVSet(kKVy)) {
    const InitialState & init_state = interaction->InitState();
    double Mn = init_state.Tgt().HitNucP4Ptr()->M(); // can be off m/shell
    double x  = kinematics.x();
    double y  = kinematics.y();
    double Ev = init_state.ProbeE(kRfHitNucRest);
    double Q2 = 2*Mn*Ev*x*y;
    return Q2;
  }
  SLOG("KineLimits", pERROR) << "Couldn't compute Q^2 for \n"<< *interaction;
  return 0;
}
//____________________________________________________________________________
double genie::utils::kinematics::W(const Interaction * const interaction)
{
  const ProcessInfo & process_info = interaction->ProcInfo();

  if(process_info.IsQuasiElastic()) {
    // hadronic inv. mass is equal to the recoil nucleon on-shell mass
    int rpdgc = interaction->RecoilNucleonPdg();
    double M = PDGLibrary::Instance()->Find(rpdgc)->Mass();
    return M;
  }

  const Kinematics & kinematics = interaction->Kine();
  if(kinematics.KVSet(kKVW)) {
    double W = kinematics.W();
    return W;
  }
  if(kinematics.KVSet(kKVx) && kinematics.KVSet(kKVy)) {
    const InitialState & init_state = interaction->InitState();
    double Ev = init_state.ProbeE(kRfHitNucRest);
    double M  = init_state.Tgt().HitNucP4Ptr()->M(); 
    double M2 = M*M;
    double x  = kinematics.x();
    double y  = kinematics.y();
    double W2 = TMath::Max(0., M2 + 2*Ev*M*y*(1-x));
    double W  = TMath::Sqrt(W2);
    return W;
  }
  SLOG("KineLimits", pERROR) << "Couldn't compute W for \n"<< *interaction;
  return 0;
}
//___________________________________________________________________________


Utils/MathUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
         University of Liverpool & STFC Rutherford Appleton Lab 

 For documentation see the corresponding header file.

 Important revisions after version 2.0.0 :
 @ Feb 8, 2016 - CA
   Added Cholesky's method functions
*/
//____________________________________________________________________________

#include <float.h>

#include <TMath.h>

#include "Messenger/Messenger.h"
#include "Numerical/RandomGen.h"
#include "Utils/MathUtils.h"

//____________________________________________________________________________
TMatrixD genie::utils::math::CholeskyDecomposition(const TMatrixD& cov_matrix)
{
// Perform a Cholesky decomposition of the input covariance matrix and
// return the lower triangular matrix
//
   const double epsilon = 1E-12;

   int ncols = cov_matrix.GetNcols();
   int nrows = cov_matrix.GetNrows();

   assert(ncols==nrows);

   int n = nrows;

   TMatrixD L(n, n);

   for (int i = 0; i < n; ++i) {

     // calculate the diagonal term first
     L(i,i) = cov_matrix(i,i);
     for (int k = 0; k < i; ++k) {
        double tmp = L(k,i);
        L(i,i) -= tmp*tmp;
     }//k

     if(L(i,i) <= 0) {
       if(fabs(L(i,i)) < epsilon){
         L(i,i)=epsilon;
         LOG("Cholesky", pINFO) 
           << "Changed element (" << i << ", " << i << ") to " << L(i,i);
       }
       else{
         LOG("Cholesky", pERROR) 
            << "Decomposed covariance matrix not positive-definite";
         LOG("Cholesky", pERROR) 
            << "L(" << i << "," << i << ") = " << L(i,i);
         exit(1);
       }
     }
     L(i,i) = TMath::Sqrt(L(i,i));
     // then the off-diagonal terms
     for (int j = i+1; j < n; ++j) {
        L(i,j) = cov_matrix(i,j);
        for (int k = 0; k < i; ++k) {
           L(i,j) -= L(k,i)*L(k,j);
        }
        L(i,j) /= L(i,i);
     }//j
  }//i

  // create the transpose of L
  TMatrixD LT(TMatrixD::kTransposed,L);

  return LT;
}
//____________________________________________________________________________
TVectorD  genie::utils::math::CholeskyGenerateCorrelatedParams (
    const TMatrixD& cholesky_triangular, TVectorD& mean_params) 
{
// Generate a vector of correlated params

  int ncols = cholesky_triangular.GetNcols();
  int nrows = cholesky_triangular.GetNrows();
  int npars = mean_params.GetNrows();

  if(ncols != nrows) {
    LOG("Cholesky", pERROR) 
        << "Mismatch between number of columns (" << ncols 
        << ") & rows (" << nrows << ")";
    exit(1);
  }
  if(npars != nrows) {
    LOG("Cholesky", pERROR) 
        << "Mismatch between number of parameters (" << npars
        << ") & array size (" << nrows << ")";
    exit(1);
  }

  int n = nrows;

  // create a vector of unit Gaussian variables
  // and multiply by Lt to introduce the appropriate correlations
  TVectorD g(n);
  for (int k = 0; k < n; ++k) {
    g(k) = RandomGen::Instance()->RndNum().Gaus();
  }
  g *= cholesky_triangular;

  // add the mean value offsets and store the results
  TVectorD correlated_params(n);
  for (int i = 0; i < n; ++i) {
     double v = mean_params[i];
	         University of Liverpool & STFC Rutherford Appleton Lab - May 06, 2004
	
	 For documentation see the corresponding header file.
	
	 Important revisions after version 2.0.0 :
	
	*/
	//____________________________________________________________________________
	
	#include <float.h>
	
	#include <TMath.h>
	
	#include "Messenger/Messenger.h"
	#include "Utils/MathUtils.h"
	
	//____________________________________________________________________________
	double genie::utils::math::KahanSummation(double x[], unsigned int n)
	{
	// the Kahan summation algorithm - minimizes the error when adding a sequence
	// of finite precision floating point numbers (compensated summation)
	
	  double sum = x[0];
	  double c   = 0.0;
	  for(unsigned int i=1; i<n; i++) {
	    double y = x[i]-c;
	    double t = sum+y;
	    c   = (t-sum) - y;
	    sum = t;
	  }
	  return sum;
	}
	//____________________________________________________________________________
	double genie::utils::math::KahanSummation(const vector<double> & x)
	{
	// the Kahan summation algorithm - minimizes the error when adding a sequence
	// of finite precision floating point numbers (compensated summation)
	
	  double sum = x[0];
	  double c   = 0.0;
	  for(unsigned int i=1; i<x.size(); i++) {
	    double y = x[i]-c;
	    double t = sum+y;
	    c   = (t-sum) - y;
	    sum = t;
	  }
	  return sum;
	}
	//____________________________________________________________________________
	bool genie::utils::math::AreEqual(double x1, double x2)
	{
	  double err = 0.001*DBL_EPSILON;
	  double dx  = TMath::Abs(x1-x2);
	  if(dx<err) {
	    LOG("Math", pINFO) << x1 << " := " << x2;
	    return true;
	  }
	  return false;;
	}
	//____________________________________________________________________________
	bool genie::utils::math::AreEqual(float x1, float x2)
	{
	  float err = FLT_EPSILON;
	  float dx  = TMath::Abs(x1-x2);
	  if(dx<err) {
	    LOG("Math", pINFO) << x1 << " := " << x2;
	    return true;
	  }
	  return false;;
	}
	//____________________________________________________________________________
	bool genie::utils::math::IsWithinLimits(double x, Range1D_t range)
	{
	  return ( x >= range.min && x <= range.max );
	}
	//____________________________________________________________________________
	bool genie::utils::math::IsWithinLimits(float x, Range1F_t range)
	{
	  return ( x >= range.min && x <= range.max );
	}
	//____________________________________________________________________________
	bool genie::utils::math::IsWithinLimits(int i, Range1I_t range)
	{
	  return ( i >= range.min && i <= range.max );
	}
	//____________________________________________________________________________
	double genie::utils::math::NonNegative(double x)
	{
	// this is used to handle very small numbers in sqrts
	
	  return TMath::Max(0., x);
	}
	//____________________________________________________________________________
	double genie::utils::math::NonNegative(float x)
	{
	// this is used to handle very small numbers in sqrts
	
	  return TMath::Max( (float)0., x);
	}
	//____________________________________________________________________________
	
     v += g(i);
     correlated_params[i] = v;
  }

  return correlated_params;
}
//____________________________________________________________________________
TVectorD  genie::utils::math::CholeskyGenerateCorrelatedParams (
 const TMatrixD& cholesky_triangular, TVectorD& mean_params, TVectorD& g_uncorrelated) 
{
// Generate a vector of correlated params

  int ncols = cholesky_triangular.GetNcols();
  int nrows = cholesky_triangular.GetNrows();
  int npars = mean_params.GetNrows();
  int nunco = g_uncorrelated.GetNrows();

  if(ncols != nrows) {
    LOG("Cholesky", pERROR) 
        << "Mismatch between number of columns (" << ncols 
        << ") & rows (" << nrows << ")";
    exit(1);
  }
  if(npars != nrows) {
    LOG("Cholesky", pERROR) 
        << "Mismatch between number of parameters (" << npars
        << ") & array size (" << nrows << ")";
    exit(1);
  }
  if(nunco != nrows) {
    LOG("Cholesky", pERROR) 
        << "Mismatch between size of uncorrelated parameter vector (" << nunco
        << ") & array size (" << nrows << ")";
    exit(1);
  }

  int n = nrows;

  // create a vector of unit Gaussian variables
  // and multiply by Lt to introduce the appropriate correlations
  g_uncorrelated *= cholesky_triangular;

  // add the mean value offsets and store the results
  TVectorD correlated_params(n);
  for (int i = 0; i < n; ++i) {
     double v = mean_params[i];
     v += g_uncorrelated(i);
     correlated_params[i] = v;
  }

  return correlated_params;
}
//____________________________________________________________________________
TVectorD  genie::utils::math::CholeskyGenerateCorrelatedParamVariations (
    const TMatrixD& cholesky_triangular) 
{
  int ncols = cholesky_triangular.GetNcols();
  int nrows = cholesky_triangular.GetNrows();

  assert(ncols==nrows);

  int n = nrows;

  // create a vector of unit Gaussian variables
  // and multiply by Lt to introduce the appropriate correlations
  TVectorD g(n);
  for (int k = 0; k < n; ++k) {
    g(k) = RandomGen::Instance()->RndNum().Gaus();
  }
  g *= cholesky_triangular;

  return g;
}
//____________________________________________________________________________
TVectorD  genie::utils::math::CholeskyCalculateCorrelatedParamVariations (
    const TMatrixD& cholesky_triangular, TVectorD & g_uncorrelated) 
{
  int ncols = cholesky_triangular.GetNcols();
  int nrows = cholesky_triangular.GetNrows();
  int npars = g_uncorrelated.GetNrows();

  assert(ncols==nrows);
  assert(npars==nrows);

  // create a vector of unit Gaussian variables
  // and multiply by Lt to introduce the appropriate correlations
  TVectorD g(g_uncorrelated);
  g *= cholesky_triangular;

  return g;
}
//____________________________________________________________________________
double genie::utils::math::KahanSummation(double x[], unsigned int n)
{
// the Kahan summation algorithm - minimizes the error when adding a sequence
// of finite precision floating point numbers (compensated summation)

  double sum = x[0];
  double c   = 0.0;
  for(unsigned int i=1; i<n; i++) {
    double y = x[i]-c;
    double t = sum+y;
    c   = (t-sum) - y;
    sum = t;
  }
  return sum;
}
//____________________________________________________________________________
double genie::utils::math::KahanSummation(const vector<double> & x)
{
// the Kahan summation algorithm - minimizes the error when adding a sequence
// of finite precision floating point numbers (compensated summation)

  double sum = x[0];
  double c   = 0.0;
  for(unsigned int i=1; i<x.size(); i++) {
    double y = x[i]-c;
    double t = sum+y;
    c   = (t-sum) - y;
    sum = t;
  }
  return sum;
}
//____________________________________________________________________________
bool genie::utils::math::AreEqual(double x1, double x2)
{
  double err = 0.001*DBL_EPSILON;
  double dx  = TMath::Abs(x1-x2);
  if(dx<err) {
    LOG("Math", pINFO) << x1 << " := " << x2;
    return true;
  }
  return false;;
}
//____________________________________________________________________________
bool genie::utils::math::AreEqual(float x1, float x2)
{
  float err = FLT_EPSILON;
  float dx  = TMath::Abs(x1-x2);
  if(dx<err) {
    LOG("Math", pINFO) << x1 << " := " << x2;
    return true;
  }
  return false;;
}
//____________________________________________________________________________
bool genie::utils::math::IsWithinLimits(double x, Range1D_t range)
{
  return ( x >= range.min && x <= range.max );
}
//____________________________________________________________________________
bool genie::utils::math::IsWithinLimits(float x, Range1F_t range)
{
  return ( x >= range.min && x <= range.max );
}
//____________________________________________________________________________
bool genie::utils::math::IsWithinLimits(int i, Range1I_t range)
{
  return ( i >= range.min && i <= range.max );
}
//____________________________________________________________________________
double genie::utils::math::NonNegative(double x)
{
// this is used to handle very small numbers in sqrts

  return TMath::Max(0., x);
}
//____________________________________________________________________________
double genie::utils::math::NonNegative(float x)
{
// this is used to handle very small numbers in sqrts

  return TMath::Max( (float)0., x);
}
//____________________________________________________________________________



Utils/NaturalIsotopes.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/NuclearUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/PhysUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/PREM.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/PrintUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
  PrintBanner(warn_dev_banner, 0);
#endif

#ifdef __GENIE_RELEASE_CANDIDATE__ 
	  PrintBanner(warn_dev_banner, 15000);
	#endif
	
	#ifdef __GENIE_RELEASE_CANDIDATE__ 
  PrintBanner(warn_rc_banner, 0);
#endif

	  PrintBanner(warn_rc_banner, 15000);
	#endif
	
  PrintBanner(main_banner, 0);
}
//___________________________________________________________________________
	  PrintBanner(main_banner, 1000);
	}
	//___________________________________________________________________________


Utils/Range1.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/RunOpt.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/StringUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
	string genie::utils::str::FilterString(string filt_elements, string input)
	{
	// filter out from 'input' all characters that can be found in 'filt_elements'
	
	  string filtered_string = input;
	  string::size_type pos = 0;
	
void genie::utils::str::ReplaceStringInPlace(
  string& subject, const string& search, const string& replace)
{
// Searches the string "input" for "search" and replaces this with "replace"
  size_t pos = 0;
	  while( (pos = filtered_string.find_first_of(
	                       filt_elements, pos)) != string::npos )
	                                                filtered_string.erase(pos,1);
	  return filtered_string;
	}
	//____________________________________________________________________________
	string genie::utils::str::ToUpper(string input)
	{
	  for(unsigned int i=0; i<input.size(); i++) input[i] = toupper(input[i]);
	  return input;
	}
	//____________________________________________________________________________
	string genie::utils::str::ToLower(string input)
	{
	  for(unsigned int i=0; i<input.size(); i++) input[i] = tolower(input[i]);
	  return input;
	}
	//____________________________________________________________________________
	const char * genie::utils::str::Concat(
	           const char * s1, const char * s2, const char * s3, const char * s4)
	{
	  ostringstream sstr;
	  sstr << s1 << s2;
	
	  if(s3) sstr << s3;
	  if(s4) sstr << s4;
	
	  return sstr.str().c_str();
	}
	//____________________________________________________________________________
	const char * genie::utils::str::Concat(const char * s1, bool b)
	{
	    ostringstream sstr;
	    sstr << s1;
	
	    if(b) sstr << "TRUE";
	    else  sstr << "FALSE";
	
	    return sstr.str().c_str();
	}
	//____________________________________________________________________________
	const char * genie::utils::str::Concat(const char * s1, int n)
	{
	  ostringstream sstr;
	  sstr << s1 << n;
	  return sstr.str().c_str();
	}
	//____________________________________________________________________________
	const char * genie::utils::str::Concat(const char * s1, double x)
	{
	  ostringstream sstr;
	  sstr << s1 << x;
	  return sstr.str().c_str();
	}
	//____________________________________________________________________________
	const char * genie::utils::str::Concat(const char * s1, float x)
	{
	  ostringstream sstr;
	  sstr << s1 << x;
	  return sstr.str().c_str();
	}
	//____________________________________________________________________________
	
	
  while ((pos = subject.find(search, pos)) != std::string::npos) {
    subject.replace(pos, search.length(), replace);
    // move to end of replaced string
    pos += replace.length();
  }
}
//____________________________________________________________________________
string genie::utils::str::FilterString(string filt_elements, string input)
{
// filter out from 'input' all characters that can be found in 'filt_elements'

  string filtered_string = input;
  string::size_type pos = 0;

  while( (pos = filtered_string.find_first_of(
                       filt_elements, pos)) != string::npos )
                                                filtered_string.erase(pos,1);
  return filtered_string;
}
//____________________________________________________________________________
string genie::utils::str::ToUpper(string input)
{
  for(unsigned int i=0; i<input.size(); i++) input[i] = toupper(input[i]);
  return input;
}
//____________________________________________________________________________
string genie::utils::str::ToLower(string input)
{
  for(unsigned int i=0; i<input.size(); i++) input[i] = tolower(input[i]);
  return input;
}
//____________________________________________________________________________
const char * genie::utils::str::Concat(
           const char * s1, const char * s2, const char * s3, const char * s4)
{
  ostringstream sstr;
  sstr << s1 << s2;

  if(s3) sstr << s3;
  if(s4) sstr << s4;

  return sstr.str().c_str();
}
//____________________________________________________________________________
const char * genie::utils::str::Concat(const char * s1, bool b)
{
    ostringstream sstr;
    sstr << s1;

    if(b) sstr << "TRUE";
    else  sstr << "FALSE";

    return sstr.str().c_str();
}
//____________________________________________________________________________
const char * genie::utils::str::Concat(const char * s1, int n)
{
  ostringstream sstr;
  sstr << s1 << n;
  return sstr.str().c_str();
}
//____________________________________________________________________________
const char * genie::utils::str::Concat(const char * s1, double x)
{
  ostringstream sstr;
  sstr << s1 << x;
  return sstr.str().c_str();
}
//____________________________________________________________________________
const char * genie::utils::str::Concat(const char * s1, float x)
{
  ostringstream sstr;
  sstr << s1 << x;
  return sstr.str().c_str();
}
//____________________________________________________________________________




Utils/Style.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/SystemUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/T2KEvGenMetaData.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/UnitUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Utils/XmlParserUtils.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
         University of Liverpool & STFC Rutherford Appleton Lab

 For documentation see the corresponding header file.
*/
//____________________________________________________________________________

#include <sstream>

#include <TFile.h>
#include <TH1F.h>
#include <TH1D.h>
#include <TH2D.h>
#include <TVectorD.h>

#include "Messenger/Messenger.h"
#include "Utils/XmlParserUtils.h"

	         University of Liverpool & STFC Rutherford Appleton Lab - January 12, 2004
	
	 For documentation see the corresponding header file.
	
	 Important revisions after version 2.0.0 :
	
	*/
	//____________________________________________________________________________
	
	#include <sstream>
	
	#include "Utils/XmlParserUtils.h"
	
//____________________________________________________________________________
	// really only exists so that rootcint will add these to the dictionary
	
	
	//____________________________________________________________________________
	
	
xmlNodePtr genie::utils::xml::FindNode(xmlDocPtr xml_doc, string node_path)
{
  xmlNodePtr root_node = xmlDocGetRootElement(xml_doc);
  if(root_node==NULL) {
     LOG("XML", pERROR) << "Null root XML node";
     return NULL;
  }

  vector<string> node_path_vec = genie::utils::str::Split(node_path,"/");

  unsigned int ndepth = node_path_vec.size();
  unsigned int idepth = 0;

  xmlNodePtr curr_node = root_node; 

  while (curr_node != NULL) {
    if( (!xmlStrcmp(
       curr_node->name, (const xmlChar *) node_path_vec[idepth].c_str())) ) 
    {
        idepth++;
        if(idepth == ndepth) {
          return curr_node;
        } else {
          curr_node = curr_node->xmlChildrenNode;
        }
    }
    curr_node = curr_node->next;
  }

  xmlFree(curr_node);
  return NULL;
}
//____________________________________________________________________________
bool genie::utils::xml::GetBool(xmlDocPtr xml_doc, string node_path)
{
  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return false;
  }
  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );

  if(content == "true" || 
     content == "TRUE" || 
     content == "True" || 
     content == "on"   ||
     content == "ON"   ||
     content == "On"   ||
     content == "1"    || 
     content == "I") return true;

  if(content == "false" || 
     content == "FALSE" || 
     content == "False" ||
     content == "off"   ||
     content == "OFF"   ||
     content == "Off"   ||
     content == "0"     || 
     content == "O") return false;

  LOG("XML", pERROR) 
       << "Could not interpret content (" << content 
       << ") found at node_path: " << node_path << " as a boolean!";
  return false;
}
//____________________________________________________________________________
int genie::utils::xml::GetInt(xmlDocPtr xml_doc, string node_path)
{
  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return -999999;
  }
  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );
  int value = atoi(content.c_str());
  return value;
}
//____________________________________________________________________________
vector<int> genie::utils::xml::GetIntArray(xmlDocPtr xml_doc, string node_path)
{
  vector<int> array;

  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return array;
  }

  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );
  
  vector<string> str_tokens = genie::utils::str::Split(content, ",");
  vector<string>::const_iterator str_tokens_iter = str_tokens.begin();
  for( ; str_tokens_iter != str_tokens.end(); ++str_tokens_iter) {
     string token = genie::utils::str::TrimSpaces(*str_tokens_iter);
     if (not token.size() ) continue;
     array.push_back( atoi(token.c_str()) );
  }
  return array;
}
//____________________________________________________________________________
double genie::utils::xml::GetDouble(xmlDocPtr xml_doc, string node_path)
{
  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return -999999;
  }
  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );
  double value = atof(content.c_str());
  return value;
}
//____________________________________________________________________________
vector<double> 
  genie::utils::xml::GetDoubleArray(xmlDocPtr xml_doc, string node_path)
{
  vector<double> array;

  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return array;
  }

  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );
  
  vector<string> str_tokens = genie::utils::str::Split(content, ",");
  vector<string>::const_iterator str_tokens_iter = str_tokens.begin();
  for( ; str_tokens_iter != str_tokens.end(); ++str_tokens_iter) {
     string token = genie::utils::str::TrimSpaces(*str_tokens_iter);
     if (not token.size() ) continue;
     array.push_back( atof(token.c_str()) );
  }
  return array;
}
//____________________________________________________________________________
string genie::utils::xml::GetString(xmlDocPtr xml_doc, string node_path)
{
  xmlNodePtr node = genie::utils::xml::FindNode(xml_doc, node_path);
  if(node==NULL) {
    return "";
  }
  string content = genie::utils::xml::TrimSpaces( 
      xmlNodeListGetString(xml_doc, node->xmlChildrenNode, 1) );
  return content;
}
//____________________________________________________________________________
string genie::utils::xml::GetROOTFileName(xmlDocPtr xml_doc, string node_path)
{
  return genie::utils::xml::GetString(xml_doc, node_path+"/filename");
}
//____________________________________________________________________________
string genie::utils::xml::GetROOTObjName (xmlDocPtr xml_doc, string node_path)
{
  return genie::utils::xml::GetString(xml_doc, node_path+"/objname");
}
//____________________________________________________________________________
string genie::utils::xml::GetROOTObjType (xmlDocPtr xml_doc, string node_path)
{
  return genie::utils::xml::GetString(xml_doc, node_path+"/objtype");
}
//____________________________________________________________________________
TFile * genie::utils::xml::GetTFile(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  LOG("XML", pINFO) << "Reading info at XML node node_path: " << node_path;

  string filename = genie::utils::xml::GetROOTFileName(xml_doc,node_path);

  string used_base_dir = base_dir;
  if(base_dir.find("<env>") != string::npos) {
    used_base_dir = gSystem->Getenv("GENIE");
  }

  const char * full_filename = 
     Form("%s/%s", used_base_dir.c_str(), filename.c_str());
  TFile * file = new TFile(full_filename,"read");
  if(!file) {
    LOG("XML",pERROR) << "No file: " << full_filename << " found";
    return 0;
  }
  if(file->IsZombie()) {
    LOG("XML",pERROR) << "File is a zombie: " << full_filename;
    return 0;
  }

  return file;
}
//____________________________________________________________________________
TH1F * genie::utils::xml::GetTH1F(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  TFile * file = genie::utils::xml::GetTFile(xml_doc,node_path,base_dir);
  if(!file) return 0;

  string objname = genie::utils::xml::GetROOTObjName(xml_doc,node_path);
  TH1F * h = (TH1F*)file->Get(objname.c_str());
  if(!h) {
    LOG("XML",pERROR) << "No " << objname;
    file->Close();
    delete file;
    return 0;
  }

  TH1F * hcopy = new TH1F(*h);
  hcopy->SetDirectory(0);
  file->Close();
  delete file;

  return hcopy;
}
//____________________________________________________________________________
TH1D * genie::utils::xml::GetTH1D(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  TFile * file = genie::utils::xml::GetTFile(xml_doc,node_path,base_dir);
  if(!file) return 0;

  string objname = genie::utils::xml::GetROOTObjName(xml_doc,node_path);
  TH1D * h = (TH1D*)file->Get(objname.c_str());
  if(!h) {
    LOG("XML",pERROR) << "No " << objname;
    file->Close();
    delete file;
    return 0;
  }

  TH1D * hcopy = new TH1D(*h);
  hcopy->SetDirectory(0);
  file->Close();
  delete file;

  return hcopy;
}
//____________________________________________________________________________
TH2D * genie::utils::xml::GetTH2D(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  TFile * file = genie::utils::xml::GetTFile(xml_doc,node_path,base_dir);
  if(!file) return 0;

  string objname = genie::utils::xml::GetROOTObjName(xml_doc,node_path);
  TH2D * h = (TH2D*)file->Get(objname.c_str());
  if(!h) {
    LOG("XML",pERROR) << "No " << objname;
    file->Close();
    delete file;
    return 0;
  }

  TH2D * hcopy = new TH2D(*h);
  hcopy->SetDirectory(0);
  file->Close();
  delete file;

  return hcopy;
}
//____________________________________________________________________________
TVectorD * genie::utils::xml::GetTVectorD(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  TFile * file = genie::utils::xml::GetTFile(xml_doc,node_path,base_dir);
  if(!file) return 0;

  string objname = genie::utils::xml::GetROOTObjName(xml_doc,node_path);
  TVectorD * vec = (TVectorD*)file->Get(objname.c_str());
  if(!vec) {
    LOG("XML",pERROR) << "No " << objname;
    file->Close();
    delete file;
    return 0;
  }

  TVectorD * veccopy = new TVectorD(*vec);
  file->Close();
  delete file;

  return veccopy;
}
//____________________________________________________________________________
/*
TMatrixDSym * genie::utils::xml::GetTMatrixDSym(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  return 0;
}
//____________________________________________________________________________
TMatrixD * genie::utils::xml::GetTMatrixD(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  return 0;
}
//____________________________________________________________________________
TSpline3 * genie::utils::xml::GetTSpline3(
  xmlDocPtr xml_doc, string node_path, string base_dir)
{
  return 0;
}
//____________________________________________________________________________
*/


Utils/XSecSplineList.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration
        const Interaction * interaction, int nknots, double e_min, double e_max)
{
// Build a cross section spline for the input interaction using the input
	        const Interaction * interaction, int nknots, double Emin, double Emax)
	{
	// Build a cross section spline for the input interaction using the input
// to override the list-wide nknots,e_min,e_max

  double xsec[nknots];
  double E   [nknots];

  SLOG("XSecSplLst", pNOTICE)
     << "Creating cross section spline using the algorithm: " << *alg;

  string key = this->BuildSplineKey(alg,interaction);

  // If any of the nknots,e_min,e_max was not set or its value is not acceptable
	// to override the list-wide nknots,Emin,Emax
	
	  double xsec[nknots];
	  double E   [nknots];
	
	  SLOG("XSecSplLst", pNOTICE)
	     << "Creating cross section spline using the algorithm: " << *alg;
	
	  string key = this->BuildSplineKey(alg,interaction);
	
	  // If any of the nknots,Emin,Emax was not set or its value is not acceptable
  if (e_min   < 0.) e_min = this->Emin();
  if (e_max   < 0.) e_max = this->Emax();
	  if (Emin   < 0.) Emin   = this->Emin();
	  if (Emax   < 0.) Emax   = this->Emax();
  assert(e_min < e_max);

	  assert(Emin < Emax);
	
  // Distribute the knots in the energy range (e_min,e_max) :
	  // Distribute the knots in the energy range (Emin,Emax) :
  //   spline behaves correctly in (e_min,Ethr)
  // - Place 1 knot exactly on the input interaction threshold
  // - Place the remaining n-6 knots spaced either linearly or logarithmically 
  //   above the input interaction threshold
	  //   spline behaves correctly in (Emin,Ethr)
	  // - Place 1 knot exactly on the input interaction threshold
	  // - Place the remaining n-6 knots spaced either linearly or logarithmically 
	  //   above the input interaction threshold
  // The above scheme schanges appropriately if Ethr<e_min (i.e. no knots
  // are computed below threshold)
  //
  double Ethr = interaction->PhaseSpace().Threshold();
  SLOG("XSecSplLst", pNOTICE)
    << "Energy threshold for current interaction = " << Ethr << " GeV";

  int nkb = (Ethr>e_min) ? 5 : 0; // number of knots <  threshold
  int nka = nknots-nkb;          // number of knots >= threshold

  // knots < energy threshold
  double dEb =  (Ethr>e_min) ? (Ethr - e_min) / nkb : 0;
  for(int i=0; i<nkb; i++) {     
     E[i] = e_min + i*dEb;
  }
  // knots >= energy threshold
  double E0  = TMath::Max(Ethr,e_min);
  double dEa = 0;
  if(this->UseLogE())
    dEa = (TMath::Log10(e_max) - TMath::Log10(E0)) /(nka-1);
  else 
    dEa = (e_max-E0) /(nka-1);

  for(int i=0; i<nka; i++) {
     if(this->UseLogE())
       E[i+nkb] = TMath::Power(10., TMath::Log10(E0) + i * dEa);
     else  
       E[i+nkb] = E0 + i * dEa;
  }

  // Compute cross sections for the input interaction at the selected
  // set of energies
  //
  for (int i = 0; i < nknots; i++) {
	  // The above scheme schanges appropriately if Ethr<Emin (i.e. no knots
	  // are computed below threshold)
	  //
	  double Ethr = interaction->PhaseSpace().Threshold();
	  SLOG("XSecSplLst", pNOTICE)
	    << "Energy threshold for current interaction = " << Ethr << " GeV";
	
	  int nkb = (Ethr>Emin) ? 5 : 0; // number of knots <  threshold
	  int nka = nknots-nkb;          // number of knots >= threshold
	
	  // knots < energy threshold
	  double dEb =  (Ethr>Emin) ? (Ethr - Emin) / nkb : 0;
	  for(int i=0; i<nkb; i++) {     
	     E[i] = Emin + i*dEb;
	  }
	  // knots >= energy threshold
	  double E0  = TMath::Max(Ethr,Emin);
	  double dEa = 0;
	  if(this->UseLogE())
	    dEa = (TMath::Log10(Emax) - TMath::Log10(E0)) /(nka-1);
	  else 
	    dEa = (Emax-E0) /(nka-1);
	
	  for(int i=0; i<nka; i++) {
	     if(this->UseLogE())
	       E[i+nkb] = TMath::Power(10., TMath::Log10(E0) + i * dEa);
	     else  
	       E[i+nkb] = E0 + i * dEa;
	  }
	
	  // Compute cross sections for the input interaction at the selected
	  // set of energies
	  //
	  for (int i = 0; i < nknots; i++) {


VHE/GLRESGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VHE/GLRESInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VHE/GLRESPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/IBDHadronicSystemGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/IBDInteractionListGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/IBDKinematicsGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/IBDPrimaryLeptonGenerator.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/IBDXSecMap.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/KLVOxygenIBDPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


VLE/StrumiaVissaniIBDPXSec.cxx
	 Copyright (c) 2003-2015, GENIE Neutrino MC Generator Collaboration
 Copyright (c) 2003-2016, GENIE Neutrino MC Generator Collaboration


Algorithm/AlgCmp.h Algorithm/AlgConfigPool.h Algorithm/AlgFactory.h Algorithm/AlgId.h Algorithm/Algorithm.h Algorithm/AlgStatus.h Algorithm/LinkDef.h Algorithm/_ROOT_DICT_Algorithm.h AlvarezRuso/AlvarezRusoCOHPiPDXSec.h AlvarezRuso/AlvarezRusoCOHPiPXSec.h AlvarezRuso/ARConstants.h AlvarezRuso/AREikonalSolution.h AlvarezRuso/ARSampledNucleus.h AlvarezRuso/ARWavefunction.h AlvarezRuso/ARWFSolution.h AlvarezRuso/IntegrationTools.h AlvarezRuso/LinkDef.h AlvarezRuso/_ROOT_DICT_AlvarezRuso.h BaryonResonance/BaryonResList.h BaryonResonance/BaryonResonance.h BaryonResonance/BaryonResUtils.h BaryonResonance/LinkDef.h BaryonResonance/_ROOT_DICT_BaryonResonance.h Base/DISStructureFunc.h Base/DISStructureFuncModelI.h Base/LinkDef.h Base/QELFormFactors.h Base/QELFormFactorsModelI.h Base/_ROOT_DICT_Base.h Base/XSecAlgorithmI.h Base/XSecIntegratorI.h BergerSehgal/BergerSehgalCOHPiPXSec2015.h BergerSehgal/BergerSehgalFMCOHPiPXSec2015.h BergerSehgal/LinkDef.h BergerSehgal/_ROOT_DICT_BergerSehgal.h BodekYang/BYPDF.h BodekYang/BYStrucFunc.h BodekYang/LinkDef.h BodekYang/_ROOT_DICT_BodekYang.h Charm/AivazisCharmPXSecLO.h Charm/KovalenkoQELCharmPXSec.h Charm/LinkDef.h Charm/_ROOT_DICT_Charm.h Charm/SlowRsclCharmDISPXSecLO.h Coherent/COHElasticPXSec.h Coherent/COHElHadronicSystemGenerator.h Coherent/COHElKinematicsGenerator.h Coherent/COHHadronicSystemGenerator.h Coherent/COHInteractionListGenerator.h Coherent/COHKinematicsGenerator.h Coherent/COHPrimaryLeptonGenerator.h Coherent/LinkDef.h Coherent/_ROOT_DICT_Coherent.h Conventions/Constants.h Conventions/Controls.h Conventions/EnvSnapshot.h Conventions/GBuild.h Conventions/GMode.h Conventions/GVersion.h Conventions/KinePhaseSpace.h Conventions/KineVar.h Conventions/RefFrame.h Conventions/Units.h Conventions/XmlParserStatus.h CrossSections/COHXSecAR.h CrossSections/COHXSec.h CrossSections/DISXSec.h CrossSections/GSLXSecFunc.h CrossSections/IMDXSec.h CrossSections/LinkDef.h CrossSections/NuElectronXSec.h CrossSections/QELXSec.h CrossSections/RESXSec.h CrossSections/_ROOT_DICT_CrossSections.h Decay/BaryonResonanceDecayer.h Decay/DecayerInputs.h Decay/DecayModelI.h Decay/LinkDef.h Decay/PythiaDecayer.h Decay/_ROOT_DICT_Decay.h Diffractive/DFRHadronicSystemGenerator.h Diffractive/DFRInteractionListGenerator.h Diffractive/DFRKinematicsGenerator.h Diffractive/DFRPrimaryLeptonGenerator.h Diffractive/LinkDef.h Diffractive/_ROOT_DICT_Diffractive.h DIS/DISHadronicSystemGenerator.h DIS/DISInteractionListGenerator.h DIS/DISKinematicsGenerator.h DIS/DISPrimaryLeptonGenerator.h DIS/LinkDef.h DIS/_ROOT_DICT_DIS.h Elastic/AhrensNCELPXSec.h Elastic/LinkDef.h Elastic/_ROOT_DICT_Elastic.h Elastic/RosenbluthPXSec.h ElFF/BBA03ELFormFactorsModel.h ElFF/BBA05ELFormFactorsModel.h ElFF/BBA07ELFormFactorsModel.h ElFF/DipoleELFormFactorsModel.h ElFF/ELFormFactors.h ElFF/ELFormFactorsModelI.h ElFF/LinkDef.h ElFF/_ROOT_DICT_ElFF.h ElFF/TransverseEnhancementFFModel.h EVGCore/EventGenerator.h EVGCore/EventGeneratorI.h EVGCore/EventGeneratorListAssembler.h EVGCore/EventGeneratorList.h EVGCore/EventRecord.h EVGCore/EventRecordVisitorI.h EVGCore/EVGThreadException.h EVGCore/GVldContext.h EVGCore/InteractionGeneratorMap.h EVGCore/InteractionListAssembler.h EVGCore/InteractionListGeneratorI.h EVGCore/InteractionList.h EVGCore/InteractionSelectorI.h EVGCore/LinkDef.h EVGCore/PhysInteractionSelector.h EVGCore/_ROOT_DICT_EVGCore.h EVGCore/RunningThreadInfo.h EVGCore/ToyInteractionSelector.h EVGCore/XSecAlgorithmMap.h EVGDrivers/GeomAnalyzerI.h EVGDrivers/GEVGDriver.h EVGDrivers/GEVGPool.h EVGDrivers/GFluxI.h EVGDrivers/GMCJDriver.h EVGDrivers/GMCJMonitor.h EVGDrivers/LinkDef.h EVGDrivers/PathLengthList.h EVGDrivers/_ROOT_DICT_EVGDrivers.h EVGModules/FermiMover.h EVGModules/HadronicSystemGenerator.h EVGModules/HadronTransporter.h EVGModules/InitialStateAppender.h EVGModules/KineGeneratorWithCache.h EVGModules/LinkDef.h EVGModules/NucBindEnergyAggregator.h EVGModules/NucDeExcitationSim.h EVGModules/PauliBlocker.h EVGModules/PrimaryLeptonGenerator.h EVGModules/_ROOT_DICT_EVGModules.h EVGModules/UnstableParticleDecayer.h EVGModules/VertexGenerator.h FluxDrivers/GAstroFlux.h FluxDrivers/GAtmoFlux.h FluxDrivers/GBartolAtmoFlux.h FluxDrivers/GCylindTH1Flux.h FluxDrivers/GFlavorMap.h FluxDrivers/GFlavorMixerFactory.h FluxDrivers/GFlavorMixerI.h FluxDrivers/GFlukaAtmo3DFlux.h FluxDrivers/GFluxBlender.h FluxDrivers/GFluxDriverFactory.h FluxDrivers/GFluxExposureI.h FluxDrivers/GFluxFileConfigI.h FluxDrivers/GJPARCNuFlux.h FluxDrivers/GMonoEnergeticFlux.h FluxDrivers/GNuMIFlux.h FluxDrivers/GSimpleNtpFlux.h FluxDrivers/LinkDef.h FluxDrivers/_ROOT_DICT_FluxDrivers.h Fragmentation/CharmHadronization.h Fragmentation/CollinsSpillerFragm.h Fragmentation/FragmentationFunctionI.h Fragmentation/FragmentationFunctions.h Fragmentation/HadronizationModelBase.h Fragmentation/HadronizationModelI.h Fragmentation/KNOHadronization.h Fragmentation/KNOPythiaHadronization.h Fragmentation/LinkDef.h Fragmentation/Multiplicity.h Fragmentation/PetersonFragm.h Fragmentation/PythiaHadronization.h Fragmentation/_ROOT_DICT_Fragmentation.h Geo/FidShape.h Geo/GeomVolSelectorBasic.h Geo/GeomVolSelectorFiducial.h Geo/GeomVolSelectorI.h Geo/GeomVolSelectorRockBox.h Geo/GeoUtils.h Geo/LinkDef.h Geo/PathSegmentList.h Geo/PointGeomAnalyzer.h Geo/_ROOT_DICT_Geo.h Geo/ROOTGeomAnalyzer.h GHEP/GHepFlags.h GHEP/GHepParticle.h GHEP/GHepRecord.h GHEP/GHepRecordHistory.h GHEP/GHepStatus.h GHEP/GHepUtils.h GHEP/GHepVirtualListFolder.h GHEP/GHepVirtualList.h GHEP/LinkDef.h GHEP/_ROOT_DICT_GHEP.h GiBUU/GiBUUData.h GiBUU/GiBUURESPXSec.h GiBUU/LinkDef.h GiBUU/_ROOT_DICT_GiBUU.h HadronTransport/HAIntranuke2014.h HadronTransport/HAIntranuke2015.h HadronTransport/HAIntranuke.h HadronTransport/HNIntranuke2014.h HadronTransport/HNIntranuke2015.h HadronTransport/HNIntranuke.h HadronTransport/Intranuke2014.h HadronTransport/Intranuke2015.h HadronTransport/Intranuke.h HadronTransport/INukeDeltaPropg.h HadronTransport/INukeException.h HadronTransport/INukeHadroData2014.h HadronTransport/INukeHadroData2015.h HadronTransport/INukeHadroData.h HadronTransport/INukeHadroFates.h HadronTransport/INukeMode.h HadronTransport/INukeNucleonCorr.h HadronTransport/INukeOsetFormula.h HadronTransport/INukeOset.h HadronTransport/INukeOsetTable.h HadronTransport/INukeUtils2014.h HadronTransport/INukeUtils2015.h HadronTransport/INukeUtils.h HadronTransport/LinkDef.h HadronTransport/_ROOT_DICT_HadronTransport.h Interaction/InitialState.h Interaction/Interaction.h Interaction/InteractionType.h Interaction/Kinematics.h Interaction/KPhaseSpace.h Interaction/LinkDef.h Interaction/ProcessInfo.h Interaction/_ROOT_DICT_Interaction.h Interaction/ScatteringType.h Interaction/SppChannel.h Interaction/Target.h Interaction/XclsTag.h LlewellynSmith/LinkDef.h LlewellynSmith/LwlynSmithFFCC.h LlewellynSmith/LwlynSmithFF.h LlewellynSmith/LwlynSmithFFNC.h LlewellynSmith/LwlynSmithQELCCPXSec.h LlewellynSmith/_ROOT_DICT_LlewellynSmith.h Masterclass/FastSimCherenkov.h Masterclass/FastSimScintCalo.h Masterclass/GNuMcMainFrame.h Masterclass/LinkDef.h Masterclass/MCTruthDisplay.h Masterclass/_ROOT_DICT_Masterclass.h MEC/LinkDef.h MEC/MECGenerator.h MEC/MECInteractionListGenerator.h MEC/MECPXSec.h MEC/_ROOT_DICT_MEC.h Messenger/LinkDef.h Messenger/Messenger.h MuELoss/BetheBlochMaterialParams.h MuELoss/BetheBlochModel.h MuELoss/BezrukovBugaevModel.h MuELoss/KokoulinPetrukhinModel.h MuELoss/LinkDef.h MuELoss/MuELMaterial.h MuELoss/MuELossI.h MuELoss/MuELProcess.h MuELoss/PetrukhinShestakovModel.h MuELoss/_ROOT_DICT_MuELoss.h Ntuple/LinkDef.h Ntuple/NtpMCDTime.h Ntuple/NtpMCEventRecord.h Ntuple/NtpMCFormat.h Ntuple/NtpMCJobConfig.h Ntuple/NtpMCJobEnv.h Ntuple/NtpMCRecHeader.h Ntuple/NtpMCRecordI.h Ntuple/NtpMCTreeHeader.h Ntuple/NtpWriter.h Ntuple/_ROOT_DICT_Ntuple.h Nuclear/EffectiveSF.h Nuclear/FermiMomentumTable.h Nuclear/FermiMomentumTablePool.h Nuclear/FGMBodekRitchie.h Nuclear/LinkDef.h Nuclear/NuclearData.h Nuclear/NuclearModel.h Nuclear/NuclearModelI.h Nuclear/NuclearModelMap.h Nuclear/_ROOT_DICT_Nuclear.h Nuclear/SpectralFunc1d.h Nuclear/SpectralFunc.h NucleonDecay/DummyInteractionListGenerator.h NucleonDecay/DummyPXSec.h NucleonDecay/LinkDef.h NucleonDecay/NucleonDecayMode.h NucleonDecay/NucleonDecayPrimaryVtxGenerator.h NucleonDecay/NucleonDecayUtils.h NucleonDecay/_ROOT_DICT_NucleonDecay.h NuE/BardinIMDRadCorPXSec.h NuE/IMDAnnihilationPXSec.h NuE/LinkDef.h NuE/NuEInteractionListGenerator.h NuE/NuEKinematicsGenerator.h NuE/NuElectronPXSec.h NuE/NuEPrimaryLeptonGenerator.h NuE/NuETargetRemnantGenerator.h NuE/_ROOT_DICT_NuE.h NuGamma/AMNuGammaGenerator.h NuGamma/AMNuGammaInteractionListGenerator.h NuGamma/H3AMNuGammaPXSec.h NuGamma/LinkDef.h NuGamma/_ROOT_DICT_NuGamma.h Numerical/BLI2D.h Numerical/GFunc.h Numerical/LinkDef.h Numerical/RandomGen.h Numerical/_ROOT_DICT_Numerical.h Numerical/Spline.h PartonModel/LinkDef.h PartonModel/QPMDISPXSec.h PartonModel/QPMDISStrucFuncBase.h PartonModel/QPMDISStrucFunc.h PartonModel/_ROOT_DICT_GQPM.h Paschos/LinkDef.h Paschos/P33PaschosLalakulichPXSec.h PDF/LinkDef.h PDF/PDF.h PDF/PDFLIB.h PDF/PDFModelI.h PDF/PDFt.h PDF/_ROOT_DICT_PDF.h PDG/LinkDef.h PDG/PDGCodeList.h PDG/PDGCodes.h PDG/PDGLibrary.h PDG/PDGUtils.h PDG/_ROOT_DICT_PDG.h QEL/LinkDef.h QEL/QELHadronicSystemGenerator.h QEL/QELInteractionListGenerator.h QEL/QELKinematicsGenerator.h QEL/QELPrimaryLeptonGenerator.h QEL/_ROOT_DICT_QEL.h Registry/LinkDef.h Registry/Registry.h Registry/RegistryItem.h Registry/RegistryItemI.h Registry/RegistryItemTypeDef.h Registry/RegistryItemTypeId.h Registry/_ROOT_DICT_Registry.h ReinSehgal/BergerSehgalRESPXSec2014.h ReinSehgal/BSKLNBaseRESPXSec2014.h ReinSehgal/FKR.h ReinSehgal/KuzminLyubushkinNaumovRESPXSec2014.h ReinSehgal/LinkDef.h ReinSehgal/ReinDFRPXSec.h ReinSehgal/ReinSehgalCOHPiPXSec.h ReinSehgal/ReinSehgalRESPXSec.h ReinSehgal/ReinSehgalRESXSec.h ReinSehgal/ReinSehgalRESXSecWithCache.h ReinSehgal/ReinSehgalSPPPXSec.h ReinSehgal/ReinSehgalSPPXSec.h ReinSehgal/_ROOT_DICT_ReinSehgal.h ReinSehgal/RSHelicityAmpl.h ReinSehgal/RSHelicityAmplModelCC.h ReinSehgal/RSHelicityAmplModelEMn.h ReinSehgal/RSHelicityAmplModelEMp.h ReinSehgal/RSHelicityAmplModelI.h ReinSehgal/RSHelicityAmplModelNCn.h ReinSehgal/RSHelicityAmplModelNCp.h RES/LinkDef.h RES/RESHadronicSystemGenerator.h RES/RESInteractionListGenerator.h RES/RESKinematicsGenerator.h RES/RESPrimaryLeptonGenerator.h RES/_ROOT_DICT_RES.h RES/RSPPHadronicSystemGenerator.h RES/RSPPInteractionListGenerator.h RES/RSPPResonanceSelector.h ReWeight/GReWeightAGKY.h ReWeight/GReWeightDISNuclMod.h ReWeight/GReWeightFGM.h ReWeight/GReWeightFZone.h ReWeight/GReWeight.h ReWeight/GReWeightI.h ReWeight/GReWeightINuke.h ReWeight/GReWeightINukeParams.h ReWeight/GReWeightIOBranchDesc.h ReWeight/GReWeightIORecord.h ReWeight/GReWeightNonResonanceBkg.h ReWeight/GReWeightNuXSecCCQE.h ReWeight/GReWeightNuXSecCCQEvec.h ReWeight/GReWeightNuXSecCCRES.h ReWeight/GReWeightNuXSecCOH.h ReWeight/GReWeightNuXSecDIS.h ReWeight/GReWeightNuXSecHelper.h ReWeight/GReWeightNuXSecNCEL.h ReWeight/GReWeightNuXSecNC.h ReWeight/GReWeightNuXSecNCRES.h ReWeight/GReWeightResonanceDecay.h ReWeight/GReWeightUtils.h ReWeight/GSyst.h ReWeight/GSystSet.h ReWeight/GSystUncertainty.h ReWeight/LinkDef.h ReWeight/_ROOT_DICT_ReWeight.h SingleKaon/AlamSimoAtharVacasSKPXSec2014.h SingleKaon/AlamSimoAtharVacasSKXSec.h SingleKaon/LinkDef.h SingleKaon/_ROOT_DICT_SingleKaon.h SingleKaon/SKHadronicSystemGenerator.h SingleKaon/SKInteractionListGenerator.h SingleKaon/SKKinematicsGenerator.h SingleKaon/SKPrimaryLeptonGenerator.h Utils/AppInit.h Utils/BWFunc.h Utils/CacheBranchFx.h Utils/CacheBranchI.h Utils/CacheBranchNtp.h Utils/Cache.h Utils/CmdLnArgParser.h Utils/ConfigIsotopeMapUtils.h Utils/FragmRecUtils.h Utils/GArray.h Utils/GSimFiles.h Utils/GSLUtils.h Utils/GUIUtils.h Utils/HadXSUtils.h Utils/KineUtils.h Utils/LinkDef.h Utils/MathUtils.h Utils/NaturalIsotopes.h Utils/nm.h Utils/NuclearUtils.h Utils/PhysUtils.h Utils/PREM.h Utils/PrintUtils.h Utils/Range1.h Utils/_ROOT_DICT_Utils.h Utils/RunOpt.h Utils/StringUtils.h Utils/Style.h Utils/SystemUtils.h Utils/T2KEvGenMetaData.h Utils/UnitUtils.h Utils/XmlParserUtils.h Utils/XSecSplineList.h VHE/GLRESGenerator.h VHE/GLRESInteractionListGenerator.h VHE/GLRESPXSec.h VHE/LinkDef.h VHE/_ROOT_DICT_VHE.h VLE/IBDHadronicSystemGenerator.h VLE/IBDInteractionListGenerator.h VLE/IBDKinematicsGenerator.h VLE/IBDPrimaryLeptonGenerator.h VLE/IBDXSecMap.h VLE/KLVOxygenIBDPXSec.h VLE/LinkDef.h VLE/StrumiaVissaniIBDPXSec.h VLE/VLEConstants.h


